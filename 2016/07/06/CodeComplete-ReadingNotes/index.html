<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="读书,代码大全," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="第一部分 打好基础 Laying the Foundation第一章 欢迎进入软件构建的世界 Welcome to Software Construction
什么是软件的构建
定义问题
需求分析
规划构建
软件架构 或者 高层设计
详细设计
编码与调试
单元测试
集成测试
集成
系统测试
保障维护


总结
软件构建是软件开发中唯一不可缺少的部分，也就是必须完成的部分
软件的构建主要包括：详细设">
<meta property="og:type" content="article">
<meta property="og:title" content="代码大全读书笔记">
<meta property="og:url" content="https://yoursite.com/2016/07/06/CodeComplete-ReadingNotes/index.html">
<meta property="og:site_name" content="AaronChan Blog">
<meta property="og:description" content="第一部分 打好基础 Laying the Foundation第一章 欢迎进入软件构建的世界 Welcome to Software Construction
什么是软件的构建
定义问题
需求分析
规划构建
软件架构 或者 高层设计
详细设计
编码与调试
单元测试
集成测试
集成
系统测试
保障维护


总结
软件构建是软件开发中唯一不可缺少的部分，也就是必须完成的部分
软件的构建主要包括：详细设">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1767214-26333d8e59a26e9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1767214-4bea2d4078308180.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/ upload_images/1767214-a1597a1c648fdf02.png?imageMogr2/auto-orient/ strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2016-07-10T12:45:14.887Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="代码大全读书笔记">
<meta name="twitter:description" content="第一部分 打好基础 Laying the Foundation第一章 欢迎进入软件构建的世界 Welcome to Software Construction
什么是软件的构建
定义问题
需求分析
规划构建
软件架构 或者 高层设计
详细设计
编码与调试
单元测试
集成测试
集成
系统测试
保障维护


总结
软件构建是软件开发中唯一不可缺少的部分，也就是必须完成的部分
软件的构建主要包括：详细设">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1767214-26333d8e59a26e9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://yoursite.com/2016/07/06/CodeComplete-ReadingNotes/"/>

  <title> 代码大全读书笔记 | AaronChan Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?51f0c6f8829e2634ec8f9bfc8220f514";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">AaronChan Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">陈晓城</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                代码大全读书笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-06T23:55:00+08:00" content="2016-07-06">
              2016-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/06/CodeComplete-ReadingNotes/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/06/CodeComplete-ReadingNotes/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="第一部分-打好基础-Laying-the-Foundation"><a href="#第一部分-打好基础-Laying-the-Foundation" class="headerlink" title="第一部分 打好基础 Laying the Foundation"></a>第一部分 打好基础 Laying the Foundation</h2><h3 id="第一章-欢迎进入软件构建的世界-Welcome-to-Software-Construction"><a href="#第一章-欢迎进入软件构建的世界-Welcome-to-Software-Construction" class="headerlink" title="第一章 欢迎进入软件构建的世界 Welcome to Software Construction"></a>第一章 欢迎进入软件构建的世界 Welcome to Software Construction</h3><ul>
<li>什么是软件的构建<ul>
<li>定义问题</li>
<li>需求分析</li>
<li>规划构建</li>
<li>软件架构 或者 高层设计</li>
<li>详细设计</li>
<li>编码与调试</li>
<li>单元测试</li>
<li>集成测试</li>
<li>集成</li>
<li>系统测试</li>
<li>保障维护</li>
</ul>
</li>
<li>总结<ul>
<li>软件构建是软件开发中唯一不可缺少的部分，也就是必须完成的部分</li>
<li>软件的构建主要包括：详细设计、编码调试、集成和开发者测试（单元测试和集成测试）</li>
<li><strong><em>你对软件构建的理解程度决定 程序员的优秀程度</em></strong></li>
</ul>
</li>
</ul>
<h3 id="第二章-用隐喻来更充分地理解软件开发-Metaphors-for-a-Richer-Understanding-of-Software-Development"><a href="#第二章-用隐喻来更充分地理解软件开发-Metaphors-for-a-Richer-Understanding-of-Software-Development" class="headerlink" title="第二章 用隐喻来更充分地理解软件开发 Metaphors for a Richer Understanding of Software Development"></a>第二章 用隐喻来更充分地理解软件开发 Metaphors for a Richer Understanding of Software Development</h3><h3 id="第三章-三思而后行：前期准备-Measure-Twice-Cut-Once-Upstream-Prerequisites"><a href="#第三章-三思而后行：前期准备-Measure-Twice-Cut-Once-Upstream-Prerequisites" class="headerlink" title="第三章 三思而后行：前期准备 Measure Twice, Cut Once: Upstream Prerequisites"></a>第三章 三思而后行：前期准备 Measure Twice, Cut Once: Upstream Prerequisites</h3><h3 id="第四章-关键的『构建』决策-Key-Construction-Decisions"><a href="#第四章-关键的『构建』决策-Key-Construction-Decisions" class="headerlink" title="第四章  关键的『构建』决策 Key Construction Decisions"></a>第四章  关键的『构建』决策 Key Construction Decisions</h3><h2 id="第二部分-创建高质量的代码-Creating-High-Quality-Code"><a href="#第二部分-创建高质量的代码-Creating-High-Quality-Code" class="headerlink" title="第二部分 创建高质量的代码 Creating-High Quality Code"></a>第二部分 创建高质量的代码 Creating-High Quality Code</h2><h3 id="第五章-软件构建中的设计-Design-in-Construction"><a href="#第五章-软件构建中的设计-Design-in-Construction" class="headerlink" title="第五章 软件构建中的设计 Design in Construction"></a>第五章 软件构建中的设计 Design in Construction</h3><h3 id="第六章-可以工作的类-Working-Classes-抽象是以简化方式看待复杂操作的能力"><a href="#第六章-可以工作的类-Working-Classes-抽象是以简化方式看待复杂操作的能力" class="headerlink" title="第六章 可以工作的类 Working Classes:抽象是以简化方式看待复杂操作的能力"></a>第六章 可以工作的类 Working Classes:<strong><em>抽象是以简化方式看待复杂操作的能力</em></strong></h3><ul>
<li>6.1类的基础：抽象数据类型 ADTs<ul>
<li>ADT，abstract data type 抽象数据类型。它指的是一些<strong>数据</strong>及对这些数据的<strong>操作</strong>的<strong>集合</strong>。这里的<em>“数据”</em>，不仅仅是数学上或者软件工程中的数据，而是现实世界中可以操作的<strong><em>实体</em></strong></li>
<li>ADT 的好处：</li>
<li>隐藏实现细节（可能会有后续操作）</li>
<li>容易改动（更改数据结构，优化提高性能）</li>
<li>让接口提供更多信息（通过名称）</li>
<li>可读性提高</li>
<li>不需要多次传值（相关操作需要用到变量都放在ADT里面了）</li>
<li>把常见的底层数据类型（栈 队列）创建为ADT并使用<blockquote>
<p>如出场演员名单（底层数据类型是列表）</p>
</blockquote>
</li>
<li>对于<em>应用层面</em>上ADT，最好在原有ADT的基础上创建一个针对现实世界问题的抽象层次。</li>
<li>简单的事情可以抽取成ADT（方便扩展后续操作）</li>
<li>在支持面向对象的语言，ADT可以用自己的class(类)实现。<strong><em>class=ADT+继承+多态</em></strong></li>
</ul>
</li>
<li>6.2良好的类接口：<strong><em>用接口去展示抽象，确保细节隐藏在抽象背后</em></strong><ul>
<li>接口中的每个子程序都朝着这个<em>一致</em>的目标而工作</li>
<li>类的接口要展示一致的抽象层次，<strong><em>一个类只能实现一个ADT</em></strong>，不然就要拆分</li>
<li>要理解类要抽象出什么功能，避免把使用的类库或者容器类暴露出来</li>
<li>尽可能让接口可编程(programatic,编译器强制要求)，而不是表达语义(  sematic,通过方法名和注释)。<blockquote>
<p>比如多个类的初始化有先后顺序；一个类没有初始化调用会报错</p>
</blockquote>
</li>
<li>扩展的时候要注意新增公用方法的 抽象的一致性</li>
<li>不要对类的使用者做任何假设，接口已经隐含了契约(接口已经提供了调用的条件说明)</li>
<li>语义上的封装比语法上的封装要困难(公用接口不要暴露内部实现和数据) <blockquote>
<p>P142 很多例子</p>
</blockquote>
</li>
<li>封装和抽象要么两者皆有，要么全部没有</li>
</ul>
</li>
<li>6.3有关设计和实现的问题：包含/继承/成员函数/数据成员/类之间的耦合性<ul>
<li>包含(has a “有一个的关系”)：数据成员的限制：7-+2<blockquote>
<p>数据成员<strong><em>都是</em></strong>基本数据类型，数据成员不超过<strong><em>9</em></strong>；数据成员<strong><em>都是</em></strong>    复杂对象，数据成员不超过<strong><em>5</em></strong></p>
</blockquote>
</li>
<li>继承（is a “是一个的关系”）( 使用时会增加复杂度，有违软件的技术使命-管理复杂度的)<ul>
<li>要考虑方法和属性对派生类是否可见，方法是否要有默认的实现，是否可以覆盖？</li>
<li>继承要符合<strong><em>里氏替换原则</em></strong>:对于基类定义的接口，在派生类的语义应该是相同的</li>
<li>不要覆盖不可覆盖的方法(不要新建一个与基类的private相同的方法)</li>
<li>只有一个派生类，可能犯了提前设计的毛病</li>
<li>继承不要超过2-3层，派生类总数不超过该7+-2个；</li>
<li>尽可能让数据让数据时private，因为<strong><em>继承会破坏封装</em></strong></li>
<li>如果多个类共享数据而非行为，创建这些类包含共用对象</li>
<li>如果多个类共享行为而非数据，在基类定义接口，继承基类</li>
<li>如果多个类共享行为和数据，在基类定义接口和数据成员，继承基类</li>
<li>当你想由基类控制接口时，用继承，由自己控制接口，用包含</li>
</ul>
</li>
<li>成员函数和数据成员：<ul>
<li><strong><em>减少以下数字的数量</em></strong><ul>
<li>所实例化对象的种类</li>
<li>调用实例化对象的子程序的数量</li>
<li>调用由其他对象返回对象的子程序数量</li>
<li>子程序的数量</li>
</ul>
</li>
<li>构造函数<ul>
<li>尽可能在构造函数中初始化全部数据成员</li>
</ul>
</li>
<li>6.4创建类的原因</li>
<li>对现实对象的建模</li>
<li>对抽象对象的建模（如shape就是抽象对象，<strong><em>得出恰当的抽象对象很重要</em></strong>）</li>
<li>降低复杂度（调用类的接口不用关心实现细节）</li>
<li>隔离复杂度</li>
<li>隐藏实现细节</li>
<li>限制变化的影响范围</li>
<li>隐藏全局数据</li>
<li>让参数传递更流畅</li>
<li>创建中心控制点</li>
<li>让代码重用</li>
<li>为程序族做规划</li>
<li>把相关操作放在一起（子程序的组合）</li>
<li>实现特定的重构</li>
<li>6.5与具体编程语言有关的问题</li>
<li>6.6超越类：包</li>
<li>类的质量核对表P157-P158</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第七章-高质量的子程序-High-Quality-Routines"><a href="#第七章-高质量的子程序-High-Quality-Routines" class="headerlink" title="第七章 高质量的子程序 High-Quality Routines"></a>第七章 高质量的子程序 High-Quality Routines</h3><ul>
<li>7.1 创建子程序（routines）的正当理由：提高程序管理能力，包括提高可读性、可靠性和可修改性，节省代码空间是次要，或者是副作用（side effect）。<ul>
<li>降低复杂度</li>
<li>引入中间，易懂的抽象</li>
<li>避免重复</li>
<li>支持子类化(subclassing)</li>
<li>隐藏顺序</li>
<li>隐藏指针操作</li>
<li>提高可移植性</li>
<li>简化布尔判断</li>
<li>改善性能</li>
<li>确保所有程序都很小</li>
</ul>
</li>
<li>7.2 在子程序层上设计(Design at the Routine Level)：抽象和封装理念适合类层次的设计，内聚性适合子程序设计<ul>
<li>内聚性(cohesion)：指子程序中各种操作之间联系的紧密程度。(一个子程序就干一个活)</li>
<li>功能内聚性：一个子程序只干一件事情</li>
<li>以下是不够理想的内聚性，但是有作用的。<ul>
<li>顺序上的内聚性：子程序包含按特定顺序执行的操作，这些操作共享数据，而且只有在操作 全部执行完毕的时候才达到一项完整的功能</li>
<li>通信上的内聚性：指一个子程序内的不同操作用同样的数据，但不存在任何的联系</li>
<li>临时的内聚性：一些因为需要同时操作而放在一起的操作<blockquote>
<p>startUp() </p>
</blockquote>
</li>
</ul>
</li>
<li>以下是不可取的内聚性<ul>
<li>过程内聚性：把一组操作放在子程序中并按照特定顺序执行，除此之外没有其他彼此的联系</li>
<li>逻辑上内聚性（其实是缺乏逻辑的内聚性）：把若干操作放入同一子程序，通过传入的控 制符执行不同的操作<ul>
<li>如果子程序仅有由一系列if  else语句以及其他子程序语句组成，这样的逻辑上内聚性的子程序是<strong><em>可以的</em></strong> ，就是这个子程序只发出各种指令，不进行任何的处理，那么他就是一个<strong><em>事件处理器( event handler)</em></strong></li>
</ul>
</li>
<li>巧合的内聚性：子程序的操作之间没有任何的 联系</li>
</ul>
</li>
</ul>
</li>
<li>7.3 好的子程序的名字 Good Routine Names<ul>
<li>描述子程序所做的<strong><em>所有</em></strong>的事</li>
<li>避免使用无意义、模糊或者表达不清的动词 <code>event handling</code>事件处理除外<blockquote>
<p><code>handleCalculation()</code><br><code>PerformServices()</code><br><code>OutputUser()</code><br><code>ProcessInput()</code><br><code>DealwithOutPut</code></p>
</blockquote>
</li>
<li>不仅仅通过数字形成不同子程序名<blockquote>
<p><code>outPut1()</code>; <code>outPut2()</code></p>
</blockquote>
</li>
<li>根据需求确定子程序的名称长度</li>
<li>函数命名时要对函数的返回值有所描述<blockquote>
<p><code>printer.isReady()</code><br><code>customerId.next()</code></p>
</blockquote>
</li>
<li>给子程序命名时要使用语气强烈的动词加宾语的形式，在面向对象语言中，不用再过程(Procedure)名中<strong><em>不用加入对象名(宾语)</em></strong><blockquote>
<p><code>document.print()</code> <code>orderInfo.check()</code></p>
</blockquote>
</li>
<li>准确使用对仗词<blockquote>
<p><code>add/remove</code> <code>insert/delete</code> <code>start/stop</code> <code>up/down</code><br><code>begin/end</code> <code>increment/decrement</code> <code>open/close</code> <code>get/set</code><br><code>first/last</code> <code>old/new</code> <code>min/max</code> <code>show/hide</code><br><code>create/destory</code> <code>lock/unlock</code> <code>source/target</code> <code>get/put</code></p>
</blockquote>
</li>
<li>为常用操作确立命名规则</li>
</ul>
</li>
<li>7.4 子程序可以写多长 How long can a Routine be<ul>
<li>虽然有很多研究但是仍然没有一个公认的说法，一般是<strong><em>50-200行</em></strong>左右，可以从子程序的<strong>内聚性</strong>、<strong>嵌套层次</strong>、<strong>变量数量</strong>、<strong>决策点</strong>(desicions points)和<strong>注释</strong>来决定子程序的长度，当超过<strong><em>200</em></strong>行，就要考虑在可读性上问题了。</li>
</ul>
</li>
<li>7.5 如何使用子程序参数 How to Use Routine Parameters <ul>
<li>按照输入-修改-输出的顺序排列参数：暗含了操作数据的顺序</li>
<li>如果子程序用了类似的参数，参数的排列顺序应该一致</li>
<li>使用所有的参数，没有用的要撇除</li>
<li>把状态或者出错变量放在最后，因为它们只是程序的附属</li>
<li>不要把子程序参数当做工作变量<blockquote>
<p>对输入参数进行操作，并将其作为返回值返回结果。</p>
</blockquote>
</li>
<li>在接口中对参数的假定加以说明，<strong><em>在接口文档说明</em></strong><ul>
<li>参数是仅用于输入，要被修改，还是仅用于输出</li>
<li>表示数量的参数单位（秒/分）</li>
<li>没有用枚举类型的话，应该说明状态码和错误码的含义</li>
<li>所能接受的数据范围</li>
<li>不能接受的特定数值</li>
</ul>
</li>
<li>把子程序的参数个数限制在<strong>7</strong>个以内<ul>
<li>如何一直需要传递很多参数，说明子程序之间的<strong><em>耦合</em></strong> 太过紧密。如果需要向很多不同的子程序传入<strong><em>相同的数据</em></strong>，就<strong><em> 把这些子程序组成一个类</em></strong>，并把那些经常使用的数据作为类的<strong><em>内部数据</em></strong></li>
</ul>
</li>
<li>考虑对参数使用某种输入、修改、输出的命名规则<blockquote>
<p><code>i_xxx</code>,<code>m_xxx</code>,<code>o_xxx</code> 或者 <code>Input_xxx</code>,<code>Modify_xxx</code>,<code>Output_xxx</code></p>
</blockquote>
</li>
<li>为子程序传递用以维持其接口抽象的变量和对象<ul>
<li>假如经常需要修改子程序的参数表，且都是来自同一个对象，那就传递整个对象</li>
<li>如果只是为传递几个特定的数据，把数据填入对象，再到子程序读取这些数据，那就只传递 数据的值</li>
<li>使用具名参数<strong><em>？</em></strong></li>
<li>确保实际参数与形式参数相匹配<strong><em>？</em></strong></li>
</ul>
</li>
</ul>
</li>
<li>7.6 使用函数时要特别考虑的问题<ul>
<li><strong><em>函数</em></strong>是<strong><em>有返回值</em></strong>的子程序，<strong><em>过程</em></strong>是指<strong><em>没有返回值</em></strong>的子程序</li>
<li>设置函数的返回值<ul>
<li>检查所有可能的返回路径</li>
<li>假如需要返回有关的数据，那就应该作为类的成员保存起来，而不是作为局部数据的引用或 者指针返回。</li>
</ul>
</li>
</ul>
</li>
<li>7.7 宏子程序和内联子程序 Macro Routine And Inline Routines<strong><em>？</em></strong><ul>
<li>把宏表达式整个都包含在括号内</li>
<li>把包含多条语句的宏用大括号括起来</li>
<li>用给子程序命名的方法给展开后代码形同子程序的宏命名，以便需要可以用子程序来替换宏。</li>
</ul>
</li>
<li>高质量的子程序核对表<strong><em>P185</em></strong></li>
</ul>
<h3 id="第八章-防御式编程-Defensive-Programming：子程序应该不因传入错误的数据而被破坏，哪怕是由其他子程序产生的错误的数据。即核心思想是程序都是有问题，都是要被修改。"><a href="#第八章-防御式编程-Defensive-Programming：子程序应该不因传入错误的数据而被破坏，哪怕是由其他子程序产生的错误的数据。即核心思想是程序都是有问题，都是要被修改。" class="headerlink" title="第八章 防御式编程 Defensive Programming：子程序应该不因传入错误的数据而被破坏，哪怕是由其他子程序产生的错误的数据。即核心思想是程序都是有问题，都是要被修改。"></a>第八章 防御式编程 Defensive Programming：<strong><em>子程序应该不因传入错误的数据而被破坏</em></strong>，哪怕是由其他子程序产生的错误的数据。即核心思想是<strong><em>程序都是有问题，都是要被修改</em></strong>。</h3><ul>
<li>8.1 保护程序免遭非法输入数据破坏 Protecting your program from invalid inputs<ul>
<li>检查所有来源于外部数据的值:从<strong><em>文件</em></strong>、<strong><em>网络</em></strong>、<strong><em>用户</em></strong>或者其他外部接口获得的数据应该检查其有效性</li>
<li>检查子程序所有输入参数的值</li>
<li>决定如何处理错误的输入数据</li>
</ul>
</li>
<li>8.2 断言 Assertions<ul>
<li>在开发期间使用的，让程序运行时进行自检的代码，一个断言一般包含两个参数，一个布尔表达式，一个断言为假时显示的消息。断言程序执行的前条件和后条件</li>
<li>用断言检查一下假定：<ul>
<li>输入参数或者输出参数在预定范围内</li>
<li>子程序开始（结束）文件或者流处于开启或者关闭的状态</li>
<li>子程序开始（结束）文件或者流读写的位置位于开头或者结尾</li>
<li>指针不为空 </li>
<li>传入子程序的数组或者其他容器至少能存储X个数据元素</li>
<li>表已经初始化，存储着真实的数据</li>
<li>仅用于输入的变量的值没有被子程序改变</li>
<li>子程序开始或者结束的时候，某个容器为满或者为空</li>
<li>高度优化的子程序与运行缓慢但逻辑清晰的子程序运行结果一致</li>
</ul>
</li>
<li>对于高健壮性的代码，应该先断言再处理错误</li>
</ul>
</li>
<li>8.3 错误处理技术 Erro-Handling Technique：<strong><em>断言</em></strong>处理<strong><em>不应该发生</em></strong>的错误，<strong><em>错误处理技术</em></strong>处理<strong><em>预料中</em></strong>可能发生的错误。<ul>
<li>返回中立值<ul>
<li>数值计算返回0</li>
<li>字符串操作返回空字符串</li>
<li>指针操作返回空指针等</li>
</ul>
</li>
<li>换用下一个正确的数据<blockquote>
<p>温度计读取数值失败，可以等下一次如1/100秒读取</p>
</blockquote>
</li>
<li>返回前次相同的数据<blockquote>
<p>上面温度计的例子同样适用</p>
</blockquote>
</li>
<li>换用最接近的合法值<blockquote>
<p>得到字符串长度小于0，那返回0</p>
</blockquote>
</li>
<li>把警告信息写到日志</li>
<li>返回一个错误码</li>
<li>调用处理错误的对象或者子程序</li>
<li>健壮性 vs 正确性 robustness vs correctness</li>
<li>高层次设计对错误处理方式的影响</li>
</ul>
</li>
<li>8.4 异常Exceptions：是把错误或者异常事件传递给调用方代码的特殊手段<ul>
<li>用异常通知其他的程序，发生了不可忽略的错误</li>
<li>与断言相似，都是用来处理<strong><em>罕见甚至不可能出现</em></strong>的情况<strong><em>???</em></strong></li>
<li>是处理意外的有效途径，但是<strong><em>增加复杂度</em></strong></li>
<li>不能用异常来推卸责任，明确是由自身处理异常还是由调用方处理异常</li>
<li>避免在解构函数和构造函数抛出异常，除非在同一地方进行捕获</li>
<li>在<strong><em>恰当的抽象层次抛出异常</em></strong>，就异常应于当前接口的抽象层次一致，避免暴露实现细节和内部信息</li>
<li>避免使用空的catch语句，除非将catch的异常文档化  </li>
<li>了解函数库可能抛出的异常、</li>
<li>考虑创造一个集中的异常报告机制，就是对于异常进行统一的格式化并记录和存储</li>
<li>把项目中对异常的使用标准化 <ul>
<li>可以定义项目特定的异常类，记录日志、报告错误的集中起来和标准化</li>
<li>规定何种场合异常时需要局部处理</li>
<li>规定何种场合异常只能抛出，不能局部处理</li>
<li>考虑异常的替换方案</li>
</ul>
</li>
</ul>
</li>
<li>8.5 隔离程序，使之包容由程序错误造成的伤害Barricade Your Program to Contain the Damage Caused by Errors<ul>
<li>隔栏是一种容错的策略 damage containment strategy</li>
<li>可以在类的层面上采用这种方法，在类的<strong><em>公有方法</em></strong>假定输入的数据时<strong><em>不安全</em></strong>的，对数据进行<strong><em>检查并清理</em></strong>，之后再将数据传给<strong><em>私有方法</em></strong>，类的私有方法假定数据都是<strong><em>安全的</em></strong></li>
<li>隔栏<strong><em>外部</em></strong>的程序使用<strong><em>错误处理</em></strong>技术，在那里对数据的假定是不安全的。<strong><em>内部</em></strong>的程序使用<strong><em>断言</em></strong>技术，这样如果隔栏内的出现错误的数据，就是<strong><em>程序上的错误</em></strong>而非数据上的错误</li>
</ul>
</li>
<li>8.6 辅助调试的代码 Debugging aids<ul>
<li>不要把自动地把产品版的限制强加于开发版上：开发版可以花费更多的资源，允许运行缓慢，允许暴露不安全的操作</li>
<li>尽早引入辅助代码</li>
<li>采用攻击式编程 offensive programming<ul>
<li>确保断言使程序中止，及时修复错误</li>
<li>case语句的default分支或者else分支产生严重的错误以致不被忽视</li>
</ul>
</li>
<li>计划移除调试辅助的代码</li>
</ul>
</li>
<li>8.7 确定在产品中该保留多少防御式代码 Determine How much Defensive Programming  to Leave  in  Production code<ul>
<li>保留那些检查<strong><em>重要错误</em></strong>的代码</li>
<li>去掉检查<strong><em>细微错误</em></strong>的代码</li>
<li>去掉可以导致<strong><em>程序硬性崩溃</em></strong>的代码：虽然便于调试，但是用户体验差</li>
<li>为你的技术支持员记录错误信息</li>
<li>确认留在代码中的错误信息是友好的(friendly):就是要严谨，正式</li>
</ul>
</li>
<li>8.8 对防御式编程采取防御姿态 Being Defensive about Defensive Programing <ul>
<li>防御式编程增加复杂度</li>
<li>防御式编程因为要检查参数使程序运行缓慢<ul>
<li>核对表 P211</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第九章-伪代码编程过程-The-Pseudocode-Programming-Process"><a href="#第九章-伪代码编程过程-The-Pseudocode-Programming-Process" class="headerlink" title="第九章 伪代码编程过程 The Pseudocode Programming Process"></a>第九章 伪代码编程过程 The Pseudocode Programming Process</h3><ul>
<li>9.1 创建类和子程序的步骤概述 Summary steps of Building Classes and Routines<ul>
<li>图9.1 at p216： <img src="http://upload-images.jianshu.io/upload_images/1767214-26333d8e59a26e9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>创建一个类的步骤 Steps in Creating a class<ul>
<li>创建类的总体设计   具体参考第六章 可以工作类<ul>
<li>定义类的职责</li>
<li>定义类要隐藏的”秘密”</li>
<li>定义类的接口所代表的抽象概念</li>
<li>决定这个类是否要从其他类派生出来</li>
<li>决定这个类是否可以被派生，即是否能被继承</li>
<li>指出类的关键公用方法</li>
<li>标识并设计出类所需要的重要数据成员 </li>
</ul>
</li>
<li>创建类的子程序  Steps in Building a routine<ul>
<li>图9.2 at p217   <img src="http://upload-images.jianshu.io/upload_images/1767214-4bea2d4078308180.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li>子程序的种类：成员访问子程序 (accessor routine ),转发到其他对象(pass-throughs)的子程序</li>
<li>步骤：设计子程序-&gt;检查设计-&gt;编写子程序的代码-&gt;检查代码</li>
</ul>
</li>
<li>复审并测试整个类  ：在子程序创建的同时经过测试，在整个类可以工作后，应该再对整体进行复查和测试，以便于发现在<strong><em>子程序独立测试层次上无法发现的问题</em></strong></li>
</ul>
</li>
</ul>
</li>
<li>9.2 伪代码 Pseudocode for Pros<ul>
<li>伪代码：描述 算法、子程序、类或者完整程序的<strong><em>工作逻辑</em></strong>、非正式的、类似英语的记法</li>
<li>伪代码的注意事项：<ul>
<li>用类似英语的语句来精确描述特定的操作</li>
<li>避免使用目标编程语言的元素，伪代码是比代码本身略高的设计层次，使用目标编程语言的元素会降低设计层次</li>
<li>在本意 intent 层面编写伪代码</li>
<li>在足够低的层次编写伪代码，以便可以近乎转化为代码</li>
<li>好的伪代码能转换为注释</li>
</ul>
</li>
<li>伪代码的好处：<ul>
<li>伪代码使得评审更容易</li>
<li>伪代码支持反复迭代精化思想：自顶向下，逐层拆解问题，解决问题</li>
<li>伪代码使变更更加容易</li>
<li>伪代码能使给代码作注释的工作量减少</li>
<li>伪代码比其他设计形式的文档更容易维护</li>
</ul>
</li>
</ul>
</li>
<li>9.3 通过伪代码编码过程创建子程序<ul>
<li>设计子程序 Design the Routine<ul>
<li>检查先决条件：子程序工作是否定义好，是不是与整体设计相匹配。是否项目必需的</li>
<li>定义子程序的解决的问题：<ul>
<li>子程序要隐藏的信息</li>
<li>子程序的输入</li>
<li>子程序的输出</li>
<li>调用子程序前确保有关的前条件成立(输入数据在特定范围内，流已经初始化等)</li>
<li>在子程序将控制权交回调用程序前，确保后条件成立( 输出数据在特定范围内，流已经关闭)</li>
</ul>
</li>
<li>为子程序命名</li>
<li>决定如何测试子程序</li>
<li>在标准库搜索可用的功能：重用好的代码，<strong><em>不重复造轮子</em></strong></li>
<li>考虑错误处理</li>
<li>考虑效率问题：<blockquote>
<p>第一种情况绝大数系统而言，效率并不是十分紧要。另一种情况是对少数系统而言性能 非常重要。在除了上述两种情况，在子程序效率的优化是白费功夫的，因为主要的优化是 在于完善高层的设计</p>
</blockquote>
</li>
<li>研究算法和数据类型</li>
<li>编写伪代码：先写头注释 head comment，再写伪代码</li>
<li>考虑数据</li>
<li>检查伪代码：确认很容易，很自然地理解子程序做些什么以及怎样做</li>
<li>在伪代码中试验一些想法，留下最好的想法（迭代）：伪代码试验想法成本比代码低。<blockquote>
<p>用伪代码反复描述这个子程序，直到伪代码写出句子已经足够简单，你可以把伪代码直 接变成代码文档为止。最初伪代码层次太高，不断的精化和分解伪代码，直到再写伪代码 实在浪费时间为止</p>
</blockquote>
</li>
<li>编写子程序代码 Code the Routine<ul>
<li>图9.3  at p225 <img src="http://upload-images.jianshu.io/ upload_images/1767214-a1597a1c648fdf02.png?imageMogr2/auto-orient/ strip%7CimageView2/2/w/1240" alt=""></li>
<li>写出子程序的声明：把如果接口名称起得直接了当，就不需要接口假定(interface  assumption)的事情</li>
<li>把伪代码转变为高层次的注释</li>
<li>在每条注释下填充代码： <strong><em>伪代码相当于文章的提纲</em></strong> ，每段伪代码注释描述类一段或者一句代码</li>
<li>检查代码是否需要进一步分解<ul>
<li>如果一行伪代码下的代码过多，可以refactor重构成一个子程序</li>
<li>递归recursively地应用伪代码编程过程。如果一行伪代码下的代码过<br>多，可以把一行伪代码拆分为多行伪代码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>检查代码 Check the Code<ul>
<li>在脑海检查程序的错误：当子程序足够短小精悍，检查到程序所有可能的<strong><em> 执行路径、端点和异常情况</em></strong>，不但要自己查(这叫桌面检查 desk checking) ，可以同行审查peer review，详查walk-through或者审查inspection<blockquote>
<p>从superstition<strong><em>迷信</em></strong>到<strong><em>理解</em></strong>,调查显示只有5%的错误是由于编译器或者 硬件造成的,所以遇到的错误大部分都是程序员自身造成的</p>
<ul>
<li>编译子程序：把编译器的警告级别调到<strong><em>最高</em></strong>，使用像lint的<strong><em>检查工具</em></strong>，<strong><em> 及时消除</em></strong>产生错误信息和警告的所有根源</li>
<li>在调试器中逐行运行代码</li>
<li>测试代码</li>
<li>消除程序中的错误</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>收尾工作 Clean Up LeftOvers<ul>
<li>检查子程序的接口</li>
<li>检查子整体的设计质量：内聚性；子程序间松散耦合；防御式编程C7</li>
<li>检查子程序的变量C10-13</li>
<li>检查子程序的语句和逻辑：有无泄漏资源，错误，死循环，错误嵌套C14-19</li>
<li>检查子程序的布局:格式化 C31</li>
<li>检查子程序的文档</li>
<li>除去冗余的注释</li>
</ul>
</li>
</ul>
</li>
<li>9.4 伪代码编程过程的替代方案 Alternative to the PPP<ul>
<li>测试先行开发（测试驱动开发）Test-first Development：在任何代码之前先要写出测试用例，使得程序可测试</li>
<li>重构refactoring C24</li>
<li>契约式设计 design by contract 即每一段程序都具有前条件preconditions和后条件postconditions</li>
<li>东拼西凑hacking</li>
<li>核对表 P233</li>
</ul>
</li>
</ul>
<h2 id="第三部分-变量-Variable"><a href="#第三部分-变量-Variable" class="headerlink" title="第三部分 变量 Variable"></a>第三部分 变量 Variable</h2><h3 id="第十章-使用变量的一般事项-General-Issue-in-Using-Variables"><a href="#第十章-使用变量的一般事项-General-Issue-in-Using-Variables" class="headerlink" title="第十章 使用变量的一般事项 General Issue in Using Variables"></a>第十章 使用变量的一般事项 General Issue in Using Variables</h3><ul>
<li>10.1 数据认知: 列举的常见的数据类型</li>
<li>10.2 轻松掌握变量定义：<ul>
<li>隐式声明：避免隐式声明，可能导致编译器的初始值不符合编程的要求，应该关闭隐式声明，并声明全部变量；</li>
</ul>
</li>
<li>10.3 变量初始化原则：<ul>
<li>初始化错误：<ul>
<li>从未对变量赋值</li>
<li>变量值已经过期</li>
<li>变量的一部分被赋值</li>
</ul>
</li>
<li>避免初始化方法：<ul>
<li>在声明时初始化变量</li>
<li>在靠近变量第一次使用的地方初始化它</li>
<li><strong><strong>理想状态下</strong></strong>，在第一次使用的地方声明并初始化变量    </li>
<li>在可能的情况下，使用final或者const</li>
<li>在计数累加器i j，再次使用时忘记重置是一个常见的错误</li>
<li>在类的构造函数中初始化该类数据成员</li>
<li>检查变量是否需要重新初始化</li>
<li>一次性初始化具名常量，用可执行代码初始化变量。</li>
</ul>
</li>
</ul>
</li>
<li>10.4 作用域 Scope   <ul>
<li>使变量引用局部化：跨度span：变量引用点之间的距离；应该把变量的引用点集中起来<br>、    * 尽可能缩短存活时间：就是变量最初引用点到最后引用点之间的距离<ul>
<li>减少作用域的一般原则：<ul>
<li>在循环开始前初始化该循环里使用的变量，而不是在该循环所属的子程序开始处初始 化这些变量</li>
<li>直到变量即将被使用的时候再为其赋值</li>
<li>把相关的语句放在一起</li>
<li>把相关的语句提出成单独的子程序</li>
<li>开始时采用严格的作用域，然后根据需要扩展变量的作用域 <pre><code>&gt; private -&gt; protected -&gt; default- &gt;public
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>10.5 持续性:有可能数据发生了变化，引用了过期的变量导致错误<ul>
<li>在子程序加入调试代码或者断言检查关键数据的合理性</li>
<li>准备抛弃变量时给它设置不合理的值 <strong><em>个人认为在at C++</em></strong></li>
<li>编写程序假定是没有持续性的，但不适合c++或者java中的static数据</li>
<li>养成使用所有数据前声明和初始化的习惯</li>
</ul>
</li>
<li>10.6 绑定时间：绑定时间越早灵活性越差，其实跟上面的初始化变量的指导是一样的</li>
<li>10.7 数据类型和控制结构之间的关系：<ul>
<li>序列型数据翻译为程序中的顺序语句</li>
<li>选择型数据翻译为程序中的if else语句</li>
<li>迭代型数据翻译为for repeat while等循环语句</li>
</ul>
</li>
<li>10.8 为变量指定单一用途<ul>
<li>每个变量只用于单一的用途</li>
</ul>
</li>
</ul>
<h3 id="第十一章-变量名的力量"><a href="#第十一章-变量名的力量" class="headerlink" title="第十一章 变量名的力量"></a>第十一章 变量名的力量</h3><ul>
<li>11.1 选择好变量名的注意事项<ul>
<li>最终重要的命名事项：<ul>
<li>名字要完全、准确地表达该事物</li>
<li>容易阅读、不包含晦涩的缩写、同时无歧义<ul>
<li>以问题为导向：好的名字是表达”什么“（<strong><em>what</em></strong>）而不是”如何“（how），即反映问题而不是解决方案。变量应直指<strong><em>问题的领域而非计算机世界</em></strong><blockquote>
<p>inputRecord 比 employeeData</p>
</blockquote>
</li>
<li>最适当的名字长度 Optimum Name Length：</li>
</ul>
</li>
<li>有研究是平均长度在10到16个字符</li>
<li>有研究是平均长度在8到20个字符</li>
<li>最重要是强调当自己代码中出现很多<strong><em>更短</em></strong>的名字，认真检查确保<strong><em>名字含义足够清晰</em></strong><ul>
<li>变量名对作用域的影响 The Effect of Scope on Variable Names、</li>
</ul>
</li>
<li>对位于全局命名空间中的名字加入限定词</li>
<li>如果编程语言不支持命名空间，就在对应的子系统加入前缀<ul>
<li>变量名中计算值限定空间 Computed-Value Qualifiers In Variable Names</li>
</ul>
</li>
<li>把总额 sum total、平均数 average 、最大值Max、最小值Min、记录Record、字符串String、Pointer指针<strong><em>加入名字的后面</em></strong><blockquote>
<p>revenueTotal revenueAverage更具对称性，<strong><em>更容易维护</em></strong><br>Num放在开始位置代表总数，放在结束位置代表一个下标<br>customerCount代表员工总数 <strong><em>customerIndex</em></strong>代表<strong><em>某个特定</em></strong>的员工</p>
<ul>
<li>变量名中的对仗词 Common  Opposites  In Variable Names<ul>
<li>begin/end</li>
<li>first/last</li>
<li>locked/unlocked</li>
<li>min/max</li>
<li>next/previous</li>
<li>old/new</li>
<li>opened/closed</li>
<li>visible/invisible</li>
<li>source/target</li>
<li>source/destination</li>
<li>up/down</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>11.2 为特定类型的数据命名 Naming Specific Types of Data<ul>
<li>为循环下标命名 Naming Loop Index：<ul>
<li>一般情况下使用i、j、k</li>
<li>多层循环嵌套的情况或者循环长度超过<strong>*一两行</strong> *代码，应该给计数器赋予更长的名字以表达其含义</li>
</ul>
</li>
<li>为状态变量命名 Naming Status Variables<ul>
<li>为状态变量取一个<strong><em>比flag更好</em></strong>的名字</li>
<li>标记应该用<strong><em>枚举类型</em></strong>、<strong><em>具名常量</em></strong>或者作为<strong>*具名常量的全局变量</strong> *对其进行赋值，增加可读性</li>
</ul>
</li>
<li>为临时变量命名 Naming Temporary  Variables：在使用temp等命名前最好思考是否有能表达其含义的名字</li>
<li>为布尔变量命名 Naming Boolean Variables：<ul>
<li>谨记典型的布尔变量命名：<ul>
<li><strong><em>done</em></strong> 表示事情是否完成，未完成前是false，完成后是true</li>
<li><strong><em>error</em></strong> 表示有错误发生，错误发生前是false，错误发生后是true</li>
<li><strong><em>found</em></strong> 表示某个值已经找到，在未找到该值前是false，找到该值后是true</li>
<li><strong><em>success</em></strong>或者<strong><em>ok</em></strong> 表示一项操作是否成功，失败是false，成功是true</li>
</ul>
</li>
<li>为布尔变量赋予隐含“真/假”含义的名字<ul>
<li>status不是一个好的命名 </li>
<li>isXXX优点是：不能用于哪些模糊的名字。缺点是可读性较差<blockquote>
<p>isStatus无意义 isFound 比found可读性差 </p>
</blockquote>
</li>
<li>使用肯定布尔命名 </li>
</ul>
</li>
</ul>
</li>
<li>为枚举变量命名 Naming Enumerated Types：<ul>
<li>可以通过使用<strong><em>组前缀</em></strong>为明确表示该类型的成员都同属于一个组<blockquote>
<p>Color_XXX</p>
</blockquote>
</li>
<li>对于枚举的命名有不同的观点：有大小写混合<code>Color_Blue</code> ；与常量类似的大写Color.BULE</li>
<li>在处理枚举像类的编程语言里，处理枚举很像类，所以<strong><em>枚举成员总是冠以枚举名字前缀 </em></strong>，就无需重复前缀了</li>
</ul>
</li>
<li>为常量命名 Naming Constans：应命名该常量代表的<strong><em>抽象事物</em></strong>而非数值</li>
</ul>
</li>
<li>11.3 命名规则的力量 The Power of Naming Covenstions<ul>
<li>为什么要有规则<ul>
<li>要求你更多按规矩办事，集中精力投入关注代码更重要的特征</li>
<li>有助于项目之间传递知识</li>
<li>有助于学习新项目</li>
<li>有助于减少名字增生 name Proliferation</li>
<li>弥补编程语言的不足</li>
<li>强调相关变量之间的关系：把相关变量设置相同前缀将它们关联起来<ul>
<li>何时采用命名规则</li>
<li>多人开发</li>
<li>程序需要转交别人</li>
<li>程序规模太大，无法同时了解全局，必需分而治之</li>
<li>程序开发周期过长</li>
<li>一个项目存在一些不常见的术语，在编写代码中<strong><em>使用术语或者缩写的时候</em></strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>11.4 非正式命名规则 Informal Naming Conventions<ul>
<li>与语言无关的命名规则指导原则</li>
<li>与语言相关的命名规则指导原则：有C，C++,<strong><em>只列举Java</em></strong><ul>
<li>i,j是整数下标</li>
<li>常量全部大写并用下划线分割</li>
<li>类名和接口每个单词首字母大写</li>
<li>变量名和方法名第一个单词首字母小写，后续单词首字母大写</li>
<li>除用于全部大写的名字外，不使用下划线作为名字中的分隔符</li>
<li>访问器子程序使用get和set前缀</li>
</ul>
</li>
<li>混合语言编程注意事项</li>
<li>命名规则示例<ul>
<li>包含以下三类信息：<ul>
<li>变量的内容（是什么）</li>
<li>数据的种类（具名常量，简单变量，用户自定义类型或者类）</li>
<li>变量的作用域（局部，私用的，类的，包的或者全部的作用域）</li>
</ul>
</li>
<li>类成员数据：mXXX，全局变量：gXXX</li>
</ul>
</li>
</ul>
</li>
<li>11.5 标准前缀 Standardized Prefixes:分<strong><em>用户自定义类型（UDT）的缩写</em></strong>和<strong><em>语义前缀</em></strong><ul>
<li>用户类型缩写 User-Defined Type Abbreviation:UDT缩写可以<strong><em>标识</em></strong> 被命名对象或者变量的<strong><em>数据类型</em></strong></li>
<li>语义前缀 Semantic Prefixes：描述变量或者对象是如何被使用的<ul>
<li>c：count 数量</li>
<li>first：数组需要处理的第一个元素</li>
<li>g：全局变量</li>
<li>i：数组的下标</li>
<li>last：数组中需要处理的最后一个元素</li>
<li>lim：数组中需要处理的元素上限，是非法的，不存在的上限，而last是合法的</li>
<li>m：类一级的变量</li>
<li>min：数组或者其他种类列表中绝对最前一个元素</li>
<li>max：数组或者其他种类列表中绝对最后一个元素</li>
<li>p：pointer 指针<ul>
<li>标准前缀的优点：使名字更紧凑、增加可读性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>11.6 创建具备可读性的短名字 Creating Short Names That Are Readable<ul>
<li>缩写的一般指导原则：<ul>
<li>使用标准缩写（参考词典）</li>
<li>去掉所有非前置元音<strong><em>？？？</em></strong><blockquote>
<p>computer-&gt;cmptr screen-&gt;scrn</p>
</blockquote>
</li>
<li>去掉虚词 <blockquote>
<p><strong><em>and</em></strong>、<strong><em>or</em></strong>、<strong><em>the</em></strong>等</p>
</blockquote>
</li>
<li>使用每个单词的第一个或者前几个字母</li>
<li>统一地使用单词的第一、第二或者第三（自行确定）字母后截断</li>
<li>保留每个单词的第一和最后一个字母</li>
<li>使用名字中每个重要单词，最多不超过3个</li>
<li>去除无用的后缀<blockquote>
<p><strong><em>ed</em></strong>，<strong><em>ing</em></strong></p>
</blockquote>
</li>
<li>确保不要改变变量的含义</li>
</ul>
</li>
</ul>
</li>
<li>11.7 应该避免的名字 Kind of Names To Avoid<ul>
<li>避免使用令人误解的名字或者缩写</li>
<li>避免使用具有相似含义的名字</li>
<li>避免使用具有不同含义但是相似名字的变量：<blockquote>
<p>一般是缩写很相似的情况如 clientReq 和 clientRes</p>
</blockquote>
</li>
<li>避免使用发音相似的名字</li>
<li>避免在名字中使用<strong><em>数字</em></strong></li>
<li>避免拼错单词</li>
<li>避免使用容易拼错的单词</li>
<li>不要仅靠大小写来区分变量名</li>
<li>避免使用多种自然语言：只有英语，不使用汉语等</li>
<li>避免使用标准类型、变量和子程序名字：编程语言的关键词</li>
<li>不要使用与变量含义无关的名字</li>
<li>避免在名字中使用容易混淆的字符：数字1对于字母l或者字母i，数字2对应字母z，数字5对应字母s，数字6对应字母g，数字0对应字母o</li>
</ul>
</li>
</ul>
<h3 id="第十二章-基本数据类型"><a href="#第十二章-基本数据类型" class="headerlink" title="第十二章 基本数据类型"></a>第十二章 基本数据类型</h3><ul>
<li>12.1 数值概论<ul>
<li>避免神秘数值</li>
<li>可以使用硬编码的1或者0</li>
<li>预防除零错误</li>
<li>使类型转换变得明显：不同的数据类型之间会发生转换时，利用显式转换而非隐式转换</li>
<li>避免混合类型的比较：应该转换成相同类型再进行比较</li>
<li>注意编译器警告</li>
</ul>
</li>
<li>12.2 整数 Integers<ul>
<li>检查整数除法</li>
<li>检查整数溢出：在整数加法或者乘法的<strong><em>过程中</em></strong>，留心较大的整数。</li>
</ul>
</li>
<li>12.3 浮点数 Floating-Point Numbers<ul>
<li>避免数量级相差巨大之间加减运算：解决方案：对于一系列<strong><em>相差巨大</em></strong>的数进行运算，先进行<strong><em>从小到大排序</em></strong>，<strong><em>从最小值开始</em></strong>把它们加起来，并不能消除舍入问题，但是能减少到最低限度。<blockquote>
<p>1000 000.00+0.1可能等于1000 000.00</p>
</blockquote>
</li>
<li>避免等量判断：确定数值在可接受的精度范围内<blockquote>
<p>double类型变量，for循环中 加0.1，十次后不一定等于1.0</p>
</blockquote>
</li>
<li>处理舍入误差问题：<ul>
<li>换用精度更高的变量类型</li>
<li>把浮点变量变成整数变量</li>
<li>检查语言和函数库对特定数据类型的支持</li>
</ul>
</li>
</ul>
</li>
<li>12.4 字符和字符串 Characters and Strings<ul>
<li>避免神秘字符和神秘字符串</li>
<li>了解你的语言和开发环境是如何支持Unicode</li>
<li>在程序生命周期中尽早决定国际化/本地化策略</li>
<li>只支持一种文字语言，考虑使用<strong><em>ISO-8859字符集</em></strong></li>
<li>需要支持多语言，请使用unicode</li>
<li>使用某种一致的字符串转换策略</li>
</ul>
</li>
<li>12.5 布尔变量<ul>
<li>用布尔变量对程序加以文档说明：对于表达式的结果赋予一个布尔变量，以提高可读性</li>
<li>用布尔变量简化复杂判断：这是在上一条意见演化出来的，也是提高可读性</li>
<li>如果需要的话，创建你自己的布尔类型</li>
</ul>
</li>
<li>12.6 枚举类型 Enumerated Types<ul>
<li>用枚举提高代码可读性</li>
<li>用枚举提高代码可靠性</li>
<li>用枚举是程序易于简化修改</li>
<li>使用枚举作为布尔值的替代方案：有多种失败的类型</li>
<li>检查非法数值</li>
<li>定义枚举的第一项和最后一项以用于循环边界<blockquote>
<p>Enum Country{</p>
<pre><code>Country_First = 0;
Country_China = 0;
Country_USA = 1;
Country_Last = 1;
</code></pre><p> }</p>
</blockquote>
</li>
<li>把枚举的第一个元素留作非法值<blockquote>
<p> Enum Country{</p>
<pre><code>Country_InvalidFirst = 0;
Country_First = 1;
Country_China = 1;
Country_USA = 2;
Country_Last = 2;
</code></pre><p> }</p>
</blockquote>
</li>
<li>明确定义项目代码编写标准中第一个和最后一个元素的使用规则</li>
<li>警惕给枚举元素明确赋值而带来错误：<blockquote>
<p>Enum Country{</p>
<pre><code>Country_InvalidFirst = 0;
Country_First = 2;
Country_China = 2;
Country_UK = 4;
Country_USA = 6;
Country_Last = 6;
</code></pre><p> }<br>遍历的时候会遍历到1，3，5这些非法值</p>
</blockquote>
</li>
<li>如果你的语言没有枚举类型：p307</li>
</ul>
</li>
<li>12.7 具名常量 Named Constants</li>
<li>12.8 数组 Arrays<ul>
<li>确保数组下标没有越界</li>
<li>考虑用容器取代数组，或者将数组作为顺序化结构来处理</li>
<li>检查数组的边界</li>
<li>数组是多维，保证下标的使用顺序正确，防止<strong><em>下标串话</em></strong></li>
<li>在C中结合ARRAY_LENGTH()宏来使用数组</li>
</ul>
</li>
<li>12.9 创造自己的类型（类型别名）Creating Your Own Types（Type Aliasing）</li>
</ul>
<h3 id="第十三章-不常见的数据类型"><a href="#第十三章-不常见的数据类型" class="headerlink" title="第十三章 不常见的数据类型"></a>第十三章 不常见的数据类型</h3><ul>
<li>13.1 结构体 Structure：指使用其他类型创建的数据，<strong><em>类似java中没有公用子程序，完全由公用数据成员组成的类</em></strong>，个人认为就是<strong><em>封装</em></strong><ul>
<li>用结构体明确数据关系：归为一类，关联起来</li>
<li>用结构体简化对数据块的操作</li>
<li>用结构体简化参数列表</li>
<li>用结构体减少维护</li>
</ul>
</li>
<li>13.2 指针 Pointers<strong><em>？？？未学，略</em></strong><ul>
<li>用来理解指针的范例：指针：内存中的某个位置+如何解释该位置的内容<ul>
<li>内存中的位置：就是一个地址，以16进制数表示</li>
<li>如何解释指针所指的内容：由指针的基类型 base type决定</li>
</ul>
</li>
<li>使用指针的一般技巧：略</li>
</ul>
</li>
<li>13.3 全局数据 Global Data<ul>
<li>与全局变量有关的常见问题：<ul>
<li>无意间修改了全局数据</li>
<li>与全局数据有关的奇异的和令人激动的别名问题：就是出现两个或者以上的名字都是指<strong><em>同一个变量</em></strong></li>
<li>与全局数据有关的代码重入（re-entrant）问题：多线程情况下全局数据不仅是不同子程序共享，同时同一程序的不同拷贝之间也共享</li>
<li><strong><em>全局数据阻碍代码重用</em></strong><blockquote>
<p>子程序用到全局数据，不能直接将子程序复制到其他地方（其他类）里面，解决方法：上策是修改旧类将全局数据局部化；下策是在新类创建与旧类相同的全局数据，导致像病毒一样传染</p>
</blockquote>
</li>
<li>与全局数据有关的非确定的<strong><em>初始化顺序</em></strong>事宜<blockquote>
<p>在初始化一个类的变量时需要使用其他文件的初始化全局变量，所以需要采用明确手段保证两个变量按照正确顺序进行，不然将导致错误</p>
</blockquote>
</li>
<li>全局数据破坏了模块化和智力上的可管理性</li>
</ul>
</li>
<li>使用全局数据的理由：<ul>
<li>保存全局数据：比如程序是否debug等</li>
<li>模拟具名常量</li>
<li>模拟枚举类型</li>
<li>简化对极其常用数据的使用</li>
<li>消除流浪数据（tramp data）：<blockquote>
<p>有时候传递数据给一个子程序或者类，只是想传递给另一个子程序或者类，如果调用链中间的子程序并不适用这一对象的时候，就称这些数据为流浪数据</p>
</blockquote>
</li>
</ul>
</li>
<li>只有万不得已才使用全局数据<ul>
<li>按照”局部数据-&gt;private数据-&gt;protected数据-&gt;全局数据”顺序设置数据的作用域</li>
<li>区分全局变量和类变量</li>
<li>使用访问器子程序</li>
</ul>
</li>
<li>用访问器子程序来取代全局数据<ul>
<li>访问器子程序的优势<ul>
<li>获得对数据的集中控制：如果要修改结构方法是需要修改子程序即可</li>
<li>确保变量的所有引用得到保护，避免出现异常</li>
<li>访问器子程序可以容易转变为抽象数据类型：即通过子程序名称实现抽象，提高代码可读性</li>
</ul>
</li>
<li>如何使用访问器子程序<ul>
<li>要求所有数据通过子程序访问</li>
<li>不要把全局数据放在一起，而是放在相应抽象水平的类里面</li>
<li>用锁来控制对全局数据的访问：在多线程下，子程序访问器加锁，保证数据正确性</li>
<li>使得对一项数据的所有访问都发生在同一抽象层上<blockquote>
<p>如果有add(event),就会有remove(event)\</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>如何降低使用全局数据的风险<ul>
<li>创建一种命名规则来突出全局变量<blockquote>
<p>gXXX</p>
</blockquote>
</li>
<li>为全局变量创建一份注释良好的清单</li>
<li>不要用全局变量存储中间结果</li>
<li>不要把全局变量都放在一个大对象中并到处传递，以说明你没有使用全局变量<blockquote>
<p>全局变量应根据其抽象层次防到相应的类中</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第四部分-语句-statement"><a href="#第四部分-语句-statement" class="headerlink" title="第四部分 语句 statement"></a>第四部分 语句 statement</h2><h3 id="第十四章-组织直线型代码-Organizing-Straight-Line-Code"><a href="#第十四章-组织直线型代码-Organizing-Straight-Line-Code" class="headerlink" title="第十四章 组织直线型代码 Organizing Straight-Line Code"></a>第十四章 组织直线型代码 Organizing Straight-Line Code</h3><ul>
<li><p>14.1 必须有明确顺序的语句 statements That Must be in Specific Order</p>
<ul>
<li>设法组织代码，让依赖关系变得非常明显</li>
<li>使子程序名能突显依赖关系</li>
<li><p>利用子程序参数明确显示依赖关系</p>
<blockquote>
<p> 参数<br><code>init(expenseData);</code><br><code>dayExpensse(expenseData);</code><br><code>monthlyExpensse(expenseData);</code><br><code>anunalExpensse(expenseData);</code></p>
<p>带返回值<br><code>expenseData = init(expenseData);</code><br><code>expenseData = dayExpensse(expenseData);</code><br><code>expenseData = monthlyExpensse(expenseData);</code><br><code>expenseData = anunalExpensse(expenseData);</code><br>用数据表明依赖关系不重要<br><code>init(expenseData);</code><br><code>dayExpenseData = dayExpensse(expenseData);</code><br><code>monthlyExpenseData = monthlyExpensse(expenseData);</code><br><code>anunalExpensseData = anunalExpensse(dayExpenseData ,monthlyExpenseData );</code></p>
</blockquote>
</li>
<li>用注释对不清晰的依赖关系进行说明</li>
<li>用断言或者错误处理代码来检查依赖关系：<strong><em>但是增加类复杂度</em></strong>，采用的时候需要衡量利弊</li>
</ul>
</li>
<li>14.2 顺序无关的 语句 Statements Whose Order Don’t Matter<ul>
<li>使代码易于自上而下地阅读 Making Code Read From Top to Bottom：跟把相关代码组织在一起时道理是一样的</li>
<li>把相关代码组织在一起 Grouping Related Statements</li>
</ul>
</li>
</ul>
<h3 id="第十五章-使用条件语句-Using-Conditionals"><a href="#第十五章-使用条件语句-Using-Conditionals" class="headerlink" title="第十五章 使用条件语句 Using Conditionals"></a>第十五章 使用条件语句 Using Conditionals</h3><ul>
<li>15.1 if语句<ul>
<li>简单的if-then语句<ul>
<li>首先写正确代码路径，再处理不常见情况</li>
<li>确保等量分支是正确的：不要漏掉特定情况</li>
<li>把正常情况的处理放在if后面而不要放在else后面</li>
<li>if后面不要跟空语句：要不就改成 if(!XXX){};</li>
<li>考虑else语句：如果需要可以配个空的else语句并加以说明</li>
<li>测试else语句的正确性</li>
<li>检查if else语句是不是弄反</li>
</ul>
</li>
<li>if-then-else语句串 Chains of if-then-else statements：<ul>
<li>使用布尔值调用简化复杂的检测</li>
<li>把最正确的情况放在最前面<blockquote>
<p>if(xxx){<br>}else if(xxx){<br>}<br>else if(xxx){<br>}</p>
</blockquote>
</li>
<li>如果语言支持把if-then-else语句串替换成其他结构：case语句，更清晰</li>
</ul>
</li>
</ul>
</li>
<li>15.2 case语句 case Statements<ul>
<li>为case语句选择最有效的排序<ul>
<li>按字母顺序或者数字顺序排列各种情况：所有情况的重要性相同</li>
<li>把正常的情况放在前面</li>
<li>按执行频率排列case语句</li>
</ul>
</li>
<li>使用case语句的诀窍<ul>
<li>简化每种情况对应的操作：对于某种情况的操作过于复杂，应该变成一个子程序</li>
<li>不要为了使用case语句而刻意制造一个变量</li>
<li>把default语句只用于检查真正默认的情况<blockquote>
<p>还剩一个情况，用default去检查是不对的</p>
</blockquote>
</li>
<li>使用case穿越（穿透）需要注释说明情况</li>
</ul>
</li>
<li>核对表at p635</li>
</ul>
</li>
</ul>
<h3 id="第十六章-控制循环"><a href="#第十六章-控制循环" class="headerlink" title="第十六章 控制循环"></a>第十六章 控制循环</h3><ul>
<li>16.1 选择循环的种类 Selecting the Kind of Loop p367<ul>
<li>种类：<ul>
<li>计数循环 counted loop</li>
<li>连续求值循环 continuously evaluated loop</li>
<li>无限循环 endless loop</li>
<li>迭代器循环 iterator loop<blockquote>
<p>对于C、C++、Java：for、foreach 、while、检查位置都是开始       do- while是结尾<br>灵活度除了foreach 是严格之外其他均是灵活<br>do-while至少执行一次，其他可以不执行</p>
</blockquote>
</li>
</ul>
</li>
<li>什么时候使用while循环 When to Use a Loop-While-Exit Loop</li>
<li>什么时候用带退出的循环<ul>
<li>正常带退出的循环<ul>
<li>带退出的循环更容易理解</li>
<li>带退出的循环可能使退出的地方很多，可能导致在调试、修改或者测试时被忽略，如果可能尽可能把退出的代码写在一个地方</li>
</ul>
</li>
<li>非正常带退出的循环</li>
</ul>
</li>
<li>什么时候使用for循环 When to Use a <em>for</em> Loop:<blockquote>
<p>你在循环头处写好后即把它忘掉，无须再循环中做任何事情去控制它，如果<strong><em>有一个必须使循环从循环退出的条件</em></strong>，就使用while循环</p>
</blockquote>
</li>
<li>什么时候使用foreach循环 When to Use a <em>foreach</em> Loop：消除循环内务处理算数，防止off-by-one越界错误</li>
</ul>
</li>
<li>16.2 循环控制 Controlling the Loop p373<ul>
<li>防止出现错误的方法：<ul>
<li>减少能影响该循环各种原因的因素：说了跟没有一样——</li>
<li>把循环内部当做子程序，<strong><em>把控制尽可能放在循环体外</em></strong><blockquote>
<pre><code>while(XXX &amp;&amp; XXX &amp;&amp; (XXX||XXX)){
 XXXXXXXXXX
 }
</code></pre></blockquote>
</li>
<li>进入循环 Entering Loop<ul>
<li>只从一个位置进入循环</li>
<li>把初始化代码紧放在循环前面</li>
<li>用while(true)代表无限循环</li>
<li>在适当情况下多使用for循环<blockquote>
<p>因为for循环把循环控制代码<strong><em>集中</em></strong>了,while需要在<strong><em>循环顶部初始化循环条件</em></strong>，然后在<strong><em>底部修改循环的相关代码</em></strong></p>
</blockquote>
</li>
<li>在while循环更适用的时候，不要使用for循环<blockquote>
<p>不是for(xx;xx;xx)中间代码不是简单对计数值进行判断，而是其他表达式则应当该为while循环</p>
</blockquote>
</li>
<li>处理好循环体 Processing The Middle of the Loop<ul>
<li>用<code>{}</code>将循环体重的语句包起来：个人：即使是一条语句也需要，因为扩展、修改程序可能会出现意料之外的错误</li>
<li>避免空循环：不要出现循环体为空的情况，应改成do-while</li>
<li>把循环体的内务操作要么放在循环开始处，要么放在结尾处：内务操作如i= i+1这样的表达式</li>
<li>一个循环只做一件事</li>
</ul>
</li>
</ul>
</li>
<li>退出循环 Exiting Loop<ul>
<li>设法确认循环能够终止：考虑正常情况、端点以及每一种异常情况</li>
<li>不要为了终止循环混乱修改for循环下标</li>
<li>避免出现依赖于下标最终取值的代码：<strong><em>下标值只在循环体内有效，可以说是缩小作用域的一种做法</em></strong></li>
<li>考虑使用安全计数器</li>
<li>提前退出循环<ul>
<li>考虑在while循环中使用break而不是布尔标记：<blockquote>
<p>就是循环体中前后操作有条件限制关系，当达到某个条件，不执行后续操作时，应当使用break直接退出</p>
</blockquote>
</li>
</ul>
</li>
<li>小心那些有很多break散布在循环中</li>
<li>在循环开始处使用continue：提高可读性</li>
<li>如果语言支持，请使用带标记号break结构：是break退出的目标一目标然 </li>
<li>使用break和continue要小心谨慎</li>
</ul>
</li>
<li>检查端点 Checking EndPoints<blockquote>
<p>简单的循环：开始情况+任意选择的中间情况+最终情况，先脑海模拟，如果有复杂计算，手动检查计算是否正确</p>
</blockquote>
</li>
<li>使用循环变量 Using Loop Variables<ul>
<li>用整数或者枚举类型表示数组和循环的边界</li>
<li>嵌套循环中使用有意义的变量名提高其可读性</li>
<li>用有意义的名字防止循环下标串话</li>
<li>把循环下标变量限制在本循环内</li>
</ul>
</li>
</ul>
</li>
<li>循环应该多长 How Long Should a Loop Be<ul>
<li>把循环代码的行数限制在50行以内</li>
<li>把嵌套限制在<strong><em>3层以内</em></strong></li>
<li>把长循环的内容移到子程序内</li>
<li>要让长循环格外清晰</li>
</ul>
</li>
</ul>
</li>
<li>16.3 轻松创建循环-由内而外 Creating Loop Easily- From the inside Out p385<ul>
<li>循环内部逻辑-&gt;循环控制语句<br>*伪代码－＞代码</li>
</ul>
</li>
<li>16.4 循环和数组的关系 Corresponse Between Loop And Arrays p387</li>
</ul>
<h3 id="第十七章-不常见的控制结构-Unusual-Control-Structures"><a href="#第十七章-不常见的控制结构-Unusual-Control-Structures" class="headerlink" title="第十七章 不常见的控制结构 Unusual Control Structures"></a>第十七章 不常见的控制结构 Unusual Control Structures</h3><ul>
<li>17.1 子程序中多处返回 Multiple Return From a Routine p391<ul>
<li>如果能增加可读性，就用return</li>
<li>用防卫句子(guard clause)(早返回或早退出) 来简化复杂的错误处理</li>
</ul>
</li>
<li>17.2 递归 Recursion p393<ul>
<li>使用递归的技巧<ul>
<li>确认递归能够终止</li>
<li>使用安全计数器防止无限循环</li>
<li>把递归限制在一个子程序里面</li>
<li>留心栈空间：防止栈溢出</li>
<li>不要用递归去计算阶乘和斐波那契数列</li>
</ul>
</li>
</ul>
</li>
<li>17.3 goto p398<ul>
<li>反对goto的观点 The Arguments Against <em>gotos</em></li>
<li>支持goto的观点 The Arguments for <em>gotos</em></li>
<li>关于goto的虚假辩论 The phony  goto Debate</li>
<li>错误处理和goto Erro Processing And goto</li>
<li>goto和在else字句中的共享代码 goto And The Sharing Code In an else Clause</li>
<li>goto使用原则总结  Summary of Guidlines For Using <em>gotos </em></li>
</ul>
</li>
<li>17.4 针对不常见控制结构的观点 Perspective on Unusual Control Structures</li>
</ul>
<h3 id="第十八章-表驱动法-Table-Driven-Methods"><a href="#第十八章-表驱动法-Table-Driven-Methods" class="headerlink" title="第十八章 表驱动法 Table-Driven Methods"></a>第十八章 表驱动法 Table-Driven Methods</h3><ul>
<li>18.1 表驱动法使用总则 General Considerations in Using Table-Driven Methods p411<ul>
<li>查询表取代复杂的逻辑控制结构<blockquote>
<pre><code>  if(xxx|xxx){
    xxxxx
}else if(xxx ||xxx &amp;&amp; xxx){
}else if(xxx ||xxx &amp;&amp; xxx){
}
</code></pre></blockquote>
</li>
<li>使用表驱动法的两个问题 Two Issues in Using Table-Driven Methods<ul>
<li>怎样从表中查询条目（<strong><em>查询</em></strong>）<ul>
<li>直接访问 Direct access</li>
<li>索引访问 Index access</li>
<li>阶梯访问 Stair-step access</li>
</ul>
</li>
<li>在表中存些什么（<strong><em>数据</em></strong>）</li>
</ul>
</li>
</ul>
</li>
<li>18.2 直接访问表 Direct Access Tables p413<ul>
<li>示例 一个月中的天数 保险费率 灵活消息的格式</li>
<li>灵活的消息格式：20种消息类型打印出来<ul>
<li>基于逻辑：根据消息的类型，一个类型对应一个子程序执行打印消息</li>
<li>面向对象设计：定义一个消息基类，在其中定义一个打印消息的共有方法，派生出不同的消息子类，然后重载打印消息的方法，通过多态的方式打印消息</li>
<li>表驱动法：根据不同的消息类型查找其对应字段信息和字段类型，并通过同一个子程序将基本数据信息打印出来<ul>
<li>构造键值对值 Fudging Lookup Keys</li>
</ul>
</li>
<li>复制信息从而能够直接使用该值：缺点是导致数据冗余，浪费空间</li>
<li>转换键值对以使其能够直接使用</li>
<li>把键值对转换提出成独立的子程序</li>
</ul>
</li>
</ul>
</li>
<li>18.3 索引访问表 Indexed Access Table p425<ul>
<li>通过居间的索引进行访问</li>
<li>优点：<ul>
<li>减少存储空间，主查询表每条记录都很大，索引表相对而言每条数据占用空间小很多</li>
<li>即使使用索引访问，操作索引中记录也比操作主表中的记录来得简单</li>
<li>表查询技术在可维护性上具有优点</li>
</ul>
</li>
</ul>
</li>
<li>18.4 阶梯访问表 Stair-Step Access Table p426<ul>
<li>表中的数据对于不同数据范围有效，而不是对不同的数据点有效</li>
<li>注意事项：<ul>
<li>留心端点：端点的情况是否被考虑到</li>
<li>考虑用二分查找取代顺序查找</li>
<li>考虑用索引访问来取代阶梯技术</li>
</ul>
</li>
</ul>
</li>
<li>18.5 表查询的其他示例 Other Example of Table Lookups p429</li>
</ul>
<h3 id="第十九章-一般控制问题-General-Control-Issue"><a href="#第十九章-一般控制问题-General-Control-Issue" class="headerlink" title="第十九章 一般控制问题 General Control Issue"></a>第十九章 一般控制问题 General Control Issue</h3><ul>
<li>19.1 布尔表达式 Boolean Expressions p431<ul>
<li>用true或者false做布尔判断 Using true of false For Boolean Tests<ul>
<li>用true或者false做判断，而不用0和1等数值做判断</li>
<li>隐式地比较布尔值与true和false：<blockquote>
<p><code>while(success){xx}</code> 而不是<code>while(success == true){xxx}</code></p>
</blockquote>
</li>
</ul>
</li>
<li>简化复杂的表达式 Making Complicated Expression Simple<ul>
<li>拆分复杂判断并引入新的布尔变量</li>
<li>把复杂的表达式做成布尔函数</li>
<li>用决策表替代复杂的条件</li>
</ul>
</li>
<li>编写肯定形式的布尔表达式 Forming Boolean Expression Positively<ul>
<li>先肯定再否定语句<blockquote>
<p><code>if(xx){xxx}else{xxx}</code>而不是<code>if(!xx){xxx}else{xxx}</code></p>
</blockquote>
</li>
<li>用狄摩根定理（逆反定理）简化否定的布尔判断<ul>
<li><code>not A and not B = not（A or B）</code> <code>not A or not B = not (A and B)</code></li>
</ul>
</li>
</ul>
</li>
<li>用括号使布尔表达式更清晰 Using Parentheses to Clarify Boolean Expressions<ul>
<li>用简单的技术技巧来使括号对称：开始为<em>0</em>，遇到一个左括号加1，遇到一个右括号减1<ul>
<li>把布尔值括在括号里面</li>
</ul>
</li>
</ul>
</li>
<li>理解布尔表达式如何求值 Knowing How Boolean Expression Are Evaluated</li>
<li>按照数轴顺序编写数值表达式 Writing Numeric Expressions in Number-Line Order <ul>
<li>从左到右，从大到小</li>
</ul>
</li>
<li>与0比较的知道原则 Guidelines for Comparisons to <em>0</em><ul>
<li>隐式地比较逻辑变量</li>
<li>把数和（）相比较</li>
<li>在C中显式地比较字符和零终止符(‘\0’)<ul>
<li>把指针与NULL相比较</li>
</ul>
</li>
</ul>
</li>
<li>布尔表达式的常见问题<ul>
<li>java中 == 和equal的区别 </li>
</ul>
</li>
</ul>
</li>
<li>19.2 复合语句（语句块）Compound Statements (Blocks) p443<br>＊把括号对一起写出<ul>
<li>用括号把条件表达清楚</li>
</ul>
</li>
<li>19.3 空语句 Null Statements p444<ul>
<li>小心使用空语句</li>
<li>为空语句创建一个DoNothing()预处理函数或者内联函数：强调空语句</li>
<li>考虑如果换用一个非空的循环体，是否会让代码更清晰</li>
</ul>
</li>
<li>19.4 驯服危险的深层嵌套 Taming Dangerously Deep Nesting p445<ul>
<li>通过重复检测条件中某一部分来简化嵌套的if语句</li>
<li>用break来简化嵌套if</li>
<li>把嵌套if转换成一组if-then-else语句：即转换成<code>if(xxx){xxx}elseif(xxx){xxx}elseif(xxx){xxxx}</code><ul>
<li>把嵌套if转换成case语句</li>
<li>把深层嵌套的代码抽取出来放进单独的子程序</li>
<li>使用一种更面向对象的方法：即多态</li>
<li>重新设计深层嵌套代码</li>
<li><strong><em>争议</em></strong> 用状态变量重写代码（增加复杂度）17.3</li>
<li><strong><em>争议</em></strong> 用防卫字句退出子程序，从而使代码的主要路径更为清晰 17.1</li>
<li>使用异常 8.4</li>
</ul>
</li>
</ul>
</li>
<li>19.5 编程基础：结构化编程 p454<ul>
<li>核心思想：应用程序只采用一些单入口，单出口的控制结构。单入单出的控制结构就是一个代码块，只能从一个位置开始执行，并且只能结束于某个位置。（<strong><em>有且只有一个入口和出口</em></strong>）</li>
<li>结构化编程的三个组成部分 The Three Components of Structured Programming<ul>
<li>顺序 Sequence：赋值和调用子程序</li>
<li>选择 Selection：if和case语句</li>
<li>迭代 Iteration：</li>
</ul>
</li>
</ul>
</li>
<li>19.6 控制结构与复杂度 Control Structure and Complexity p456 <ul>
<li>复杂度的重要性 How Import is Complexity</li>
<li>降低复杂度的一般性原则 General Guidelines For Reducing Complexity<ul>
<li>怎样去度量复杂度：<blockquote>
<p>程序一开始为1<br>一旦遇到关键词或者其同类加1：if repeat，while，for，and，or<br>给case语句中每一种情况加1</p>
</blockquote>
</li>
<li>如何处理复杂度的度量结果<blockquote>
<p>0-5子程序可能不错|<br>   6-10得想办法 简化子程序类<br>   10+把子程序 的某一部分拆分成另一个子程序并调用它</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第五部分-代码改善-Code-Improvement"><a href="#第五部分-代码改善-Code-Improvement" class="headerlink" title="第五部分 代码改善 Code Improvement"></a>第五部分 代码改善 Code Improvement</h2><h3 id="第二十章-软件质量描述-p463"><a href="#第二十章-软件质量描述-p463" class="headerlink" title="第二十章 软件质量描述 p463"></a>第二十章 软件质量描述 p463</h3><ul>
<li>20.1 软件质量的特性<ul>
<li>外在特性：<ul>
<li>正确性 Correctness 指系统规范、设计和实现方面的错误的稀少程度</li>
<li>可用性 Usability：指用户学习和使用的成本</li>
<li>效率 Efficiency：指占用的内存，储存和执行时间</li>
<li>可靠性 Reliability：在指定必需条件下，完成所需功能的能力：很长的无故障时间</li>
<li>健壮性 Robustness：接受无效数据或者在压力环境下运行的能力</li>
<li>完整性 Integrity：阻止对程序或者数据进行未经验证或者不正确访问的能力</li>
<li>适应性 Adaptability：为特定应用或者环境参数设计的系统，能不修改的情况给其他应用或者环境使用</li>
<li>精确性 ：输出结果的误差程度</li>
</ul>
</li>
<li>内在特性：<ul>
<li>灵活性 Flexibility： 适应需求</li>
<li>可维护性 Maintainability</li>
<li>可移植性 Portability</li>
<li>可重用性 ReuSability</li>
<li>可读性 Readability</li>
<li>可测试性 Testability</li>
<li>可理解性 Understandability</li>
</ul>
</li>
</ul>
</li>
<li>20.2 改善软件质量的技术</li>
<li>20.3 不同质量保障技术的相对效能</li>
<li>20.4 什么时候进行质量保证工作</li>
<li>20.5 软件质量的普遍原理</li>
</ul>
<h3 id="第二十一章-协同构建-p479"><a href="#第二十一章-协同构建-p479" class="headerlink" title="第二十一章 协同构建 p479"></a>第二十一章 协同构建 p479</h3><h3 id="第二十二章-开发者测试-p499"><a href="#第二十二章-开发者测试-p499" class="headerlink" title="第二十二章 开发者测试 p499"></a>第二十二章 开发者测试 p499</h3><ul>
<li>22.1 开发者测试在软件质量中的角色 p500<ul>
<li>测试的种类：<ul>
<li>单元测试(Unit testing):测试的代码：一个程序员或者一个团队编写 代码规模：完整的类、子程序或者小程序</li>
<li>组件测试(Component testing)测试代码：一个类、包小程序或者其他程序元素 代码规模：涉及到多个程序员或者多个团队</li>
<li>集成测试(Integration testing)：是对两个或更多的类、包、组件或者子系统进行联合测试。这些组件由多个程序员或者开发团队所创建。</li>
</ul>
</li>
<li>测试的作用：<ul>
<li>测试与其他开发活动背道而驰，测试的目标识<strong><em>找出错误</em></strong>，成功的测试是弄垮软件，而其他开发活动是避免程序错误和软件崩溃</li>
<li>测试永远不可能彻底证明程序中没有错误</li>
<li>测试并不能解决错误，改善软件质量</li>
<li>程序员倾向于做出”干净“的测试</li>
</ul>
</li>
<li>构建中测试<ul>
<li>构建期间：先根据需求构想子程序-&gt;编写子程序或者类-&gt;先在脑海检查-&gt;进行复查或者测试</li>
<li>每写一个子程序，对其进行独立测试，确实不容易，但是单独调试比继承之后再测试容易多。</li>
<li>新加入的子程序发现新的错误，就知道这是子程序或者其接口引发的问题</li>
</ul>
</li>
</ul>
</li>
<li>22.2 开发者测试的推荐方法 Recommend Approad to Developer Testing p503<ul>
<li>基础方法：<ul>
<li>对每一项相关的需求进行测试</li>
<li>对每隔相关的设计关注点进行测试</li>
<li>用基础测试basic testing来扩充针对需求和设计的详细测试用例：增加数据流测试  data-flow test，然后补充其他所需的测试用例</li>
<li>使用一个检查表，其中记录着你在项目中所犯的错误</li>
</ul>
</li>
<li>测试先行还是测试后行：<strong><em>测试先行</em></strong><ul>
<li>先写测试用例只是工作顺序问题：所花代价一样</li>
<li>先编写测试用例，可以更早发现缺陷</li>
</ul>
</li>
<li>开发者测试的局限性<ul>
<li>开发者测试倾向于”干净“测试</li>
<li>开发者测试对于代码覆盖率过于乐观</li>
<li>开发者测试往往忽略一些更复杂的测试覆盖率类型</li>
</ul>
</li>
</ul>
</li>
<li>22.3 测试技巧锦囊 p505<ul>
<li>不完整的测试Incomplete Testing：进行完整测试是不可能的事情</li>
<li>结构化的基础测试 Structured Basic Testing<ul>
<li><strong><em>测试程序中的每一条语句至少一次</em></strong></li>
<li>结构化基础测试最少数量计算：<ul>
<li>对于通过子程序的直路，开始的时候加1</li>
<li>遇到每个关键词或者等价物加1，如：if、while、repeat、for、and以及or</li>
<li>遇到每个case语句就加1</li>
</ul>
</li>
</ul>
</li>
<li>数据流测试 Data-Flow Testing:数据流出错率不低于控制流<ul>
<li>数据的状态<ul>
<li>已定义：数据已经初始化了，但是没有被使用</li>
<li>已使用：数据已经用于计算或者作为某子程序的参数</li>
<li>已销毁：变量出了作用域或者指针已经被释放</li>
</ul>
</li>
<li>数据的状态的组合：正确的是<strong><em>已定义-已使用</em></strong></li>
</ul>
</li>
<li>等价类划分 Equipment Partitioning</li>
<li>猜测错误 Error Guessing</li>
<li>边界值分析 Boundary Analysis<ul>
<li>常规边界值：小于、等于和大于</li>
<li>复合边界值</li>
</ul>
</li>
<li>几类坏数据 Classes of Bad Data<ul>
<li>数据太少（没有数据）</li>
<li>太多的数据</li>
<li>错误（无效）的数据</li>
<li>未初始化的数据</li>
</ul>
</li>
<li>几类好数据 Classes of Good Data<ul>
<li>正常的情况-中间或者期望值</li>
<li>最小的正常局面</li>
<li>最大的正常局面</li>
<li>与旧数据的兼容性</li>
</ul>
</li>
</ul>
</li>
<li>22.4 典型错误 p517<ul>
<li>错误不是均匀分布的</li>
<li>绝大数错误与少数几个具有严重缺陷的子程序有关</li>
<li>错误有几大类：结构方面的错误？，数据方面的错误，已实现的功能（可能是说随着迭代，新需求跟旧实现之间的错误）<ul>
<li>大多数错误的影响范围有限</li>
<li>大多数构建错误是编程人员的错误造成的</li>
<li>拼写错误是一个常见的问题</li>
</ul>
</li>
</ul>
</li>
<li>22.5 测试支持工具 Test-Support Tools p523<ul>
<li>为测试各个类构造脚手架 Building Scaffolding to Test Individual Classes<ul>
<li>哑类（模仿对象/桩对象） dummy class(mock object/stub object)：根据所需的真实性决定他们与现实的近似程度</li>
<li>调用待测试的真实函数的伪造函数，称为“驱动函数”或者“测试夹具”</li>
</ul>
</li>
<li>测试数据生成器 Test-Data Generations<ul>
<li>产生程序员意想不到的数据组合</li>
<li>比起手工构造测试数据，随机数据生成器能够更彻底地进行测试 </li>
</ul>
</li>
<li>覆盖率监视器 Coverage Monitors</li>
<li>数据记录器/日志记录器</li>
<li>符号调试器</li>
<li>系统干扰器</li>
<li>错误数据库</li>
</ul>
</li>
<li>22.6 改善测试过程 Improving Your Testing p528<ul>
<li>有计划的测试</li>
<li>重新测试（回归测试）：在彻底检查代码的前提下，当<strong><em>相关代码发生改变</em></strong>之后，需要<strong><em>重新测试</em></strong>，可能产品迭代增加新的测试用例的同时应<strong><em>保留</em></strong>旧的测试用例</li>
<li>自动化测试</li>
</ul>
</li>
<li>22.7 保留测试记录 Keeping Test Records p529</li>
</ul>
<h3 id="第二十三章-调试-p535"><a href="#第二十三章-调试-p535" class="headerlink" title="第二十三章 调试 p535"></a>第二十三章 调试 p535</h3><h3 id="第二十四章-重构-p563"><a href="#第二十四章-重构-p563" class="headerlink" title="第二十四章 重构 p563"></a>第二十四章 重构 p563</h3><h3 id="第二十五章-代码调整策略-p587"><a href="#第二十五章-代码调整策略-p587" class="headerlink" title="第二十五章 代码调整策略 p587"></a>第二十五章 代码调整策略 p587</h3><h3 id="第二十六章-代码调整技术-p609"><a href="#第二十六章-代码调整技术-p609" class="headerlink" title="第二十六章 代码调整技术 p609"></a>第二十六章 代码调整技术 p609</h3>
      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/读书/" rel="tag">#读书</a>
          
            <a href="/tags/代码大全/" rel="tag">#代码大全</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/06/30/design-pattern/" rel="next" title="设计模式">
                <i class="fa fa-chevron-left"></i> 设计模式
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/10/dp-creator-FatoryMethod/" rel="prev" title="设计模式-创建型-工厂方法(Factory Mehtod)">
                设计模式-创建型-工厂方法(Factory Mehtod) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/07/06/CodeComplete-ReadingNotes/"
           data-title="代码大全读书笔记" data-url="https://yoursite.com/2016/07/06/CodeComplete-ReadingNotes/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/headicon.jpg"
               alt="AaronChan" />
          <p class="site-author-name" itemprop="name">AaronChan</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">32</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Aaron-Chan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一部分-打好基础-Laying-the-Foundation"><span class="nav-number">1.</span> <span class="nav-text">第一部分 打好基础 Laying the Foundation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一章-欢迎进入软件构建的世界-Welcome-to-Software-Construction"><span class="nav-number">1.1.</span> <span class="nav-text">第一章 欢迎进入软件构建的世界 Welcome to Software Construction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二章-用隐喻来更充分地理解软件开发-Metaphors-for-a-Richer-Understanding-of-Software-Development"><span class="nav-number">1.2.</span> <span class="nav-text">第二章 用隐喻来更充分地理解软件开发 Metaphors for a Richer Understanding of Software Development</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第三章-三思而后行：前期准备-Measure-Twice-Cut-Once-Upstream-Prerequisites"><span class="nav-number">1.3.</span> <span class="nav-text">第三章 三思而后行：前期准备 Measure Twice, Cut Once: Upstream Prerequisites</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第四章-关键的『构建』决策-Key-Construction-Decisions"><span class="nav-number">1.4.</span> <span class="nav-text">第四章  关键的『构建』决策 Key Construction Decisions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二部分-创建高质量的代码-Creating-High-Quality-Code"><span class="nav-number">2.</span> <span class="nav-text">第二部分 创建高质量的代码 Creating-High Quality Code</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第五章-软件构建中的设计-Design-in-Construction"><span class="nav-number">2.1.</span> <span class="nav-text">第五章 软件构建中的设计 Design in Construction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第六章-可以工作的类-Working-Classes-抽象是以简化方式看待复杂操作的能力"><span class="nav-number">2.2.</span> <span class="nav-text">第六章 可以工作的类 Working Classes:抽象是以简化方式看待复杂操作的能力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第七章-高质量的子程序-High-Quality-Routines"><span class="nav-number">2.3.</span> <span class="nav-text">第七章 高质量的子程序 High-Quality Routines</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第八章-防御式编程-Defensive-Programming：子程序应该不因传入错误的数据而被破坏，哪怕是由其他子程序产生的错误的数据。即核心思想是程序都是有问题，都是要被修改。"><span class="nav-number">2.4.</span> <span class="nav-text">第八章 防御式编程 Defensive Programming：子程序应该不因传入错误的数据而被破坏，哪怕是由其他子程序产生的错误的数据。即核心思想是程序都是有问题，都是要被修改。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第九章-伪代码编程过程-The-Pseudocode-Programming-Process"><span class="nav-number">2.5.</span> <span class="nav-text">第九章 伪代码编程过程 The Pseudocode Programming Process</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三部分-变量-Variable"><span class="nav-number">3.</span> <span class="nav-text">第三部分 变量 Variable</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第十章-使用变量的一般事项-General-Issue-in-Using-Variables"><span class="nav-number">3.1.</span> <span class="nav-text">第十章 使用变量的一般事项 General Issue in Using Variables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十一章-变量名的力量"><span class="nav-number">3.2.</span> <span class="nav-text">第十一章 变量名的力量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十二章-基本数据类型"><span class="nav-number">3.3.</span> <span class="nav-text">第十二章 基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十三章-不常见的数据类型"><span class="nav-number">3.4.</span> <span class="nav-text">第十三章 不常见的数据类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四部分-语句-statement"><span class="nav-number">4.</span> <span class="nav-text">第四部分 语句 statement</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第十四章-组织直线型代码-Organizing-Straight-Line-Code"><span class="nav-number">4.1.</span> <span class="nav-text">第十四章 组织直线型代码 Organizing Straight-Line Code</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十五章-使用条件语句-Using-Conditionals"><span class="nav-number">4.2.</span> <span class="nav-text">第十五章 使用条件语句 Using Conditionals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十六章-控制循环"><span class="nav-number">4.3.</span> <span class="nav-text">第十六章 控制循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十七章-不常见的控制结构-Unusual-Control-Structures"><span class="nav-number">4.4.</span> <span class="nav-text">第十七章 不常见的控制结构 Unusual Control Structures</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十八章-表驱动法-Table-Driven-Methods"><span class="nav-number">4.5.</span> <span class="nav-text">第十八章 表驱动法 Table-Driven Methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第十九章-一般控制问题-General-Control-Issue"><span class="nav-number">4.6.</span> <span class="nav-text">第十九章 一般控制问题 General Control Issue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五部分-代码改善-Code-Improvement"><span class="nav-number">5.</span> <span class="nav-text">第五部分 代码改善 Code Improvement</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第二十章-软件质量描述-p463"><span class="nav-number">5.1.</span> <span class="nav-text">第二十章 软件质量描述 p463</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二十一章-协同构建-p479"><span class="nav-number">5.2.</span> <span class="nav-text">第二十一章 协同构建 p479</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二十二章-开发者测试-p499"><span class="nav-number">5.3.</span> <span class="nav-text">第二十二章 开发者测试 p499</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二十三章-调试-p535"><span class="nav-number">5.4.</span> <span class="nav-text">第二十三章 调试 p535</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二十四章-重构-p563"><span class="nav-number">5.5.</span> <span class="nav-text">第二十四章 重构 p563</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二十五章-代码调整策略-p587"><span class="nav-number">5.6.</span> <span class="nav-text">第二十五章 代码调整策略 p587</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二十六章-代码调整技术-p609"><span class="nav-number">5.7.</span> <span class="nav-text">第二十六章 代码调整技术 p609</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AaronChan</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"aaronchan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  

</body>
</html>
