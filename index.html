<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="AaronChan Blog">
<meta property="og:url" content="https://yoursite.com/index.html">
<meta property="og:site_name" content="AaronChan Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AaronChan Blog">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://yoursite.com/"/>

  <title> AaronChan Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?51f0c6f8829e2634ec8f9bfc8220f514";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">AaronChan Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">陈晓城</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/17/《程序员修炼之道》读书笔记/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-10-17T23:28:23+08:00" content="2017-10-17">
              2017-10-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/10/17/《程序员修炼之道》读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/10/17/《程序员修炼之道》读书笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ol>
<li>编程不存在某种最佳解决方案，我们应该注重失效，在拥有<strong><em>足够广博的背景和经验基础上</em></strong>，以保证能在特定情况下选择好的解决方案。</li>
<li>背景源自对计算机科学的基本原理理解，经验来自广泛的实际项目。</li>
</ol>
<h4 id="第1章-注重实效的哲学-1"><a href="#第1章-注重实效的哲学-1" class="headerlink" title="第1章 注重实效的哲学 1"></a>第1章 注重实效的哲学 1</h4><h5 id="1-我的源码让猫给吃了-2"><a href="#1-我的源码让猫给吃了-2" class="headerlink" title="1 我的源码让猫给吃了 2"></a>1 我的源码让猫给吃了 2</h5><ul>
<li>诚实面对我们的无知和错误</li>
<li>在做某件事情时除了尽你所能外，必须分析风险是否超过你的控制。对于不可能做到的事情或者风险太大，你有权不去为之负责。<br>但是一旦承诺某件事完成，同意为某个结果负责就必须承担其责任。</li>
<li>当自己犯错误的时候，诚实承认它，并<strong><em>设法提供各种选择</em></strong>。不要责备别人或东西，或是拼凑借口。<br>在跟别人说做不到之前请先把自己的辩解说给猫听，看看是否合理还是愚蠢。你的老板听来又是怎样？</li>
</ul>
<h5 id="2-软件的熵-3"><a href="#2-软件的熵-3" class="headerlink" title="2 软件的熵 3"></a>2 软件的熵 3</h5><ul>
<li>“不能容忍破窗户”</li>
<li>“破窗户”：低劣的设计，错误的决策或者糟糕的代码</li>
<li>没时间修理的对策：用木板把它钉起来-加入注释 加入TODO 用虚设的数据加以替代。</li>
</ul>
<h5 id="3-石头汤与煮青蛙-5"><a href="#3-石头汤与煮青蛙-5" class="headerlink" title="3 石头汤与煮青蛙 5"></a>3 石头汤与煮青蛙 5</h5><ul>
<li>知道某件事情是对的，但是涉及到其他人，为了对抗漠然和拖延，就需要欺骗，让同事们开始在路上，那么我们离成功就不远了。</li>
<li>煮青蛙：避免拖延和偏离设计，这会导致如青蛙一样被煮熟。</li>
</ul>
<h5 id="4-足够好的软件-8"><a href="#4-足够好的软件-8" class="headerlink" title="4 足够好的软件 8"></a>4 足够好的软件 8</h5><ul>
<li>足够好的软件时满足用户的需求，所以必须让用户参与权衡</li>
<li>知道何时止步：不要在过度修饰和过于求精中损坏完好的程序，迷失其中。</li>
</ul>
<h5 id="5-你的知识资产-10"><a href="#5-你的知识资产-10" class="headerlink" title="5 你的知识资产 10"></a>5 你的知识资产 10</h5><ul>
<li>知识资产：所知的关于计算机技术和所工作的应用领域的全部事实以及他们的所有经验视为他们的知识资产。</li>
<li><p>经营资产</p>
<ul>
<li>定期投资：具体见示范目标</li>
<li>多元化：你知道的不同的事情越多，你就越有价值。由于计算机技术变化很快，所以掌握的技术越多，越能更好的进行调整，赶上变化</li>
<li>管理风险：高风险高回报 低风险低回报</li>
<li>低买高卖：靠自己的判断了</li>
<li>重新评估和品和平衡：评估当前用户的技术，为适应市场变化或者职位需求是否需要学习新的东西。</li>
</ul>
</li>
<li><p>示范目标</p>
<ul>
<li>每年至少学习一种新语言</li>
<li>每季度阅读一本技术书籍</li>
<li>也要阅读非技术书籍。记住计算机是由人使用的。</li>
<li>上课</li>
<li>参加本地用户组织：主动参与了解公司以外的人在做什么，不要<strong><em>与世隔绝</em></strong></li>
<li>试验不同的环境</li>
<li>跟上潮流</li>
<li>上网</li>
</ul>
</li>
<li><p>学习的机会：</p>
<ul>
<li>不懂可以问人</li>
</ul>
</li>
<li><p>批判的思考：警惕唯一的答案，批判的分析听到的和读到的。</p>
</li>
</ul>
<h5 id="6-交流-14"><a href="#6-交流-14" class="headerlink" title="6 交流 14"></a>6 交流 14</h5><ul>
<li>知道自己想要说什么：规划你想要说的东西-》写出大纲-》问自己“这是否讲清了我想要说的内容”-》提炼-》直到确实如此</li>
<li>了解自己的听众：</li>
<li>面对不同的听众，讲出他们感兴趣的东西。<ul>
<li>你想要听众知道什么</li>
<li>他们对你讲的什么感兴趣</li>
<li>他们的知识背景是什么</li>
<li>你想要谁拥有这些信息</li>
<li>他们想要多少细节（程度）</li>
<li>你如何促使他们听你的话。</li>
</ul>
</li>
<li>选择时机：合适的时机事半功倍</li>
<li>文档除了内容形式上的美观也至关重要。</li>
</ul>
<h4 id="第2章-注重实效的途径-19"><a href="#第2章-注重实效的途径-19" class="headerlink" title="第2章 注重实效的途径 19"></a>第2章 注重实效的途径 19</h4><h5 id="7-重复的危害-20"><a href="#7-重复的危害-20" class="headerlink" title="7 重复的危害 20"></a>7 重复的危害 20</h5><p>DRY：don’t repeat yourself</p>
<p>强加的重复：</p>
<ul>
<li>信息的多种表示：在编码一级，信息需要在不同平台（客户端和服务端）上表示，即使是在客户端不同语言的表示也会带来重复。解决方法：<strong><em>编写代码生成器</em></strong>，针对文本生成不同语言平台的代码。 尽量让低级的知识放在代码中，将<strong><em>注释保留给其他高级说明</em></strong>，否则一旦代码修改，注释就得一并修改。</li>
<li>文档与代码：有些东西改变就得修改文档和代码，所以有能力的话建立文档到代码的生成机制。</li>
<li>语言问题</li>
</ul>
<p>无意的重复：原因来自信息结构的不规范，一旦发现<strong><em>多个相互依赖的数据元素时</em></strong>，就需要考虑去重复的问题</p>
<p>无耐性的重复：<strong><em>懒</em></strong></p>
<p>开发者之间的重复：通过高层设计避免</p>
<h5 id="8-正交性-25"><a href="#8-正交性-25" class="headerlink" title="8 正交性 25"></a>8 正交性 25</h5><p>正交性：两条直线相交成直角，两条直线互不依赖， <strong><em>沿着某条直线移动</em></strong>，投影到另外一条直线上的 <strong><em>位置不变</em></strong><br>正交的好处：</p>
<ul>
<li>提高效率<ul>
<li>修改得以局部化，开发和测试时间得以降低</li>
<li>促进复用，当组件有明确具体的职责，就可以与设计时未想到的新组件在一起。</li>
</ul>
</li>
<li>降低风险<ul>
<li>问题代码区被隔离开来，不会 <strong><em>扩散</em></strong>到其他部分</li>
<li>所得系统更健壮</li>
<li>测试更容易<br>怎么做</li>
<li>项目团队管理</li>
<li>设计：设计时<em>思考如果我显著改变某个特定功能背后，有多少模块会受影响</em>。</li>
<li>AOP：面向方面编程：可以让我再一个地方表达本来会分散到源码各处的某种行为</li>
<li>编码：<br>  *让代码保持解耦 羞怯代码，Law of Demeter<ul>
<li>避免使用全局数据</li>
<li>避免编写相似的函数（《重构》《设计模式》中提到策略模式）</li>
<li>构建单元测试不仅因为它比集成测试更容易规定和进行，还因为其 <strong><em>本身也是对正交性的一项测试</em></strong></li>
</ul>
</li>
<li>认同正交性，就要时刻记住运用DRY原则，寻求系统中重复降至最小；
　<h5 id="9-可撤消性-33"><a href="#9-可撤消性-33" class="headerlink" title="9 可撤消性 33"></a>9 可撤消性 33</h5><strong><em>不存在最终决策</em></strong><br>为了达到可撤销性：需要灵活的架构，使用项CORBA技术能够将项目某些部分与语言分割开来。</li>
</ul>
</li>
</ul>
<h5 id="10-曳光弹-36"><a href="#10-曳光弹-36" class="headerlink" title="10 曳光弹 36"></a>10 曳光弹 36</h5><p>先动手，然后观察各种反馈，立即改进<br> 曳光开发与项目永不会结束的理念是一致的：总有改动需要完成，总有功能需要增加。这是一个渐进的过程。<br> 曳光开发其实大家或多或少都在参与。新项目创建时搭建框架代码，逐渐为框架添加功能正是这样一个过程。我们会在框架中让关键流程能够运行，以检验新技术</p>
<p> 曳光开发和原型模式有明显区别。原型中的代码是用过就扔的，寻求以最快的速度展示产品，甚至会采用更高级的语言。曳光代码虽然简约，但却是完成的，它拥有完整的错误检查与异常处理，只不过是功能不全而已。</p>
<p> 优点：</p>
<ul>
<li>用户能够及早看到能工作的东西</li>
<li>开发者构建了一个他们能再其中工作的结构</li>
<li>有了一个集成环境</li>
<li>有了用于演示的东西</li>
<li>感知工作的进展。</li>
</ul>
<p>曳光代码vs 原型制作</p>
<ul>
<li><p>原型开发</p>
<ul>
<li>有一个非常重要的前提：你写的这段代码，将一定会被遗弃！如果不满足这个条件，请不要使用这种方法，否则会出现很悲惨的事情。既然是一个原型，那么我们可以考虑使用更加简单的方法来实现他。比如C#或者java？或者使用一些项目不建议使用的库来简化开发？甚至直接用黑板，将你的想法画出来？这样你不但能很快让大家看到一个基本的效果，还能减少不少的开发量。在原型中也不要担心效率问题，实现的优不优雅等等因素，因为请谨记：你的这段代码将被丢弃。所以请放心大胆的在上面实验你的各种想法吧。</li>
</ul>
</li>
<li><p>曳光弹</p>
<ul>
<li>一旦使用原型找到合适的方向了之后，我们就可以将原型抛弃而转入曳光弹的开发了，这也是这两种开发模式本质的区别。在曳光弹开发时，你可以为产品或特性想一个较为合适的实现了，搭建一个足已支撑项目的框架，然后开始慢慢进入正常的产品开发迭代：完成一定的功能，交付使用，根据反馈再继续修改这部分功能……直到最终成型并交付。</li>
</ul>
</li>
</ul>
<h5 id="11-原型与便笺-40"><a href="#11-原型与便笺-40" class="headerlink" title="11 原型与便笺 40"></a>11 原型与便笺 40</h5><p>原型制作与完全的制作对比成本低很多，举例轿车制作商可以为某种新车设计不同的原型，目的是测试轿车的具体方面-空气动力学，结构特征等。同样道理，软件产品也可以使用原型制作，利用不同材料制作原型，可以是白板上的图形、绘图工具绘制的产品图等等。但是，<em>如果发现自己处于不能放弃细节的环境中</em>，需要问自己是否采用该方法而转而使用曳光弹方法。</p>
<p>应制作原型的事物：</p>
<ul>
<li>架构</li>
<li>已有系统的新功能</li>
<li>外部数据的结构或内容</li>
<li>第三方工具或组件</li>
<li>性能问题</li>
<li>用户界面设计<br>原型制作中可忽略的细节：<ul>
<li>正确性：虚设数据</li>
<li>完整性：提高有意义的事物</li>
<li>健壮性：错误检查</li>
<li>风格</li>
</ul>
</li>
</ul>
<p>制作架构原型：</p>
<ul>
<li>主要组件的责任是否得到良好定义？是否适当？</li>
<li>主要组件间协作是否得到良好的定义</li>
<li>耦合是否得以最小化</li>
<li>你能否确定重复的潜在来源</li>
<li>接口的定义和各项约束是否可接受</li>
<li>每个模块再执行中能否访问其所需的数据？是否在需要时进行访问？</li>
</ul>
<h5 id="12-领域语言-43"><a href="#12-领域语言-43" class="headerlink" title="12 领域语言 43"></a>12 领域语言 43</h5><p>靠近问题领域编程：旨在脱离具体的编程语言和平台，在需解决的实际问题领域中去尝试给出解决方案（伪代码）。<br>实现小型语言，并通过解析生成器生成不同编程语言的代码。如使用BNF（Backus-Naur Form 可用于递归地规定上下文无关的语法）</p>
<h5 id="13-估算-48"><a href="#13-估算-48" class="headerlink" title="13 估算 48"></a>13 估算 48</h5><p>学习估算，并将此技能发展到你对事物的 <strong><em>数量级有直觉</em></strong>的程度，你就能展现出一种魔法般的能力。</p>
<p>估算单位</p>
<ul>
<li>时长1-15天 天</li>
<li>时长3-8周 周</li>
<li>时长8-30周 月</li>
<li>时长30+周 努力思考一下</li>
</ul>
<p>估算来自问题提供的信息</p>
<ul>
<li>第一步对提问内容的理解。</li>
<li>第二步是建立系统模型</li>
<li>第三部是把模型分解为组件，再一一估算</li>
<li>最后一步是计算答案</li>
</ul>
<h4 id="第3章-基本工具-55"><a href="#第3章-基本工具-55" class="headerlink" title="第3章 基本工具 55"></a>第3章 基本工具 55</h4><h5 id="14-纯文本的威力-56"><a href="#14-纯文本的威力-56" class="headerlink" title="14 纯文本的威力 56"></a>14 纯文本的威力 56</h5><p>持久存储知识的最佳格式是纯文本</p>
<p>纯文本：由可打印字符组成，人可以直接阅读和理解其形式。纯文本也可以有结构，可以是xml，sgml，HTML和json。借助纯文本可以获得自描述（self-describing）</p>
<p>纯文本的缺点：</p>
<ul>
<li>比压缩的二进制文件占用空间大；</li>
<li>要解释和处理纯文本文件需要的计算代价大。</li>
</ul>
<p>纯文本的优点：</p>
<ul>
<li>保证不过时：文本的描述方式永远比其他的数据形式和应用存活得更久。</li>
<li>杠杆作用：世界上每一样工具从源码管理系统到编译器环境，再到编辑器及独立的过滤器，都能够纯文本上进行。</li>
<li>更易于测试。如果纯文本用于驱动系统测试的合成数据，那么增加、修改、删除测试数据就是一件简单的事情，<strong><em>无须为此创建任何特殊工具</em></strong></li>
</ul>
<h5 id="15-shell游戏-60"><a href="#15-shell游戏-60" class="headerlink" title="15 shell游戏 60"></a>15 shell游戏 60</h5><p>虽然很多操作用GUI界面操作更直观方便，但是不能依赖它，因为GUI环境受限于设计者想要提供的能力。</p>
<p>需要投入精力熟悉shell命令，利用shell命令灵活地组织命令序列，高效地完成要做的事情。</p>
<h5 id="16-强力编辑-63"><a href="#16-强力编辑-63" class="headerlink" title="16 强力编辑 63"></a>16 强力编辑 63</h5><p>最好精通一种编辑器，并将其用于所有编辑任务：代码、文档、备忘录、系统管理等等。<br>坚持使用一款编辑器，避免在不同编辑环境中切换，重新熟悉相应的编辑约定和命令带来的成本。<br>确保编辑器能在不同平台下使用：Emacs，vi、Crisp等</p>
<p>编辑器特性：</p>
<ul>
<li>可配置</li>
<li>可扩展</li>
<li>可编程</li>
</ul>
<h5 id="17-源码控制-67"><a href="#17-源码控制-67" class="headerlink" title="17 源码控制 67"></a>17 源码控制 67</h5><p>无须多言</p>
<h5 id="18-调试-69"><a href="#18-调试-69" class="headerlink" title="18 调试 69"></a>18 调试 69</h5><ul>
<li>接受事实，调试就是解决问题。</li>
<li>要修正问题，而不是发出指责，不管bug是你的过错还是他人不是很有关系，<em>它任然是你的问题</em></li>
<li>调试的思维<ul>
<li>不要恐慌：人在面对deadline的时候或者是老板或客户的催赶会变得恐慌</li>
</ul>
</li>
</ul>
<h5 id="19-文本操纵-77"><a href="#19-文本操纵-77" class="headerlink" title="19 文本操纵 77"></a>19 文本操纵 77</h5><p>这里的文本操纵语言是轻量级的，类似脚本语言，像perl、python等脚本语言能够进行网络访问，测试数据的生成、文本的解析操纵，生成web文档。</p>
<p>建议：学习一门文本操纵语言</p>
<h5 id="20-代码生成器-80"><a href="#20-代码生成器-80" class="headerlink" title="20 代码生成器 80"></a>20 代码生成器 80</h5><p>如果有写代码重复了，那么就需要 <strong><em>编写能编写代码的代码</em></strong></p>
<p>代码生成器的类型：</p>
<ul>
<li><p>被动代码生成器：运行一次生成结果，之后结果与代码生成器无关了。本质是 <strong><em>参数化模板</em></strong></p>
<ul>
<li>用途：<ul>
<li>创建新文件</li>
<li>在变成语言之间进行一次性转换</li>
<li>生成查找表及其他在运行时计算很昂贵的资源</li>
</ul>
</li>
</ul>
</li>
<li><p>主动代码生成器：当发现自己在设法让两种完全不同的环境一起工作，那么就应该考虑主动代码生成器</p>
</li>
</ul>
<p>代码生成器并不是要很复杂，勇于尝试。</p>
<p>代码生成器不一定要生成代码</p>
<h4 id="第4章-注重实效的偏执-85"><a href="#第4章-注重实效的偏执-85" class="headerlink" title="第4章 注重实效的偏执 85"></a>第4章 注重实效的偏执 85</h4><h5 id="21-按合约设计-86"><a href="#21-按合约设计-86" class="headerlink" title="21 按合约设计 86"></a>21 按合约设计 86</h5><p>DBC:契约式设计</p>
<ul>
<li>规定调用者和被调用者双方的权利与责任</li>
<li>前条件precondition</li>
<li>后条件postcondition：完成时世界的状态</li>
<li>类不变项class invariant：在例程退出后不变项必须为真</li>
</ul>
<p>断言：断言不可能发生的事情</p>
<p>程序不一定非得一个出口</p>
<h5 id="22-死程序不说谎-95"><a href="#22-死程序不说谎-95" class="headerlink" title="22 死程序不说谎 95"></a>22 死程序不说谎 95</h5><p>早崩溃。不要破坏（trash），写入错误的数据</p>
<h5 id="23-断言式编程-97"><a href="#23-断言式编程-97" class="headerlink" title="23 断言式编程 97"></a>23 断言式编程 97</h5><p>如果它不可能发生，用断言确保它不会发生。</p>
<p>断言时不要有副作用</p>
<h5 id="24-何时使用异常-100"><a href="#24-何时使用异常-100" class="headerlink" title="24 何时使用异常 100"></a>24 何时使用异常 100</h5><p>理解需求，<strong><em>异常是留给意外事件的</em></strong></p>
<h5 id="25-怎样配平资源-103"><a href="#25-怎样配平资源-103" class="headerlink" title="25 怎样配平资源 103"></a>25 怎样配平资源 103</h5><p>要有始有终：分配资源，使用它，释放它</p>
<p>嵌套的分配（一次性不只一个资源）</p>
<ul>
<li>以与资源分配的次序相反解除资源的分配，如果一个资源含有对另一个资源的引用，就不会造成资源被遗弃</li>
<li>在代码不同的地方分配同一组资源，总是以相同的次序分配他们，这将降低死锁的可能性。</li>
</ul>
<h4 id="第5章-弯曲，或折断-111"><a href="#第5章-弯曲，或折断-111" class="headerlink" title="第5章 弯曲，或折断 111"></a>第5章 弯曲，或折断 111</h4><h5 id="26-解耦与得墨忒耳法则-112"><a href="#26-解耦与得墨忒耳法则-112" class="headerlink" title="26 解耦与得墨忒耳法则 112"></a>26 解耦与得墨忒耳法则 112</h5><p>遵循得墨忒耳法则虽然可以减少模块之间的依赖，但是会带来很多委托方法出现，不仅增加无关的代码，还影响代码的执行速度，所以需要根据不同的场景折衷，违反规范来赢取性能的改进。</p>
<h5 id="27-元程序设计-117"><a href="#27-元程序设计-117" class="headerlink" title="27 元程序设计 117"></a>27 元程序设计 117</h5><p><strong><em>？？？</em></strong><br>元数据 </p>
<ul>
<li>元数据（metadata）:描述应用的配置选项：调协参数、用户偏好</li>
<li>元数据严格意义上是数据的数据，宽泛意义上是对任何对应用进行描述的数据。（除了偏好外，还有资源等）</li>
<li>元数据是在运行时被访问和使用，而不是在编译时。<br>把抽象放在代码，把细节放在元程序</li>
</ul>
<h5 id="28-时间耦合-121"><a href="#28-时间耦合-121" class="headerlink" title="28 时间耦合 121"></a>28 时间耦合 121</h5><p>一开始编程都是按照时间的顺序去进行。但是一旦需要并发时，就出现了麻烦。</p>
<p>利用UML的活动图，分析工作流。</p>
<p><a href="http://oa5ova13h.bkt.clouddn.com/%E5%85%83%E7%A8%8B%E5%BA%8F.png" target="_blank" rel="external"></a></p>
<h5 id="29-它只是视图-127"><a href="#29-它只是视图-127" class="headerlink" title="29 它只是视图 127"></a>29 它只是视图 127</h5><p>我们基于分而治之的理念将程序分成若干个模块，但是怎么管理组织不同模块（类）之间依赖确实一个难题。</p>
<p>我们从事件（event）这个概念出发，将新变化发送给感兴趣的对象。、</p>
<p>假如通过一个 <strong><em>例程</em></strong>（例程是某个系统对外提供的功能接口或服务的集合。比如操作系统的API、服务等就是例程）<a href="http://baike.baidu.com/link?url=__3dF9ebatTgasvsyPbXx6kMoeD_4lhamfIhlJ3FOCbO9polUjbYV9SOWFsKZv3lLodSyCggjjjFrZ-L3-IbG_G1Nt7yNvFHBVVkCUxb-oq" target="_blank" rel="external">来自百度百科</a>。那么例程就需要知道各个对象之间的交互有密切的了解。显然，我们可以采用订阅/发布的模式让某个订阅者只接受它感兴趣的事件。</p>
<p>CORBA Event Service 允许参与对象通过事件信道（公共总线）发送和接受通知。</p>
<p>MVC（模型-视图=控制器）模式有效地让模型与GUI分离，又与管理视图的控件分离。</p>
<p>模型：表示图标对象的抽象数据模型。模型对任何视图或控制器都没有直接的了解<br>视图：解释模型的方式。它定业模型中的变化和来自控制器的逻辑事件<br>控制器：控制视图。并向模型提供新数据的途径。它既向模型也向视图发布事件。</p>
<p>仍然有耦合，情看下一节 <em>黑板</em></p>
<h5 id="30-黑板-134"><a href="#30-黑板-134" class="headerlink" title="30 黑板 134"></a>30 黑板 134</h5><p>将警探办案将线索信息张贴在黑板的例子指出黑板方法的特性：</p>
<ul>
<li>没有对象需要知道另外其他对象的存在，他们从黑板中查看信息，并添加他们的发现。</li>
<li>使用黑板的对象或者模块都有一个共同点就是围绕同一个目标或者功能，如在例子中是破案。</li>
</ul>
<p>对于复杂多变的工作流，我们可以黑板来协调。</p>
<ul>
<li>数据到达的次序无关紧要</li>
<li>在收到某项事实会触发适当的规则。 </li>
</ul>
<p>在分布式类黑板系统JavaSpaces中的接口设计如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>read</td>
<td>在空间中查找并获取数据</td>
</tr>
<tr>
<td>write</td>
<td>把数据项放入空间</td>
</tr>
<tr>
<td>take</td>
<td>与read类似，但同时从空间中移除该数据项</td>
</tr>
<tr>
<td>notify</td>
<td>设定每当写入与模版匹配的对象时就发出通知</td>
</tr>
</tbody>
</table>
<h4 id="第6章-当你编码时-139"><a href="#第6章-当你编码时-139" class="headerlink" title="第6章 当你编码时 139"></a>第6章 当你编码时 139</h4><h5 id="31-靠巧合编程-140"><a href="#31-靠巧合编程-140" class="headerlink" title="31 靠巧合编程 140"></a>31 靠巧合编程 140</h5><p>为什么不能靠巧合编程（看起能工作）：</p>
<ul>
<li>它也许不是真的能工作</li>
<li>依靠的边界条件知识偶然，在另一个条件下又不能工作了</li>
<li>没有记入文档的行为可能随着库的下次发布而变化</li>
<li>多余的调用让代码变慢</li>
<li>多余的调用可能引入bug</li>
</ul>
<p>深思熟虑地编程</p>
<ul>
<li>总是意识到自己在做什么</li>
<li>不要盲目编程，构建不完全理解的应用和使用你不熟悉的技术</li>
<li>按照计划行事，有条不紊！！！</li>
<li>依靠可靠的事物，如可靠的库。</li>
<li>为你的假定建立文档。</li>
<li>为你工作划分优先级，时间花在重要和最难的方面。</li>
<li>不做历史的奴隶，加入已有的代码不适用了，尽快替换。</li>
</ul>
<h5 id="32-算法速率-144"><a href="#32-算法速率-144" class="headerlink" title="32 算法速率 144"></a>32 算法速率 144</h5><p>对于算法使用的资源。处理、内存进行估算。</p>
<p>O()表示法对我们度量的事物值设置了上限。</p>
<table>
<thead>
<tr>
<th>一些常见的O()表示法</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(1)</td>
<td>常量型：数组访问</td>
</tr>
<tr>
<td>O(lg(n))</td>
<td>对数型：二分查找</td>
</tr>
<tr>
<td>O(n)</td>
<td>线性型 顺序查找</td>
</tr>
<tr>
<td>O(nlg(n))</td>
<td>比线性差，对于 <strong><em>分而治之的算法（划分其输入，并独立在两个部分进行处理）</em></strong> 但不会差很多（快速排序、堆排序的平均运行时间）</td>
</tr>
<tr>
<td>O(n^2)</td>
<td>平方律型（选择和插入排序）</td>
</tr>
<tr>
<td>O(n^3)</td>
<td>立方型2nxn矩阵相乘</td>
</tr>
<tr>
<td>O(C^n)</td>
<td>指数型 旅行商问题</td>
</tr>
</tbody>
</table>
<p>虽然我们不用去设计编写排序等算法，但是 <strong><em>估算算法的阶</em></strong> 有利我们对自己编写的程序的运行情况有一定了解</p>
<h5 id="33-重构-149"><a href="#33-重构-149" class="headerlink" title="33 重构 149"></a>33 重构 149</h5><p>重构=重写+重做+重新架构</p>
<p>何时进行重构：</p>
<ul>
<li>重复（DRY）</li>
<li>非正交设计</li>
<li>过时的知识</li>
<li>性能</li>
</ul>
<p>早重构，常重构</p>
<p>怎样重构：</p>
<ul>
<li>不要在重构同时增加功能</li>
<li>在开始重构之前确保拥有良好的测试，尽可能经常运行这些测试，这样能及早发现问题。</li>
<li>采取短小的步骤，并在每个步骤后进行测试，避免长时间的调试。</li>
</ul>
<h5 id="34-易于测试的代码-153"><a href="#34-易于测试的代码-153" class="headerlink" title="34 易于测试的代码 153"></a>34 易于测试的代码 153</h5><p>单元测试：针对合约进行测试。</p>
<p>为测试而设计：</p>
<blockquote>
<p>在设计模块甚至是单个例程时既设计其合约也设计测试该合约的代码。</p>
</blockquote>
<h5 id="35-邪恶的向导-160"><a href="#35-邪恶的向导-160" class="headerlink" title="35 邪恶的向导 160"></a>35 邪恶的向导 160</h5><p>不要使用你不理解的向导代码</p>
<h4 id="第7章-在项目开始之前-163"><a href="#第7章-在项目开始之前-163" class="headerlink" title="#### 第7章 在项目开始之前 163"></a>#### 第7章 在项目开始之前 163</h4><h5 id="36-需求之坑-163"><a href="#36-需求之坑-163" class="headerlink" title="36 需求之坑 163"></a>36 需求之坑 163</h5><p>不要搜集需求，挖掘它们。</p>
<p>应该用明了的陈述句表达需求。有时候在陈述需求中会夹带着商业政策，而 <em>商业政策是经常改变的</em>。所以我们需要将商业政策与需求做区分。</p>
<p>在讨论用户界面时，需求、政策和实现之间区别可能会变的模糊不清。</p>
<p><strong><em>重点</em></strong><br>找出用户 <strong><em>为何</em></strong>做特定事情的原因，而不是他们目前做这件事情的方式。</p>
<p>建立需求文档：用use case（用例）来描述系统的特定用法。</p>
<p>相应的用例模板</p>
<p>抽象比细节活得更长久</p>
<p>维护项目的词汇表，利于沟通。</p>
<h5 id="37-解开不可能解开的谜题-172"><a href="#37-解开不可能解开的谜题-172" class="headerlink" title="37 解开不可能解开的谜题 172"></a>37 解开不可能解开的谜题 172</h5><p>当遇到一个迷途难以解开的时候，解决的方法可能不在你现在思考的范围内。所以需要重新确定方法的约束，有些约束是绝对约束，而有些约束是先入为主。</p>
<p>不要在盒子外面思考-要找到盒子：我们需要确定问题的自由度，也就是约束<br>想想特洛伊木马</p>
<p>一定有更容易的方法</p>
<ul>
<li>有更容易的方法？</li>
<li>你是在设法解决问题还是被外部的技术问题转移注意力</li>
<li>这件事情为什么是一个问题</li>
<li>是什么使它难以解决</li>
<li>它必须以这种方式完成吗？</li>
<li>它真的必须完成吗？</li>
</ul>
<h5 id="38-等你准备好-174"><a href="#38-等你准备好-174" class="headerlink" title="38 等你准备好 174"></a>38 等你准备好 174</h5><p>倾听反复出现的疑虑-等你准备好再开始</p>
<p>是良好的判断还是拖延</p>
<ul>
<li>拖延：对于概念的验证出现“浪费时间”的厌烦</li>
<li>良好的判断，随着原型进展，肯呢个在某个时刻得到启示，突然意思到某个前提是错误的。</li>
</ul>
<h5 id="39-规范陷阱-176"><a href="#39-规范陷阱-176" class="headerlink" title="39 规范陷阱 176"></a>39 规范陷阱 176</h5><p>对于有些事情，“做”胜于“描述”</p>
<h5 id="40-圆圈与箭头-178"><a href="#40-圆圈与箭头-178" class="headerlink" title="40 圆圈与箭头 178"></a>40 圆圈与箭头 178</h5><p>不做形式方法的奴隶</p>
<p>工具只是工具，要为我所用。</p>
<h4 id="第8章-注重实效的项目-181"><a href="#第8章-注重实效的项目-181" class="headerlink" title="第8章 注重实效的项目 181"></a>第8章 注重实效的项目 181</h4><h5 id="41-注重实效的团队-181"><a href="#41-注重实效的团队-181" class="headerlink" title="41 注重实效的团队 181"></a>41 注重实效的团队 181</h5><ul>
<li>不留破窗户</li>
<li>不做温水青蛙，时刻注意到外部的变化如需求、商业政策等</li>
<li>不要重复自己</li>
<li>正交性：围绕功能而不是工作职务进行组织</li>
</ul>
<h5 id="42-无处不在的自动化-186"><a href="#42-无处不在的自动化-186" class="headerlink" title="42 无处不在的自动化 186"></a>42 无处不在的自动化 186</h5><p>不要手工</p>
<p>自动化：</p>
<ul>
<li>测试</li>
<li>构建</li>
<li>生成代码</li>
<li>批准流程</li>
</ul>
<h5 id="43-无情的测试-191"><a href="#43-无情的测试-191" class="headerlink" title="43 无情的测试 191"></a>43 无情的测试 191</h5><p>早测试、常测试、自动测试</p>
<p>要到通过全部测试，编码才算结束。</p>
<p>测试什么</p>
<ul>
<li>单元测试：对于某个模块演练的代码</li>
<li>集成测试：说明组成项目的主要子系统能工作且能很好的协同</li>
<li>验证和校验（validation和verification）：程序相应正常但是结果不是用户需要的，是错误的</li>
<li>资源耗尽，错误及恢复：错误发生时会得体的失败，保存相应的信息吗？</li>
<li>性能测试：压力测试</li>
<li>可用性测试：真正的用户进行测试</li>
</ul>
<p>怎样测试：</p>
<ul>
<li>回归测试：把当前测试输出与已知值进行比较</li>
<li>测试数据：大量数据、边界数据</li>
<li>演练GUI系统</li>
<li>对测试进行测试：通过“蓄意破坏”测试你的测试</li>
<li>彻底测试：尽可能频繁地测试，避免最后时限才进行测试</li>
</ul>
<h5 id="44-全都是写-200"><a href="#44-全都是写-200" class="headerlink" title="44 全都是写 200"></a>44 全都是写 200</h5><p>把闻到那股建里卖年，不要拴在外面</p>
<h5 id="45-极大的期望-205"><a href="#45-极大的期望-205" class="headerlink" title="45 极大的期望 205"></a>45 极大的期望 205</h5><p>温和超出用户的需求</p>
<h5 id="46-傲慢与偏见-208"><a href="#46-傲慢与偏见-208" class="headerlink" title="46 傲慢与偏见 208"></a>46 傲慢与偏见 208</h5><p>在你的作品签名：为自己负责</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/《重构》读书笔记/" itemprop="url">
                  《重构》读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-17T08:21:00+08:00" content="2017-03-17">
              2017-03-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/17/《重构》读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/17/《重构》读书笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="《重构》读书笔记"><a href="#《重构》读书笔记" class="headerlink" title="《重构》读书笔记"></a>《重构》读书笔记</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><p>第一章从实例程序出发，展示设计的缺陷，对其重构可以了解重构的过程和方法。</p>
<h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><p>第二章讨论重构的一般性原则、定义和进行重构的原因。主要讲述概念性的东西。</p>
<h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h4><p>第三章介绍如何嗅出代码的“坏味道”以及如何用重构对其消除。</p>
<h4 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h4><p>第四章讲述构建java的测试环境</p>
<h4 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h4><p>第五章到第十二章介绍作者整理下来重构的方法。</p>
<h4 id="第六部分"><a href="#第六部分" class="headerlink" title="第六部分"></a>第六部分</h4><p>第十三章重构技术在商业化应用中出现的问题</p>
<h3 id="第1章-重构，第一个案例1"><a href="#第1章-重构，第一个案例1" class="headerlink" title="第1章 重构，第一个案例1"></a>第1章 重构，第一个案例1</h3><h4 id="1-1-起点1"><a href="#1-1-起点1" class="headerlink" title="1.1 起点1"></a>1.1 起点1</h4><p>如果发现需要为程序添加新特性，而代码结构使你无法很方便的达到目的，那就需要先进行重构，然后使新特性的添加容易进行，再添加新特性。</p>
<h4 id="1-2-重构的第一步7"><a href="#1-2-重构的第一步7" class="headerlink" title="1.2 重构的第一步7"></a>1.2 重构的第一步7</h4><p>首先检查自己是否有一套可靠的测试机制。这些测试必须有自我检测的能力。因为重构有可能引入bug。</p>
<h4 id="1-3-分解并重组statement-8"><a href="#1-3-分解并重组statement-8" class="headerlink" title="1.3 分解并重组statement()8"></a>1.3 分解并重组statement()8</h4><p>重构技术就是以 <strong><em>微小的步伐</em></strong>修改程序，如果发现错误，很容易可以发现它。<br>优秀的程序员应该写出人类容易理解的代码，而非仅仅是计算机能理解的代码。</p>
<ul>
<li>搬移金额计算代码（Move Method）</li>
<li>去除不必要的临时变量（Replace Temp with Query）</li>
<li>提炼常客积分计算（Move Method）</li>
<li>Move Method 如果一个方法运用目标对象的属性进行计算，那么请把这个方法抽象到目标对象的类中。<h4 id="1-4-运用多态取代与价格相关的条件逻辑34"><a href="#1-4-运用多态取代与价格相关的条件逻辑34" class="headerlink" title="1.4 运用多态取代与价格相关的条件逻辑34"></a>1.4 运用多态取代与价格相关的条件逻辑34</h4></li>
<li>最好不要在另一个对象的属性基础上运用switch语句。如果不得不使用，也应该在对象自己的数据上使用，而不是别人的数据上。</li>
<li>当一个类需要运用多态的时候，但是假如其在生命周期内有可能变成另一个同胞类，那么就应该使用state设计模式来解决这个问题。<h4 id="1-5-结语52"><a href="#1-5-结语52" class="headerlink" title="1.5 结语52"></a>1.5 结语52</h4></li>
</ul>
<h3 id="第2章-重构原则53"><a href="#第2章-重构原则53" class="headerlink" title="第2章 重构原则53"></a>第2章 重构原则53</h3><h4 id="2-1-何谓重构53"><a href="#2-1-何谓重构53" class="headerlink" title="2.1 何谓重构53"></a>2.1 何谓重构53</h4><ul>
<li>名词含义：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高理解性和降低修改成本。</li>
<li>动词含义<br>使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</li>
<li>重构让软件更容易理解和修改</li>
<li>重构不会改变软件的可观察行为，即使改变也只能是微小的影响，软件功能一如既往。</li>
<li>两顶 <strong><em>帽子</em></strong>（时间分配）<ul>
<li>添加新功能：不应该修改已有代码，只关注新功能。增加新测试，通过测试衡量工作进度</li>
<li>重构：只改变程序内部结构，不应该添加测试（存在遗漏），不修改测试（除非接口发生变化）</li>
<li>软件开发在这两者之间切换</li>
</ul>
</li>
</ul>
<h4 id="2-2-为何重构55"><a href="#2-2-为何重构55" class="headerlink" title="2.2 为何重构55"></a>2.2 为何重构55</h4><ul>
<li><p>改进软件设计：</p>
<ul>
<li>程序的设计在没有重构的情况下逐渐腐败变质，功能的增加或者修改可能使代码越来越难以理解，就越难保护其中的设计</li>
<li>消除重复的代码一方面是程序运行更快，一方面是方便未来的修改，只用在一处修改即可不用修改多处。</li>
</ul>
</li>
<li><p>软件更容易理解：</p>
<ul>
<li>及时填补“想要它做什么”和“告诉它做什么”之间的缝隙。重构的核心就是要“准确说出我所要的”</li>
<li>重新阅读代码的人有可能是自己，他人。</li>
<li>通过重构可以把不熟悉的代码的用途理一遍，加深对代码的理解</li>
</ul>
</li>
<li>帮助找出bug：这个是建立在代码容易理解之上的</li>
<li>提高编程速度：重构达到良好的设计，而良好的设计更容易修改，增加功能，调试。</li>
</ul>
<h4 id="2-3-何时重构57"><a href="#2-3-何时重构57" class="headerlink" title="2.3 何时重构57"></a>2.3 何时重构57</h4><ul>
<li>三次法则：第一次的时候做某事尽管去做。第二次的时候对它产生反感，还是继续去做。第三次再做类似的时候，就应该重构了。</li>
<li>添加功能时重构：一方面可能是需要理解需要修改的代码，另一方面是使增加新特性更加容易。</li>
<li>修补错误时重构：出现bug的时候，难以找出问题所在的时候，很有可能是代码不清晰导致查找bug的困难。</li>
<li>复审代码时重构：<ul>
<li>复审代码有助于知识的传播，有利于代码被编写者之外的人理解。</li>
<li>重构是有利于增强复审代码的能力，重构需要先阅读代码得到一定程度的理解，得到一些建议，然后动手实现。所以重构有利于知道合理的代码应当是怎么样的。</li>
<li>复审团队需要精炼，就 <strong><em>一个审查者和一个原作者</em></strong>。较大的项目可以通过 <strong><em>UML图</em></strong>去展示代码的逻辑。</li>
</ul>
</li>
<li>程序难以相与的原因：<ul>
<li>难以阅读的程序，难以修改</li>
<li>逻辑重复的程序，难以修改</li>
<li>添加新特性需要修改已有代码的程序，难以修改</li>
<li>带复杂逻辑判断的程序，难以修改</li>
</ul>
</li>
<li>对应的期望：<ul>
<li>容易阅读</li>
<li>所有逻辑都只有唯一地点指定</li>
<li>新的改动不会危及现有行为</li>
<li>尽可能简单表达逻辑</li>
</ul>
</li>
</ul>
<h4 id="2-4-怎么对经理说60"><a href="#2-4-怎么对经理说60" class="headerlink" title="2.4 怎么对经理说60"></a>2.4 怎么对经理说60</h4><ul>
<li>不要告诉经理：经理是进度驱动，就是要求开发者尽快完成任务。而对于我来说最快完成任务的方式就是先重构。</li>
<li>很多时候重构都为程序引入间接层。把大型对象拆分成小对象，把大型函数拆分为小型函数。<ul>
<li>允许逻辑共享：一个函数在不同地点被调用。子类共享超类的方法。</li>
<li>分开解释意图和实现：通过类名和函数名解释自己的意图</li>
<li>隔离变化：在不同地方使用同一个对象，需要修改一处逻辑，那么可以做出子类，并在需要的时候修改这个子类。</li>
<li>封装条件逻辑：运用多态。将条件逻辑转化为消息模式。</li>
</ul>
</li>
<li>减少间接层:当间接层只在一处使用，那么需要将其消除。</li>
</ul>
<h4 id="2-5-重构的难题62"><a href="#2-5-重构的难题62" class="headerlink" title="2.5 重构的难题62"></a>2.5 重构的难题62</h4><ul>
<li>数据库：<ul>
<li>程序与数据库耦合在一起。另一方面是数据迁移，是向繁琐的事项。</li>
<li>在非关系型数据库，可以在数据库和对象模型中插入一个分离层，隔离两者之间的变化</li>
</ul>
</li>
<li>修改接口<ul>
<li>对于已经发布的接口需要可能需要维护旧接口和新接口，用deprecated修饰旧接口。</li>
<li>不发布新接口，在旧接口中调用新接口。</li>
<li>假如新接口抛出编译时异常，那么可以在旧接口中调用新接口并将编译时异常转化为运行时异常。</li>
</ul>
</li>
<li>何时不重构<ul>
<li>重构之前，代码必须能够在大部分情况下 <em>正常运行</em>，不然就不应该重构，而应该是 <strong><em>重写</em></strong>。</li>
<li>到了Deadline，应该避免重构。</li>
</ul>
</li>
</ul>
<h4 id="2-6-重构与设计66"><a href="#2-6-重构与设计66" class="headerlink" title="2.6 重构与设计66"></a>2.6 重构与设计66</h4><ul>
<li>重构与设计是彼此互补的。</li>
<li>预先设计是必须，预先设计不可能做到完全正确，随着对问题的逐渐深入，通过重构可以改善程序的质量。</li>
<li>重构减轻了设计的难度和压力，在程序不断修改的过程逐步完善程序的设计。</li>
</ul>
<h4 id="2-7-重构与性能69"><a href="#2-7-重构与性能69" class="headerlink" title="2.7 重构与性能69"></a>2.7 重构与性能69</h4><ul>
<li>重构是有可能导致程序运行变慢的。</li>
<li>除了对实时有严格要求的程序，编写快速软件的秘诀是：<strong><em>首先写出可调的程序，然后调整它以达到足够的速度</em></strong>。</li>
<li>经过分析大部分程序的大半部分时间是运行在一小半代码上，所以对所有代码一视同仁是错误的。 </li>
<li>性能优化放在开发的后期，通过分析工具找出消耗大量时间空间的地方，然后集中精力优化这些地方。</li>
</ul>
<h4 id="2-8-重构起源何处71"><a href="#2-8-重构起源何处71" class="headerlink" title="2.8 重构起源何处71"></a>2.8 重构起源何处71</h4><h3 id="第3章-代码的坏味道75"><a href="#第3章-代码的坏味道75" class="headerlink" title="第3章 代码的坏味道75"></a>第3章 代码的坏味道75</h3><h4 id="3-1-DuplicatedCode（重复代码）76"><a href="#3-1-DuplicatedCode（重复代码）76" class="headerlink" title="3.1 DuplicatedCode（重复代码）76"></a>3.1 DuplicatedCode（重复代码）76</h4><ul>
<li>同个类两个函数存在相同表达式：ExtractMethod（提炼函数）</li>
<li>互为兄弟类内存在相同表达式：<ul>
<li>ExtractMethod-》PullUpMethod（函数上移）</li>
<li>如果代码只是相似：先运用ExtractMethod（提炼函数）分开再Form TemPlate Method（塑造模板函数）</li>
</ul>
</li>
<li>两个毫不相干的类存在重复代码：ExtractClass（提炼类）</li>
</ul>
<h4 id="3-2-LongMethod（过长函数）76"><a href="#3-2-LongMethod（过长函数）76" class="headerlink" title="3.2 LongMethod（过长函数）76"></a>3.2 LongMethod（过长函数）76</h4><ul>
<li>原则：每当感觉需要以注释来说明什么的时候，我就将需要说明的代码放到一个独立的函数里面</li>
<li>只要函数名称能够 <strong><em>解释用途</em></strong>，我们就应该毫不犹豫地做。</li>
<li>关键不在函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。</li>
<li>具体情况<ul>
<li>函数有大量参数和临时变量：ExtractMethod（提炼函数）</li>
<li>用ReplaceTempwithQuery（以查询取代临时变量）消除临时变量</li>
<li>用IntroduceParameterObject（引入参数对象）或者PreserveWholeObject（保持对象完整）来将多长的参数列表变得简洁一点。</li>
<li>如果按照上述步骤还存在太多变量和参数就需要用到ReplaceMethodwithMethodObject（以函数对象取代函数）</li>
<li>条件表达式可以用DecomposeConditional（分解条件表达式）解决</li>
<li>可以将循环内的代码提炼为函数。</li>
</ul>
</li>
</ul>
<h4 id="3-3-LargeClass（过大的类）78"><a href="#3-3-LargeClass（过大的类）78" class="headerlink" title="3.3 LargeClass（过大的类）78"></a>3.3 LargeClass（过大的类）78</h4><ul>
<li>有时候类并非在所有时刻都使用实例变量：使用ExtractMethod和ExtractSubclass（提炼子类）</li>
<li>类中有太多代码：ExtractClass（提炼类）ExtractSubclass（提炼子类），甚至可以使用提炼接口的方式分解类的行为。</li>
<li>存在GUI的时候，可以DuplicateObservedData（复制“被监视数据”），分离数据和行为到领域模型中去。</li>
</ul>
<h4 id="3-4-LongParameterList（过长参数列）78"><a href="#3-4-LongParameterList（过长参数列）78" class="headerlink" title="3.4 LongParameterList（过长参数列）78"></a>3.4 LongParameterList（过长参数列）78</h4><ul>
<li>如果可以调用已有对象获取的话可以使用ReplaceParameterwithMethods（以函数取代参数）</li>
<li>将来自同一对象的数据收集起来，以该对象替代：PreserveWholeObject（保持对象完整）</li>
<li>如果几个参数总是同时出现，那么可以考虑IntroduceParameterObject（引入参数对象）</li>
</ul>
<h4 id="3-5-DivergentChange（发散式变化）79"><a href="#3-5-DivergentChange（发散式变化）79" class="headerlink" title="3.5 DivergentChange（发散式变化）79"></a>3.5 DivergentChange（发散式变化）79</h4><ul>
<li>一个类受多种变化影响：加上一个功能需要修改类中多个函数</li>
<li>目标是每个对象都可以只因一种变化而需要修改</li>
<li>方法：可以将提炼类来达到。</li>
</ul>
<h4 id="3-6-ShotgunSurgery（霰弹式修改）80"><a href="#3-6-ShotgunSurgery（霰弹式修改）80" class="headerlink" title="3.6 ShotgunSurgery（霰弹式修改）80"></a>3.6 ShotgunSurgery（霰弹式修改）80</h4><ul>
<li>遇到某种变化，需要在许多不同类做小修改。</li>
<li>可以通过移动函数、移动字段、内联类把一种变化一系列变化放到同一个类中。</li>
<li>对比：DivergentChange（发散式变化）是一个类受多个变化影响；ShotgunSurgery（霰弹式修改）是一个变化引起多个类相应修改。</li>
</ul>
<h4 id="3-7-FeatureEnvy（依恋情结）80"><a href="#3-7-FeatureEnvy（依恋情结）80" class="headerlink" title="3.7 FeatureEnvy（依恋情结）80"></a>3.7 FeatureEnvy（依恋情结）80</h4><ul>
<li>函数对某个类的兴趣高过对自己类的兴趣</li>
<li>通过移动函数放到该合适的位置。</li>
</ul>
<h4 id="3-8-DataClumps（数据泥团）81"><a href="#3-8-DataClumps（数据泥团）81" class="headerlink" title="3.8 DataClumps（数据泥团）81"></a>3.8 DataClumps（数据泥团）81</h4><ul>
<li>数据项总是成群结队出现</li>
<li>判断方法：删除众多数据项的一项，这么做其他数据是否失去意义。如果不再有意义就需要提炼为参数对象。</li>
</ul>
<h4 id="3-9-PrimitiveObsession（基本类型偏执）81"><a href="#3-9-PrimitiveObsession（基本类型偏执）81" class="headerlink" title="3.9 PrimitiveObsession（基本类型偏执）81"></a>3.9 PrimitiveObsession（基本类型偏执）81</h4><ul>
<li>有些字段可以用对象表示更准确ReplaceDataValuewithObject（以对象取代数据值）</li>
<li>对于不影响行为的类型码可以ReplaceTypeCodewithClass（以类取代类型码）</li>
<li>影响行为的类型码可以ReplaceTypeCodewithSubclasses（以子类取代类型码），类型码在运行时会变化就用ReplaceTypeCodewithState/Strategy（以State/Strategy取代类型码）</li>
</ul>
<h4 id="3-10-SwitchStatements（switch惊悚现身）82"><a href="#3-10-SwitchStatements（switch惊悚现身）82" class="headerlink" title="3.10 SwitchStatements（switch惊悚现身）82"></a>3.10 SwitchStatements（switch惊悚现身）82</h4><ul>
<li>使用ReplaceTypeCodewithSubclasses（以子类取代类型码）或者ReplaceTypeCodewithState/Strategy（以State/Strategy取代类型码）</li>
<li>轻量级的解决方法：ReplaceParameterwithExplicitMethods（以明确函数取代参数）</li>
</ul>
<h4 id="3-11-ParallelInheritanceHierarchies（平行继承体系）83"><a href="#3-11-ParallelInheritanceHierarchies（平行继承体系）83" class="headerlink" title="3.11 ParallelInheritanceHierarchies（平行继承体系）83"></a>3.11 ParallelInheritanceHierarchies（平行继承体系）83</h4><ul>
<li>每当为一个类增加子类必须也为另外一个类增加一个子类</li>
<li>策略是让一个继承体系的实例引用另一个继承体系的实例。</li>
</ul>
<h4 id="3-12-LazyClass（冗赘类）83"><a href="#3-12-LazyClass（冗赘类）83" class="headerlink" title="3.12 LazyClass（冗赘类）83"></a>3.12 LazyClass（冗赘类）83</h4><ul>
<li>内联类或者Collapse Hierarchy（折叠继承体系）来解决</li>
</ul>
<h4 id="3-13-SpeculativeGenerality（夸夸其谈未来性）83"><a href="#3-13-SpeculativeGenerality（夸夸其谈未来性）83" class="headerlink" title="3.13 SpeculativeGenerality（夸夸其谈未来性）83"></a>3.13 SpeculativeGenerality（夸夸其谈未来性）83</h4><ul>
<li>内联类或者Collapse Hierarchy（折叠继承体系）来解决</li>
<li>函数参数没被用上RemoveParameter（移除参数）</li>
<li>函数名称过于抽象RenameMethod（函数改名）</li>
</ul>
<h4 id="3-14-TemporaryField（令人迷惑的暂时字段）84"><a href="#3-14-TemporaryField（令人迷惑的暂时字段）84" class="headerlink" title="3.14 TemporaryField（令人迷惑的暂时字段）84"></a>3.14 TemporaryField（令人迷惑的暂时字段）84</h4><ul>
<li>对象中某个字段仅为特定情况而设。</li>
<li>提炼类来解决</li>
</ul>
<h4 id="3-15-MessageChains（过度耦合的消息链）84"><a href="#3-15-MessageChains（过度耦合的消息链）84" class="headerlink" title="3.15 MessageChains（过度耦合的消息链）84"></a>3.15 MessageChains（过度耦合的消息链）84</h4><ul>
<li>获取一个对象，再通过该对象获取另外一个对象进行操作：HideDelegate（隐藏“委托关系”）</li>
</ul>
<h4 id="3-16-MiddleMan（中间人）85"><a href="#3-16-MiddleMan（中间人）85" class="headerlink" title="3.16 MiddleMan（中间人）85"></a>3.16 MiddleMan（中间人）85</h4><ul>
<li>过度委托形成中间人:RemoveMiddleMan（移除中间人）</li>
<li>如果中间人还有其他行为,Replace Delegation with Inherited（以继承取代委托）</li>
</ul>
<h4 id="3-17-InappropriateIntimacy（狎昵关系）85"><a href="#3-17-InappropriateIntimacy（狎昵关系）85" class="headerlink" title="3.17 InappropriateIntimacy（狎昵关系）85"></a>3.17 InappropriateIntimacy（狎昵关系）85</h4><ul>
<li>两个类过于亲密，花费太多时间去探究彼此private成分</li>
<li>移动字段和移动方法减少狎昵</li>
<li>ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）</li>
<li>如果两个类实在情投意合：可以使用ExtractClass（提炼类）,让他们使用新类进行交互。</li>
</ul>
<h4 id="3-18-AlternativeClasseswithDifferentInterfaces（异曲同工的类）85"><a href="#3-18-AlternativeClasseswithDifferentInterfaces（异曲同工的类）85" class="headerlink" title="3.18 AlternativeClasseswithDifferentInterfaces（异曲同工的类）85"></a>3.18 AlternativeClasseswithDifferentInterfaces（异曲同工的类）85</h4><ul>
<li>两个函数做了相同的事情却有不同的签名</li>
</ul>
<h4 id="3-19-IncompleteLibraryClass（不完美的库类）86"><a href="#3-19-IncompleteLibraryClass（不完美的库类）86" class="headerlink" title="3.19 IncompleteLibraryClass（不完美的库类）86"></a>3.19 IncompleteLibraryClass（不完美的库类）86</h4><ul>
<li>库函数不够好，需要加入一些操作，其实类似于 <strong><em>适配</em></strong>IntroduceForeignMethod（引入外加函数）</li>
<li>如果需要加入大量的操作，IntroduceLocalExtension（引入本地扩展）</li>
</ul>
<h4 id="3-20-DataClass（纯稚的数据类）86"><a href="#3-20-DataClass（纯稚的数据类）86" class="headerlink" title="3.20 DataClass（纯稚的数据类）86"></a>3.20 DataClass（纯稚的数据类）86</h4><ul>
<li>类只有数据没有行为，其他类存在对该类的数据进行取值设值操作</li>
<li>有public字段：EncapsulateField（封装字段）</li>
<li>对于不该被其他类修改的字段:RemoveSettingMethod（移除设值函数）</li>
</ul>
<h4 id="3-21-RefusedBequest（被拒绝的遗赠）87"><a href="#3-21-RefusedBequest（被拒绝的遗赠）87" class="headerlink" title="3.21 RefusedBequest（被拒绝的遗赠）87"></a>3.21 RefusedBequest（被拒绝的遗赠）87</h4><ul>
<li>如果类不想得到另一个类全部东西，只对部分感兴趣。</li>
<li>可以使用Replace inherited with Delegation（以委托取代继承）来处理</li>
</ul>
<h4 id="3-22-Comments（过多的注释）87"><a href="#3-22-Comments（过多的注释）87" class="headerlink" title="3.22 Comments（过多的注释）87"></a>3.22 Comments（过多的注释）87</h4><ul>
<li>试试提炼方法来解决注释过多问题</li>
</ul>
<h3 id="第4章-构筑测试体系89"><a href="#第4章-构筑测试体系89" class="headerlink" title="第4章 构筑测试体系89"></a>第4章 构筑测试体系89</h3><h4 id="4-1-自测试代码的价值89"><a href="#4-1-自测试代码的价值89" class="headerlink" title="4.1 自测试代码的价值89"></a>4.1 自测试代码的价值89</h4><h4 id="4-2-JUnit测试框架91"><a href="#4-2-JUnit测试框架91" class="headerlink" title="4.2 JUnit测试框架91"></a>4.2 JUnit测试框架91</h4><h4 id="4-3-添加更多测试97"><a href="#4-3-添加更多测试97" class="headerlink" title="4.3 添加更多测试97"></a>4.3 添加更多测试97</h4><h3 id="第5章-重构列表103"><a href="#第5章-重构列表103" class="headerlink" title="第5章 重构列表103"></a>第5章 重构列表103</h3><h4 id="5-1-重构的记录格式103"><a href="#5-1-重构的记录格式103" class="headerlink" title="5.1 重构的记录格式103"></a>5.1 重构的记录格式103</h4><h4 id="5-2-寻找引用点105"><a href="#5-2-寻找引用点105" class="headerlink" title="5.2 寻找引用点105"></a>5.2 寻找引用点105</h4><h4 id="5-3-这些重构手法有多成熟106"><a href="#5-3-这些重构手法有多成熟106" class="headerlink" title="5.3 这些重构手法有多成熟106"></a>5.3 这些重构手法有多成熟106</h4><h3 id="第6章-重新组织函数109"><a href="#第6章-重新组织函数109" class="headerlink" title="第6章 重新组织函数109"></a>第6章 重新组织函数109</h3><h4 id="6-1-ExtractMethod（提炼函数）110"><a href="#6-1-ExtractMethod（提炼函数）110" class="headerlink" title="6.1 ExtractMethod（提炼函数）110"></a>6.1 ExtractMethod（提炼函数）110</h4><ul>
<li>无局部变量：直接抽取方法</li>
<li>含有局部变量<ul>
<li>局部变量只在提炼代码块内被读取值：将局部变量作为方法参数</li>
<li>局部变量在提炼代码块内被赋值：1只在提炼代码内被使用-&gt;将局部变量提炼到新该方法内;2在提炼代码块后-&gt;使用就返回局部变量修改后的值</li>
</ul>
</li>
</ul>
<h4 id="6-2-InlineMethod（内联函数）117"><a href="#6-2-InlineMethod（内联函数）117" class="headerlink" title="6.2 InlineMethod（内联函数）117"></a>6.2 InlineMethod（内联函数）117</h4><ul>
<li>当函数的名称与其本体都一眼清晰明了，在函数调用点插入函数本体，移除该函数。</li>
<li>有一群不甚合理的函数，可以先内联到大型函数然后再提炼出合理的小函数</li>
</ul>
<h4 id="6-3-InlineTemp（内联临时变量）119"><a href="#6-3-InlineTemp（内联临时变量）119" class="headerlink" title="6.3 InlineTemp（内联临时变量）119"></a>6.3 InlineTemp（内联临时变量）119</h4><ul>
<li>当临时变量只是被一个简单表达式赋值一次，而它妨碍其他重构方法</li>
<li>方法：将所有对该变量的引用动作替代成对它赋值的表达式本身。</li>
<li>情形：<ul>
<li>InlineTemp多半是为ReplaceTempwithQuery（以查询取代临时变量）准备</li>
<li>临时变量被一次赋值后，临时变量作为函数的返回值。</li>
</ul>
</li>
</ul>
<h4 id="6-4-ReplaceTempwithQuery（以查询取代临时变量）120"><a href="#6-4-ReplaceTempwithQuery（以查询取代临时变量）120" class="headerlink" title="6.4 ReplaceTempwithQuery（以查询取代临时变量）120"></a>6.4 ReplaceTempwithQuery（以查询取代临时变量）120</h4><ul>
<li>情况：你的程序以一个临时变量保存一个表达式的计算结果</li>
<li>做法：将表达式提炼出独立的函数，然后临时变量的调用替换成新函数的调用。此后新函数也能被调用。</li>
<li>具体做法：<ul>
<li>将提炼出来的函数用private修饰</li>
<li>如果独立函数有副作用，那对它进行SeparateQueryfromModifier（将查询函数和修改函数分离）</li>
</ul>
</li>
</ul>
<h4 id="6-5-IntroduceExplainingVariable（引入解释性变量）124"><a href="#6-5-IntroduceExplainingVariable（引入解释性变量）124" class="headerlink" title="6.5 IntroduceExplainingVariable（引入解释性变量）124"></a>6.5 IntroduceExplainingVariable（引入解释性变量）124</h4><ul>
<li>将复杂表达式的结果赋值给一个临时变量，用临时变量名称来解释表达式的用途</li>
</ul>
<h4 id="6-6-SplitTemporaryVariable（分解临时变量）128"><a href="#6-6-SplitTemporaryVariable（分解临时变量）128" class="headerlink" title="6.6 SplitTemporaryVariable（分解临时变量）128"></a>6.6 SplitTemporaryVariable（分解临时变量）128</h4><ul>
<li>临时变量被赋值超过一次，但是既不是 <em>循环变量</em>也不是被用于 <em>收集计算结果</em></li>
<li>原因：一个变量应该承担一个责任，如果被赋值多次很可能承担了多个责任</li>
<li>做法：针对每次赋值，创建新的临时变量</li>
</ul>
<h4 id="6-7-RemoveAssignmentstoParameters（移除对参数的赋值）131"><a href="#6-7-RemoveAssignmentstoParameters（移除对参数的赋值）131" class="headerlink" title="6.7 RemoveAssignmentstoParameters（移除对参数的赋值）131"></a>6.7 RemoveAssignmentstoParameters（移除对参数的赋值）131</h4><ul>
<li>java是值传递，对参数的任何修改都不会再调用端造成影响，所以对于 <strong><em>用过引用传递的人可能会发生理解错误</em></strong></li>
<li>参数应该仅表示“被传递过来的东西”</li>
</ul>
<h4 id="6-8-ReplaceMethodwithMethodObject（以函数对象取代函数）135"><a href="#6-8-ReplaceMethodwithMethodObject（以函数对象取代函数）135" class="headerlink" title="6.8 ReplaceMethodwithMethodObject（以函数对象取代函数）135"></a>6.8 ReplaceMethodwithMethodObject（以函数对象取代函数）135</h4><ul>
<li>情形：在大型函数内，对局部变量的使用导致难以使用ExtractMethod（提炼函数）进行重构</li>
<li>做法：将这个函数放入一个对象里，局部变量变成对象成员变量，然后可以在同一对象中将这个大型函数分解为多个小型函数。</li>
<li>原因：局部变量会增加分解函数的困难度</li>
</ul>
<h4 id="6-9-SubstituteAlgorithm（替换算法）139"><a href="#6-9-SubstituteAlgorithm（替换算法）139" class="headerlink" title="6.9 SubstituteAlgorithm（替换算法）139"></a>6.9 SubstituteAlgorithm（替换算法）139</h4><ul>
<li>把某个算法替换成更清晰的做法（算法）（有点废话）。</li>
</ul>
<h3 id="第7章-在对象之间搬移特性141"><a href="#第7章-在对象之间搬移特性141" class="headerlink" title="第7章 在对象之间搬移特性141"></a>第7章 在对象之间搬移特性141</h3><h4 id="7-1-MoveMethod（搬移函数）142"><a href="#7-1-MoveMethod（搬移函数）142" class="headerlink" title="7.1 MoveMethod（搬移函数）142"></a>7.1 MoveMethod（搬移函数）142</h4><ul>
<li>情形：程序中有个函数与所驻类之外的另一个类进行更多交流，调用后者或者后者调用该函数</li>
<li>做法：在该函数最常引用的类中定义相似行为的新接口，将旧函数变成委托函数或者将旧函数删除。</li>
<li>具体做法：<ul>
<li>检查源类中被源函数使用的一切特性，如果特性被其他函数使用，考虑这些函数一起搬移</li>
<li>检查源类的子类和超类，看看是否有该函数的声明，如果出现，很可能不能搬移。</li>
<li>目标类需要使用源类的特性：1将该特性转移到目标类；2建立目标类到源类之间引用。3将源类作为参数传给目标类4将该特性作为参数传给目标类</li>
<li>如果源函数包含 <em>异常处理</em>，需要考虑是在目标类还是源函数处理</li>
</ul>
</li>
</ul>
<h4 id="7-2-MoveField（搬移字段）146"><a href="#7-2-MoveField（搬移字段）146" class="headerlink" title="7.2 MoveField（搬移字段）146"></a>7.2 MoveField（搬移字段）146</h4><ul>
<li>情形：程序中有个字段与所驻类之外被另一个类使用（包括设置取值函数的间接调用），后者调用该字段</li>
<li>做法：将该字段搬移到目标类</li>
<li>具体做法：建立从“旧类访问新类”的连接关系，除非真正需要 <strong><em>不要建立从“新类到旧类”的关系</em></strong></li>
</ul>
<h4 id="7-3-ExtractClass（提炼类）149"><a href="#7-3-ExtractClass（提炼类）149" class="headerlink" title="7.3 ExtractClass（提炼类）149"></a>7.3 ExtractClass（提炼类）149</h4><ul>
<li>情形：一个类做了两个类的事</li>
<li>做法：建立新类，将相应的字段和函数放到新类</li>
</ul>
<h4 id="7-4-InlineClass（将类内联化）154"><a href="#7-4-InlineClass（将类内联化）154" class="headerlink" title="7.4 InlineClass（将类内联化）154"></a>7.4 InlineClass（将类内联化）154</h4><ul>
<li>情形：某个类没做太多的事情，与ExtractClass（提炼类）相反</li>
<li>做法：将这个类的所有特性搬移到另一类中，移除该类。</li>
<li>判断依据：当一个类不再承担足够责任</li>
</ul>
<h4 id="7-5-HideDelegate（隐藏“委托关系”）157"><a href="#7-5-HideDelegate（隐藏“委托关系”）157" class="headerlink" title="7.5 HideDelegate（隐藏“委托关系”）157"></a>7.5 HideDelegate（隐藏“委托关系”）157</h4><ul>
<li>情形：客户端通过委托类来调用另一个对象</li>
<li>做法：在服务类上建立客户端所需的函数，然后隐藏委托关系</li>
<li>依据：符合“封装”的特性。当委托类发生变化不会对客户端造成影响</li>
</ul>
<h4 id="7-6-RemoveMiddleMan（移除中间人）160"><a href="#7-6-RemoveMiddleMan（移除中间人）160" class="headerlink" title="7.6 RemoveMiddleMan（移除中间人）160"></a>7.6 RemoveMiddleMan（移除中间人）160</h4><ul>
<li>情形：某个类做了过多的委托动作</li>
<li>做法：让客户端直接调用委托类</li>
<li>依据：当原委托类的特性越来越多，服务类的委托函数将越来越长，需要让客户端直接调用，避免服务类沦为中间人。</li>
</ul>
<h4 id="7-7-IntroduceForeignMethod（引入外加函数）162"><a href="#7-7-IntroduceForeignMethod（引入外加函数）162" class="headerlink" title="7.7 IntroduceForeignMethod（引入外加函数）162"></a>7.7 IntroduceForeignMethod（引入外加函数）162</h4><ul>
<li>情形：需要为服务类某个函数增加功能，但是不能修改该类</li>
<li>做法：新建函数并将服务类的对象实例作为参数传入。</li>
<li>具体情形：如果需要为服务类增加 <strong><em>大量的方法</em></strong>，请考虑使用IntroduceLocalExtension（引入本地扩展）</li>
</ul>
<h4 id="7-8-IntroduceLocalExtension（引入本地扩展）164"><a href="#7-8-IntroduceLocalExtension（引入本地扩展）164" class="headerlink" title="7.8 IntroduceLocalExtension（引入本地扩展）164"></a>7.8 IntroduceLocalExtension（引入本地扩展）164</h4><ul>
<li>情形：需要为服务类某个函数增加函数，但是不能修改该类</li>
<li>做法：建立新类，使它包括这些额外函数，让这个扩展类作为服务类的子类或者包装类。</li>
<li>具体情况：如果需要对数据进行修改要波及服务类对象，那么使用包装类的方式。如果不需要，使用子类化的方式</li>
</ul>
<h3 id="第8章-重新组织数据169"><a href="#第8章-重新组织数据169" class="headerlink" title="第8章 重新组织数据169"></a>第8章 重新组织数据169</h3><h4 id="8-1-SelfEncapsulateField（自封装字段）171"><a href="#8-1-SelfEncapsulateField（自封装字段）171" class="headerlink" title="8.1 SelfEncapsulateField（自封装字段）171"></a>8.1 SelfEncapsulateField（自封装字段）171</h4><ul>
<li>情形：直接访问一个字段，但是字段之间的耦合关系逐渐变得笨拙。</li>
<li>做法：自封装就是在对于类内部的字段也封装一个设值取值的函数。</li>
<li>争论：字段访问方式是直接访问还是间接访问一致争论不断</li>
<li>间接访问的好处<ul>
<li>修改获取数据的途径；</li>
<li>支持更灵活的数据管理；如延迟加载（需要用到才加载）等。</li>
</ul>
</li>
<li>直接访问的好处<ul>
<li>容易阅读代码，不会需要转换一下这个函数是取值函数。</li>
</ul>
</li>
</ul>
<h4 id="8-2-ReplaceDataValuewithObject（以对象取代数据值）175"><a href="#8-2-ReplaceDataValuewithObject（以对象取代数据值）175" class="headerlink" title="8.2 ReplaceDataValuewithObject（以对象取代数据值）175"></a>8.2 ReplaceDataValuewithObject（以对象取代数据值）175</h4><ul>
<li>情形：假如一个数据项需要与其他数据一起使用才有意义。</li>
<li>做法：将数据变成对象。</li>
</ul>
<h4 id="8-3-ChangeValuetoReference（将值对象改为引用对象）179"><a href="#8-3-ChangeValuetoReference（将值对象改为引用对象）179" class="headerlink" title="8.3 ChangeValuetoReference（将值对象改为引用对象）179"></a>8.3 ChangeValuetoReference（将值对象改为引用对象）179</h4><ul>
<li>情形：从一个类衍生出彼此相似的对象的实例，希望把它们替换为同一个对象，ps:方便统一修改</li>
<li>做法：将值对象变成引用对象</li>
<li>区别：<ul>
<li>引用对象每个都对应现实中一个对象(==)</li>
<li>值对象只关心其值是否相等。（重写equals()和hashcode()方法）</li>
</ul>
</li>
<li>具体做法：<ul>
<li>需要使用工厂模式来创建对象</li>
<li>需要一个类（或者是自身）用字典或者静态表来保存对象</li>
<li>决定对象是预先创建还是动态创建</li>
</ul>
</li>
</ul>
<h4 id="8-4-ChangeReferencetoValue（将引用对象改为值对象）183"><a href="#8-4-ChangeReferencetoValue（将引用对象改为值对象）183" class="headerlink" title="8.4 ChangeReferencetoValue（将引用对象改为值对象）183"></a>8.4 ChangeReferencetoValue（将引用对象改为值对象）183</h4><ul>
<li>情形：有一个引用对象且 <strong><em>很小</em></strong>（创建太多值对象内存消耗大） <strong><em>不可变</em></strong>（无需修改对象），那么应该将其转换为值对象</li>
<li>具体做法：<ul>
<li>查看是否是不可变对象或者可修改成不可变对象</li>
<li>重写hashCode和equals()方法</li>
<li>取消使用工厂模式和将对象的构造函数设为public</li>
</ul>
</li>
</ul>
<h4 id="8-5-ReplaceArraywithObject（以对象取代数组）186"><a href="#8-5-ReplaceArraywithObject（以对象取代数组）186" class="headerlink" title="8.5 ReplaceArraywithObject（以对象取代数组）186"></a>8.5 ReplaceArraywithObject（以对象取代数组）186</h4><ul>
<li>情形：如果数据存储了不相似的数据，元素代表不同的东西。</li>
<li>做法：将数组变成对象，数组的每个元素用字段表示</li>
</ul>
<h4 id="8-6-DuplicateObservedData（复制“被监视数据”）189"><a href="#8-6-DuplicateObservedData（复制“被监视数据”）189" class="headerlink" title="8.6 DuplicateObservedData（复制“被监视数据”）189"></a>8.6 DuplicateObservedData（复制“被监视数据”）189</h4><ul>
<li>情形： 有领域数据置身于GUI控件中，而领域函数需要访问这些数据</li>
<li>做法：将该数据复制到领域模型中。建立Observer模式，同步UI和领域模型的数据。</li>
</ul>
<h4 id="8-7-ChangeUnidirectionalAssociationtoBidirectional（将单向关联改为双向关联）197"><a href="#8-7-ChangeUnidirectionalAssociationtoBidirectional（将单向关联改为双向关联）197" class="headerlink" title="8.7 ChangeUnidirectionalAssociationtoBidirectional（将单向关联改为双向关联）197"></a>8.7 ChangeUnidirectionalAssociationtoBidirectional（将单向关联改为双向关联）197</h4><ul>
<li>情形：被引用类需要得到引用类做一些处理</li>
<li>具体做法：<ul>
<li>两者是一对多关系，有单一引用承担控制关联关系责任</li>
<li>如果某个对象（Task）是另一个对象（Project）的组件，由后者负责控制。</li>
<li>如果两者之间都是多对多关系，那么由谁负责都没关系</li>
</ul>
</li>
</ul>
<h4 id="8-8-ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）200"><a href="#8-8-ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）200" class="headerlink" title="8.8 ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）200"></a>8.8 ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）200</h4><ul>
<li>情形：两个类有双向关联，但是一个类不关心另一个类的特性</li>
<li>做法：去除双向关联</li>
<li>原因：<ul>
<li>双向关联可能造成僵尸对象，不能被清除释放内存。</li>
<li>使两个类存在耦合关系，一个类的变化会导致另一类的变化。</li>
</ul>
</li>
</ul>
<h4 id="8-9-ReplaceMagicNumberwithSymbolicConstant（以字面常量取代魔法数）204"><a href="#8-9-ReplaceMagicNumberwithSymbolicConstant（以字面常量取代魔法数）204" class="headerlink" title="8.9 ReplaceMagicNumberwithSymbolicConstant（以字面常量取代魔法数）204"></a>8.9 ReplaceMagicNumberwithSymbolicConstant（以字面常量取代魔法数）204</h4><ul>
<li>情形：有一个字面常量（除了0和1之外）</li>
<li>做法：创建常量赋值以该字面常量，给予命名。</li>
</ul>
<h4 id="8-10-EncapsulateField（封装字段）206"><a href="#8-10-EncapsulateField（封装字段）206" class="headerlink" title="8.10 EncapsulateField（封装字段）206"></a>8.10 EncapsulateField（封装字段）206</h4><ul>
<li>情形：一个类有public字段</li>
<li>将它声明为private，并提供相应的访问函数</li>
</ul>
<h4 id="8-11-EncapsulateCollection（封装集合）208"><a href="#8-11-EncapsulateCollection（封装集合）208" class="headerlink" title="8.11 EncapsulateCollection（封装集合）208"></a>8.11 EncapsulateCollection（封装集合）208</h4><ul>
<li>情形：有函数返回集合</li>
<li>做法：让该函数返回只读副本，并在该类提供增加和删除集合元素的函数</li>
<li>具体做法：不应该提供集合的设值函数</li>
</ul>
<h4 id="8-12-ReplaceRecordwithDataClass（以数据类取代记录）217"><a href="#8-12-ReplaceRecordwithDataClass（以数据类取代记录）217" class="headerlink" title="8.12 ReplaceRecordwithDataClass（以数据类取代记录）217"></a>8.12 ReplaceRecordwithDataClass（以数据类取代记录）217</h4><ul>
<li>情形：面对传统编程环境的记录数据</li>
<li>做法：为该记录创建一个“哑”数据对象。</li>
</ul>
<h4 id="8-13-ReplaceTypeCodewithClass（以类取代类型码）218"><a href="#8-13-ReplaceTypeCodewithClass（以类取代类型码）218" class="headerlink" title="8.13 ReplaceTypeCodewithClass（以类取代类型码）218"></a>8.13 ReplaceTypeCodewithClass（以类取代类型码）218</h4><ul>
<li>情形：类中有个数值型类型码，不影响类的行为</li>
<li>做法：以一个新类替代类型码</li>
</ul>
<h4 id="8-14-ReplaceTypeCodewithSubclasses（以子类取代类型码）223"><a href="#8-14-ReplaceTypeCodewithSubclasses（以子类取代类型码）223" class="headerlink" title="8.14 ReplaceTypeCodewithSubclasses（以子类取代类型码）223"></a>8.14 ReplaceTypeCodewithSubclasses（以子类取代类型码）223</h4><ul>
<li>情形：有一个不可变的类型码且影响类的行为</li>
<li>做法：以子类取代这个类型码</li>
</ul>
<h4 id="8-15-ReplaceTypeCodewithState-Strategy（以State-Strategy取代类型码）227"><a href="#8-15-ReplaceTypeCodewithState-Strategy（以State-Strategy取代类型码）227" class="headerlink" title="8.15 ReplaceTypeCodewithState/Strategy（以State/Strategy取代类型码）227"></a>8.15 ReplaceTypeCodewithState/Strategy（以State/Strategy取代类型码）227</h4><ul>
<li>情形：有一个类型码且影响类的行为，但是无法通过继承消除（类型码可变化）</li>
<li>做法：以状态对象取代。</li>
</ul>
<h4 id="8-16-ReplaceSubclasswithFields（以字段取代子类）232"><a href="#8-16-ReplaceSubclasswithFields（以字段取代子类）232" class="headerlink" title="8.16 ReplaceSubclasswithFields（以字段取代子类）232"></a>8.16 ReplaceSubclasswithFields（以字段取代子类）232</h4><ul>
<li>情形：各个子类唯一区别只在“返回常量的数据”的函数上</li>
<li>做法：修改这些函数使它们返回超类的某个（新增）字段，然后销毁子类。</li>
</ul>
<h3 id="第9章-简化条件表达式237"><a href="#第9章-简化条件表达式237" class="headerlink" title="第9章 简化条件表达式237"></a>第9章 简化条件表达式237</h3><h4 id="9-1-DecomposeConditional（分解条件表达式）238"><a href="#9-1-DecomposeConditional（分解条件表达式）238" class="headerlink" title="9.1 DecomposeConditional（分解条件表达式）238"></a>9.1 DecomposeConditional（分解条件表达式）238</h4><ul>
<li>情形：if-then-else语句，不同分支做不同事情形成大型函数，本身就难以阅读，尤其在带有复杂条件的逻辑中。</li>
<li>做法：<ul>
<li>将if语句提炼为函数</li>
<li>将then和else段落提炼为函数</li>
<li>存在 <strong><em>嵌套</em></strong>，先判断是否可以用ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）消除。不行再分解每个条件</li>
</ul>
</li>
</ul>
<h4 id="9-2-ConsolidateConditionalExpression（合并条件表达式）240"><a href="#9-2-ConsolidateConditionalExpression（合并条件表达式）240" class="headerlink" title="9.2 ConsolidateConditionalExpression（合并条件表达式）240"></a>9.2 ConsolidateConditionalExpression（合并条件表达式）240</h4><ul>
<li>情形：有一系列条件判断都返回相同结果</li>
<li>做法：将这些测试合并为同一个表达式并将这个表达式提炼为独立函数</li>
<li>原因：<ul>
<li>只是一次检查，只是存在并列条件需要检查而已</li>
<li>为ExtractMethod（提炼函数）做准备，通过 <em>函数名 告知“为什么这么做”</em></li>
</ul>
</li>
<li>特殊情形：条件表达式 <em>存在副作用</em>。</li>
</ul>
<h4 id="9-3-ConsolidateDuplicateConditionalFragments（合并重复的条件片段）243"><a href="#9-3-ConsolidateDuplicateConditionalFragments（合并重复的条件片段）243" class="headerlink" title="9.3 ConsolidateDuplicateConditionalFragments（合并重复的条件片段）243"></a>9.3 ConsolidateDuplicateConditionalFragments（合并重复的条件片段）243</h4><ul>
<li>情形：在条件表达式的分支上有相同的代码</li>
<li>做法：将这段重复代码搬移到条件表达式之外，多行代码可以提炼为独立函数。</li>
<li>当try和catch执行相同代码，可以将代码移到final区段。</li>
</ul>
<h4 id="9-4-RemoveControlFlag（移除控制标记）245"><a href="#9-4-RemoveControlFlag（移除控制标记）245" class="headerlink" title="9.4 RemoveControlFlag（移除控制标记）245"></a>9.4 RemoveControlFlag（移除控制标记）245</h4><ul>
<li>情形：在一系列布尔表达式中，某个变量存在控制标记（control flag）作用。</li>
<li>做法：以break或者continue代替</li>
</ul>
<h4 id="9-5-ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）250"><a href="#9-5-ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）250" class="headerlink" title="9.5 ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）250"></a>9.5 ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）250</h4><ul>
<li>情形：函数中的条件逻辑使人难以看清正确的执行路径。</li>
<li>做法：使用卫语句表现特殊情况</li>
</ul>
<h4 id="9-6-ReplaceConditionalwithPolymorphism（以多态取代条件表达式）255"><a href="#9-6-ReplaceConditionalwithPolymorphism（以多态取代条件表达式）255" class="headerlink" title="9.6 ReplaceConditionalwithPolymorphism（以多态取代条件表达式）255"></a>9.6 ReplaceConditionalwithPolymorphism（以多态取代条件表达式）255</h4><ul>
<li>情形：存在条件表达式根据对象的类型不同选择不同的行为</li>
<li>做法：将表达式分支放进不同子类的重写方法，将原始函数提炼为抽象函数。</li>
</ul>
<h4 id="9-7-IntroduceNullObject（引入Null对象）260"><a href="#9-7-IntroduceNullObject（引入Null对象）260" class="headerlink" title="9.7 IntroduceNullObject（引入Null对象）260"></a>9.7 IntroduceNullObject（引入Null对象）260</h4><ul>
<li>情形：需要再三检查对象是否为null</li>
<li>做法：将null值替代为null对象</li>
</ul>
<h4 id="9-8-IntroduceAssertion（引入断言）267"><a href="#9-8-IntroduceAssertion（引入断言）267" class="headerlink" title="9.8 IntroduceAssertion（引入断言）267"></a>9.8 IntroduceAssertion（引入断言）267</h4><ul>
<li>情形：某段代码需要对程序状态做出某种假设</li>
<li>做法：以断言明确表现这种假设</li>
<li>具体做法：<ul>
<li>断言在 <strong><em>发布</em></strong>的时候统统 <strong><em>被去除</em></strong></li>
<li>断言应该检查 <strong><em>一定必须为真 </em></strong> 的条件</li>
</ul>
</li>
</ul>
<h3 id="第10章-简化函数调用271"><a href="#第10章-简化函数调用271" class="headerlink" title="第10章 简化函数调用271"></a>第10章 简化函数调用271</h3><h4 id="10-1-RenameMethod（函数改名）273"><a href="#10-1-RenameMethod（函数改名）273" class="headerlink" title="10.1 RenameMethod（函数改名）273"></a>10.1 RenameMethod（函数改名）273</h4><ul>
<li>情形：命名不好</li>
<li>做法：<ul>
<li>增加函数，将旧函数代码复制到新函数</li>
<li>修改旧函数，让其转发调用新函数，如果旧函数引用点少可跳过</li>
<li>编译测试</li>
<li>找出旧函数引用，调用新函数</li>
<li>编译测试</li>
<li>删除旧函数</li>
</ul>
</li>
</ul>
<h4 id="10-2-AddParameter（添加参数）275"><a href="#10-2-AddParameter（添加参数）275" class="headerlink" title="10.2 AddParameter（添加参数）275"></a>10.2 AddParameter（添加参数）275</h4><ul>
<li>情形：某个函数需要调用端更多的信息</li>
<li>做法：为此函数添加对象参数，让该对象带进函数所需信息。</li>
<li>其他考虑：<ul>
<li>现有参数是否提供足够的信息？</li>
<li>这个函数是否应该移动到拥有该信息的对象中？</li>
<li>加入新参数是否合适，是否需要使用IntroduceParameterObject（引入参数对象）</li>
</ul>
</li>
</ul>
<h4 id="10-3-RemoveParameter（移除参数）277"><a href="#10-3-RemoveParameter（移除参数）277" class="headerlink" title="10.3 RemoveParameter（移除参数）277"></a>10.3 RemoveParameter（移除参数）277</h4><ul>
<li>情形：函数不需要某个参数</li>
<li>做法：将该参数移除</li>
<li>具体做法同10.1</li>
</ul>
<h4 id="10-4-SeparateQueryfromModifier（将查询函数和修改函数分离）279"><a href="#10-4-SeparateQueryfromModifier（将查询函数和修改函数分离）279" class="headerlink" title="10.4 SeparateQueryfromModifier（将查询函数和修改函数分离）279"></a>10.4 SeparateQueryfromModifier（将查询函数和修改函数分离）279</h4><ul>
<li>情形：某个函数既返回对象状态值，又修改对象状态</li>
<li>做法：建立两个不同的函数，其中一个负责查询，另一个负责修改。</li>
<li>原则：任何一个有返回值的函数都不应该有副作用。</li>
<li>多线程：将修改和查询函数封装在一个同步函数中分开调用。</li>
</ul>
<h4 id="10-5-ParameterizeMethod（令函数携带参数）283"><a href="#10-5-ParameterizeMethod（令函数携带参数）283" class="headerlink" title="10.5 ParameterizeMethod（令函数携带参数）283"></a>10.5 ParameterizeMethod（令函数携带参数）283</h4><ul>
<li>情形：若干个函数做了类似的工作，但在函数本体中却包含了不同的值。</li>
<li>做法：建立单一函数，以参数表达那些不同的值。</li>
<li>要点： <strong><em>可将少量数值视为参数</em></strong></li>
</ul>
<h4 id="10-6-ReplaceParameterwithExplicitMethods（以明确函数取代参数）285"><a href="#10-6-ReplaceParameterwithExplicitMethods（以明确函数取代参数）285" class="headerlink" title="10.6 ReplaceParameterwithExplicitMethods（以明确函数取代参数）285"></a>10.6 ReplaceParameterwithExplicitMethods（以明确函数取代参数）285</h4><ul>
<li>情形：有个函数完全有数值不同采取不同的行为</li>
<li>做法：针对该参数的每个可能值，建立独立函数。</li>
<li>对比：与ParameterizeMethod（令函数携带参数）相反</li>
<li>目的：提供清晰的入口。</li>
<li>如果参数值对函数行为影响不大，不应该采用此方法。</li>
</ul>
<h4 id="10-7-PreserveWholeObject（保持对象完整）288"><a href="#10-7-PreserveWholeObject（保持对象完整）288" class="headerlink" title="10.7 PreserveWholeObject（保持对象完整）288"></a>10.7 PreserveWholeObject（保持对象完整）288</h4><ul>
<li>情形：从某个对象取若干值，把他们作为参数传给函数</li>
<li>做法：改为调用整个对象</li>
<li>目的：避免过长参数</li>
<li>不使用该方法：<ul>
<li>如果函数只依赖那些值不依赖对象，那么不能采用此方法，会导致耦合</li>
<li>有时候函数使用了很多来自对象的数据，那么应该考虑使用（Move Method）</li>
</ul>
</li>
</ul>
<h4 id="10-8-ReplaceParameterwithMethods（以函数取代参数）292"><a href="#10-8-ReplaceParameterwithMethods（以函数取代参数）292" class="headerlink" title="10.8 ReplaceParameterwithMethods（以函数取代参数）292"></a>10.8 ReplaceParameterwithMethods（以函数取代参数）292</h4><ul>
<li>情形：对象调用某个函数，并将所得结果作为参数传递给另一个函数，而接受该参数的函数本身也能够调用前一个函数</li>
<li>做法：让参数接受者去除该项参数，并直接调用前一个函数</li>
</ul>
<h4 id="10-9-IntroduceParameterObject（引入参数对象）295"><a href="#10-9-IntroduceParameterObject（引入参数对象）295" class="headerlink" title="10.9 IntroduceParameterObject（引入参数对象）295"></a>10.9 IntroduceParameterObject（引入参数对象）295</h4><ul>
<li>情形：有些参数总是自然地同时出现</li>
<li>做法：以一个对象取代这些参数</li>
<li>目的：缩短参数长度，函数具有一致性，降低理解和修改代码的难度</li>
</ul>
<h4 id="10-10-RemoveSettingMethod（移除设值函数）300"><a href="#10-10-RemoveSettingMethod（移除设值函数）300" class="headerlink" title="10.10 RemoveSettingMethod（移除设值函数）300"></a>10.10 RemoveSettingMethod（移除设值函数）300</h4><ul>
<li>情形：类的某个字段应该对象创建的时候被设置，然后不再改变</li>
<li>做法：去掉该字段的设置函数</li>
</ul>
<h4 id="10-11-HideMethod（隐藏函数）303"><a href="#10-11-HideMethod（隐藏函数）303" class="headerlink" title="10.11 HideMethod（隐藏函数）303"></a>10.11 HideMethod（隐藏函数）303</h4><ul>
<li>情形：有一个函数，从来没有被任何类调用</li>
<li>做法：将该函数设为private</li>
</ul>
<h4 id="10-12-ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）304"><a href="#10-12-ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）304" class="headerlink" title="10.12 ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）304"></a>10.12 ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）304</h4><ul>
<li>情形：创建对象时不仅仅是做简单的构建动作</li>
<li>做法：将构造函数替换为工厂模式</li>
</ul>
<h4 id="10-13-EncapsulateDowncast（封装向下转型）308"><a href="#10-13-EncapsulateDowncast（封装向下转型）308" class="headerlink" title="10.13 EncapsulateDowncast（封装向下转型）308"></a>10.13 EncapsulateDowncast（封装向下转型）308</h4><ul>
<li>情形：某个函数返回的对象，需要由函数调用者执行向下转型（）downcast</li>
<li>做法：将向下转型移到函数中</li>
</ul>
<h4 id="10-14-ReplaceErrorCodewithException（以异常取代错误码）310"><a href="#10-14-ReplaceErrorCodewithException（以异常取代错误码）310" class="headerlink" title="10.14 ReplaceErrorCodewithException（以异常取代错误码）310"></a>10.14 ReplaceErrorCodewithException（以异常取代错误码）310</h4><ul>
<li>情形：某个函数返回一个特定的代码，表示某个错误的情况</li>
<li>做法：改用异常</li>
</ul>
<h4 id="10-15-ReplaceExceptionwithTest（以测试取代异常）315"><a href="#10-15-ReplaceExceptionwithTest（以测试取代异常）315" class="headerlink" title="10.15 ReplaceExceptionwithTest（以测试取代异常）315"></a>10.15 ReplaceExceptionwithTest（以测试取代异常）315</h4><ul>
<li>情形：面对一个调用者可以预先检查条件，你抛出了一个异常</li>
<li>做法：修改调用者，使它在调用函数之前检查。</li>
</ul>
<h3 id="第11章-处理概括关系319"><a href="#第11章-处理概括关系319" class="headerlink" title="第11章 处理概括关系319"></a>第11章 处理概括关系319</h3><h4 id="11-1-PullUpField（字段上移）320"><a href="#11-1-PullUpField（字段上移）320" class="headerlink" title="11.1 PullUpField（字段上移）320"></a>11.1 PullUpField（字段上移）320</h4><ul>
<li>情形：两个子类拥有相同的字段</li>
<li>做法：将该字段移动到超类，去除重复数据声明和关于数据的重复行为。并堆超类该字段使用-SelfEncapsulateField（自封装字段）</li>
</ul>
<h4 id="11-2-PullUpMethod（函数上移）322"><a href="#11-2-PullUpMethod（函数上移）322" class="headerlink" title="11.2 PullUpMethod（函数上移）322"></a>11.2 PullUpMethod（函数上移）322</h4><ul>
<li>情形：有些函数，在各个子类产生相同的结果。</li>
<li>做法：将该函数移动到超类</li>
</ul>
<h4 id="11-3-PullUpConstructorBody（构造函数本体上移）325"><a href="#11-3-PullUpConstructorBody（构造函数本体上移）325" class="headerlink" title="11.3 PullUpConstructorBody（构造函数本体上移）325"></a>11.3 PullUpConstructorBody（构造函数本体上移）325</h4><ul>
<li>情形：你在各个子类拥有一些构造函数，它们的本地几乎完全一致</li>
<li>做法：在超类新建一个构造函数，并在子类构造函数中调用它。</li>
<li>具体做法：<ul>
<li>将共同代码复制到超类构造函数中</li>
<li>将共同代码放在子类构造函数起始处，然后再复制到超类构造函数中。</li>
<li>将子类构造函数中共同代码删除，改用调用新建的超类构造函数。</li>
</ul>
</li>
</ul>
<h4 id="11-4-PushDownMethod（函数下移）328"><a href="#11-4-PushDownMethod（函数下移）328" class="headerlink" title="11.4 PushDownMethod（函数下移）328"></a>11.4 PushDownMethod（函数下移）328</h4><ul>
<li>情形：超类中的某个函数只与部分而非全部子类有关</li>
<li>做法：将这个函数移到相关的子类去。</li>
</ul>
<h4 id="11-5-PushDownField（字段下移）329"><a href="#11-5-PushDownField（字段下移）329" class="headerlink" title="11.5 PushDownField（字段下移）329"></a>11.5 PushDownField（字段下移）329</h4><ul>
<li>情形：超类中的某个字段只被部分而非全部子类使用</li>
<li>做法：将这个字段移到需要它的那些子类去。</li>
</ul>
<h4 id="11-6-ExtractSubclass（提炼子类）330"><a href="#11-6-ExtractSubclass（提炼子类）330" class="headerlink" title="11.6 ExtractSubclass（提炼子类）330"></a>11.6 ExtractSubclass（提炼子类）330</h4><ul>
<li>情形：类中的某些特性只被某些而非全部实例用到。</li>
<li>做法：新建一个子类，将上面所说的那一部分特性移到子类中。</li>
<li>具体情况：<ul>
<li>并不是出现类型码就表示需要用到子类，可以在委托和继承之间做选择。</li>
<li>为子类新建构造函数，如果需要  <em>隐藏子类</em>，可使用ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）<ul>
<li>找出超类调用点，如超类构造函数与子类不同，通过rename method方法可以解决。</li>
<li>如果不需要超类实例，可以将超类声明为抽象类。</li>
</ul>
</li>
<li>逐一使用字段下移、函数下移将源类的特性移动到子类。</li>
</ul>
</li>
</ul>
<h4 id="11-7-ExtractSuperclass（提炼超类）336"><a href="#11-7-ExtractSuperclass（提炼超类）336" class="headerlink" title="11.7 ExtractSuperclass（提炼超类）336"></a>11.7 ExtractSuperclass（提炼超类）336</h4><ul>
<li>情形：两个类有相似特性。</li>
<li>做法：为两个类建立一个超类，将相同特性移至超类。</li>
</ul>
<h4 id="11-8-Extract-Interface（提炼接口）341"><a href="#11-8-Extract-Interface（提炼接口）341" class="headerlink" title="11.8 Extract Interface（提炼接口）341"></a>11.8 Extract Interface（提炼接口）341</h4><ul>
<li>情形：某组用户只使用类责任区中一个特定子集或者两个类的接口有部分相同。</li>
<li>做法：将相同子集提炼到独立的接口中。</li>
<li>区别：提炼超类是提炼共同代码，提炼接口时提炼共同接口。</li>
<li>具体情形：如果某个类在不同环境下扮演截然不同的角色，使用接口就是个好主意。</li>
</ul>
<h4 id="11-9-Collapse-Hierarchy（折叠继承体系）344"><a href="#11-9-Collapse-Hierarchy（折叠继承体系）344" class="headerlink" title="11.9 Collapse Hierarchy（折叠继承体系）344"></a>11.9 Collapse Hierarchy（折叠继承体系）344</h4><ul>
<li>情形：超类和子类之间区别不大。</li>
<li>做法：将它们合为一体。</li>
</ul>
<h4 id="11-10-Form-TemPlate-Method（塑造模板函数）344"><a href="#11-10-Form-TemPlate-Method（塑造模板函数）344" class="headerlink" title="11.10 Form TemPlate Method（塑造模板函数）344"></a>11.10 Form TemPlate Method（塑造模板函数）344</h4><ul>
<li>情形：你有一些子类，其中相应的函数以相同顺序执行类似的操作，但各个操作的细节有所不同。</li>
<li>做法：将这些小操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也变得相同了。然后将原函数上移至超类，运用多态来避免重复代码。</li>
<li>原因：虽然使用了继承，但是函数重复应尽量避免。</li>
</ul>
<h4 id="11-11-Replace-inherited-with-Delegation（以委托取代继承）352"><a href="#11-11-Replace-inherited-with-Delegation（以委托取代继承）352" class="headerlink" title="11.11 Replace inherited with Delegation（以委托取代继承）352"></a>11.11 Replace inherited with Delegation（以委托取代继承）352</h4><ul>
<li>情形：某个子类只使用超类接口中一部分，或是根本不需要继承而来的数据</li>
<li>做法：在子类中新建一个字段用以保存超类，调整子类函数，令它委托超类，然后去掉两者之间的继承关系。</li>
</ul>
<h4 id="11-12-Replace-Delegation-with-Inherited（以继承取代委托）352"><a href="#11-12-Replace-Delegation-with-Inherited（以继承取代委托）352" class="headerlink" title="11.12 Replace Delegation with Inherited（以继承取代委托）352"></a>11.12 Replace Delegation with Inherited（以继承取代委托）352</h4><ul>
<li>情形：在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数，</li>
<li>做法：让委托类继承受托类。</li>
<li>告诫：<ul>
<li>如果并没有使用受托类的所有函数，那么就不要使用这个方法。因为子类应该总是遵循超类的接口，如果委托过多可以通过移除“中间人”方法让客户端调用受托函数，或者“提炼超类”，让两个类的接口提炼到超类中。类似的还可以使用“提炼接口”方法。</li>
<li>如果受托对象被不止一个其他对象共享，而且受托对象是可变的时候，那么这湿乎乎不能讲委托关系替换为继承关系。</li>
</ul>
</li>
</ul>
<p>……</p>
<h3 id="第12章-大型重构359"><a href="#第12章-大型重构359" class="headerlink" title="第12章 大型重构359"></a>第12章 大型重构359</h3><h3 id="第13章-重构，复用与现实379"><a href="#第13章-重构，复用与现实379" class="headerlink" title="第13章 重构，复用与现实379"></a>第13章 重构，复用与现实379</h3><h3 id="第14章-重构工具401"><a href="#第14章-重构工具401" class="headerlink" title="第14章 重构工具401"></a>第14章 重构工具401</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/15/unit-test-java/" itemprop="url">
                  《单元测试之道Java版》读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-15T22:58:00+08:00" content="2017-02-15">
              2017-02-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/02/15/unit-test-java/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/15/unit-test-java/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="单元测试的定义"><a href="#单元测试的定义" class="headerlink" title="单元测试的定义"></a>单元测试的定义</h4><p>来自：<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" title="维基百科" target="_blank" rel="external">维基百科</a></p>
<blockquote>
<p>在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。<br>通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到软件规格书要求的工作目标，没有程序错误；虽然单元测试不是什么必须的，但也不坏，这牵涉到项目管理的政策决定。</p>
</blockquote>
<h4 id="单元测试的内容（Right-BICEP）"><a href="#单元测试的内容（Right-BICEP）" class="headerlink" title="单元测试的内容（Right-BICEP）"></a>单元测试的内容（Right-BICEP）</h4><h5 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h5><ul>
<li>Right：结果是否正确？</li>
<li>B：是否所有边界条件都是正确？</li>
<li>I：能查下反向关联？</li>
<li>C：能用 <strong><em>交叉手段</em></strong>检查一下结果？</li>
<li>E：是否强制错误条件发生（模拟错误发生）</li>
<li>P：是否满足性能要求</li>
</ul>
<h5 id="结果是否正确"><a href="#结果是否正确" class="headerlink" title="结果是否正确"></a>结果是否正确</h5><ol>
<li>验证结果的正确性需要 <strong><em>了解需求</em></strong>,可以通过需求文档来了解；在需求文档不充足或者不完整的情况下，可以站在用户的角度去思考期望的结果是什么。</li>
<li>针对大量测试需要数据文件，在构造 <strong><em>测试数据</em></strong>的时候需要倍加小心</li>
</ol>
<h5 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h5><ol>
<li>举例：<ol>
<li>格式错误的数据（如输入手机号是包含英文字母）</li>
<li>空值或者不完整的数据（如null,””等）</li>
<li>不在预期的合理值范围内（目前没有大于1000岁的人）</li>
<li>事情的到达的次序不一样，可以理解为是前提条件（如未登录就尝试读取用户数据）</li>
</ol>
</li>
<li>总结：<ol>
<li>一致性 Conformance ：值是否与预期一致</li>
<li>顺序性 Ordering ：值是有序还是无序</li>
<li>区间性 Range ：值是否在合理的区间内</li>
<li>依赖性 Reference ：代码是否引用了代码无法控制的外部资源（如数据库）</li>
<li>存在性 Existence ：值是否存在（是否非null，非0，非””）</li>
<li>基数性 Cardinatity ：是否有足够的值</li>
<li>相对或者绝对的时间性 Time ：所有事情是否发生有序？是否在正确时间执行？是否恰好及时？</li>
</ol>
</li>
</ol>
<h5 id="检查反向关联"><a href="#检查反向关联" class="headerlink" title="检查反向关联"></a>检查反向关联</h5><ol>
<li>通过反向的逻辑关系来验证</li>
<li>例子：<ul>
<li>插入数据库，可以通过查询数据库来验证</li>
<li>写入文件，可以通过读取文件内容来验证</li>
</ul>
</li>
</ol>
<h5 id="使用其他手段来交叉检查"><a href="#使用其他手段来交叉检查" class="headerlink" title="使用其他手段来交叉检查"></a>使用其他手段来交叉检查</h5><ol>
<li>交叉检查就是被测试的方法A有与其相同功能但使用了另一套算法的方法B，但由于一些原因（性能不佳）不在项目中使用，利用B来验证A的结果正确性</li>
<li>使用与操作值有约束关系的其他数据来验证：如在图书管理系统中，借出数增加，留存数肯定是下降的</li>
</ol>
<h5 id="强制错误发生条件"><a href="#强制错误发生条件" class="headerlink" title="强制错误发生条件"></a>强制错误发生条件</h5><ol>
<li>主要是人为制作硬件环境或者运行环境的错误</li>
<li>checkList：<ul>
<li>内存耗光</li>
<li>磁盘用满</li>
<li>时钟出问题</li>
<li>网络不可用</li>
<li>系统过载</li>
</ul>
</li>
</ol>
<h5 id="性能特性"><a href="#性能特性" class="headerlink" title="性能特性"></a>性能特性</h5><ol>
<li>不是性能而是性能特性：性能随着规模的增加的变化趋势</li>
</ol>
<h5 id="边界条件详解"><a href="#边界条件详解" class="headerlink" title="边界条件详解"></a>边界条件详解</h5><ol>
<li>一致性：类似于数据的格式是否跟预期一致</li>
<li>有序性：数据是否按照某种特定顺序排序</li>
<li>区间性：<ul>
<li>索引：负 越界等</li>
<li>值的预期区间</li>
</ul>
</li>
<li>依赖性/耦合性：<ul>
<li>前条件：方法运行需要系统处于什么状态</li>
<li>后条件：方法存在任何副作用都需要检查</li>
</ul>
</li>
<li>存在性：给定事物是否存在</li>
<li>基数性：考虑0-1-n三种情况，其中n是随着业务的变化而变化<ul>
<li>例子：订单的前十名：订单少于10个；订单等于10个；订单为0</li>
</ul>
</li>
<li>时间性：<ul>
<li>相对时间（方法执行顺序）</li>
<li>绝对时间（耗时（超时）或者时钟的时间）</li>
<li>并发问题（多线程或者多进程问题）</li>
</ul>
</li>
</ol>
<h4 id="使用MOCK对象"><a href="#使用MOCK对象" class="headerlink" title="使用MOCK对象"></a>使用MOCK对象</h4><h5 id="合适使用MOCK对象"><a href="#合适使用MOCK对象" class="headerlink" title="合适使用MOCK对象"></a>合适使用MOCK对象</h5><ol>
<li>真实对象具有不可确定的行为</li>
<li>真实对象很难被创建</li>
<li>真实对象的某些行为很难触发（如网络错误）</li>
<li>真实对象令程序的运行速度很慢</li>
<li>真实对象有用户界面</li>
<li>测试需要询问真实对象是如何被调用的（验证对象某个函数是否被调用）</li>
<li>真实对象并不存在（需要不同开发小组或者跟新硬件系统打交道）</li>
</ol>
<h5 id="MOCK步骤"><a href="#MOCK步骤" class="headerlink" title="MOCK步骤"></a>MOCK步骤</h5><ol>
<li>使用一个接口来描述一个对象</li>
<li>为产品代码实现这个接口</li>
<li>以测试为目的，在mock对象中实现这个接口</li>
</ol>
<h4 id="好的测试需要具备的品质（A-TRIP）"><a href="#好的测试需要具备的品质（A-TRIP）" class="headerlink" title="好的测试需要具备的品质（A-TRIP）"></a>好的测试需要具备的品质（A-TRIP）</h4><h5 id="自动化（Automatic）"><a href="#自动化（Automatic）" class="headerlink" title="自动化（Automatic）"></a>自动化（Automatic）</h5><ol>
<li>概述：调用测试自动化和检查结果自动化</li>
<li>拓展：持续构建</li>
</ol>
<h5 id="彻底的（Thorough）"><a href="#彻底的（Thorough）" class="headerlink" title="彻底的（Thorough）"></a>彻底的（Thorough）</h5><ol>
<li>取舍：是测试都覆盖全部代码分支还是仅仅测试最可能的情况</li>
<li>通过相关的代码覆盖工具进行检查</li>
</ol>
<h5 id="可重复（Repeatable）"><a href="#可重复（Repeatable）" class="headerlink" title="可重复（Repeatable）"></a>可重复（Repeatable）</h5><ol>
<li>测试必须不随顺序影响或者外部条件变化，每次都出现 <strong><em>相同的结果</em></strong>，也就是说必要时应该Mock来隔离外部因素，使测试能够独立与外部，也就是说测试是运行在 <strong><em>sanbox</em></strong>沙盒里面</li>
</ol>
<h5 id="独立的（Independent）"><a href="#独立的（Independent）" class="headerlink" title="独立的（Independent）"></a>独立的（Independent）</h5><ol>
<li>一个测试函数应该专注于一个目标函数或者组合起来的共同提供某个特性的一组函数</li>
<li>一个测试函数不能依赖与另一个测试函数，也就是不能假定测试函数的执行顺序，因为随着测试数目的增加，这种顺序将变得难以管理。最好是通过setup和teardown来确保每个测试都有一个新的开始。</li>
<li>每个测试函数都是一个 <strong><em>孤岛</em></strong></li>
</ol>
<h5 id="专业的（Professional）"><a href="#专业的（Professional）" class="headerlink" title="专业的（Professional）"></a>专业的（Professional）</h5><ol>
<li>跟编写产品代码一样，一旦发现有代码冗余重复，就应该重构将该功能放到一个函数里面。</li>
<li>保持简洁和精炼，设计要良好且重构充分，<strong><em>对待测试代码应该对待产品代码一样</em></strong></li>
<li>不要为了测试而测试，对于发生可能性很低的错误不要进行测试</li>
<li>自设圈套:让产品产生想要测试的bug，验证测试是否失败</li>
</ol>
<h4 id="项目中进行测试"><a href="#项目中进行测试" class="headerlink" title="项目中进行测试"></a>项目中进行测试</h4><h5 id="测试与评审"><a href="#测试与评审" class="headerlink" title="测试与评审"></a>测试与评审</h5><ol>
<li>编写test case 和/或测试代码</li>
<li>评审test case 和/或测试代码</li>
<li>经评审修改test case 和/或测试代码</li>
<li>编写能通过所有测试的产品代码</li>
<li>评审产品代码和测试代码</li>
<li>在每次评审后，修改测试代码和产品代码</li>
</ol>
<h4 id="设计话题"><a href="#设计话题" class="headerlink" title="设计话题"></a>设计话题</h4><h5 id="面向测试设计"><a href="#面向测试设计" class="headerlink" title="面向测试设计"></a>面向测试设计</h5><ol>
<li>关注点分离，包括：封装性，正交性、耦合性和所有一切编写shycode的计算机科学概念</li>
<li>比如一个函数有多个操作，可以将多个操作分离到各个方法里面这样就可以独立进行测试</li>
</ol>
<h5 id="为测试而重构"><a href="#为测试而重构" class="headerlink" title="为测试而重构"></a>为测试而重构</h5><h5 id="测试类的不变性"><a href="#测试类的不变性" class="headerlink" title="测试类的不变性"></a>测试类的不变性</h5><ol>
<li>跟上述测试的内容有重合的部分，不再赘述</li>
</ol>
<h5 id="测试驱动设计-TDD"><a href="#测试驱动设计-TDD" class="headerlink" title="测试驱动设计 TDD"></a>测试驱动设计 TDD</h5><p>TDD：在编写代码之前先编写测试代码</p>
<p>只是做了简单的介绍；TDD好处在于你把自己当成产品的用户，在这个角度你对代码所提供的接口有了更多的感知，从而做出更好的设计</p>
<h5 id="测试无效参数"><a href="#测试无效参数" class="headerlink" title="测试无效参数"></a>测试无效参数</h5><p>无效参数在哪里检查呢？</p>
<ul>
<li>要是在系统任意部分都做检查，显然会出现重复检查的情况（违反DRY）原则且浪费精力和时间</li>
<li>通常是采用“不让野蛮人入门”的想法，在系统的入口对参数进行检查，然后系统内部就可以信任这些数据了</li>
</ul>
<p>[2]: </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/23/算法-查找/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-23T22:38:59+08:00" content="2016-12-23">
              2016-12-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/23/算法-查找/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/23/算法-查找/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="3-2-二叉查找树"><a href="#3-2-二叉查找树" class="headerlink" title="3.2 二叉查找树"></a>3.2 二叉查找树</h2><ol>
<li>定义：二叉查找树就是一个二叉树。其中每个借点都含有一个compareable的键且每个结点都含有一个左连接和右连接，且每个结点上的都大于左子树上任意结点的键，小于右子树上任意结点的键。</li>
<li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.N = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">       root =  put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Node node, Key key, Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果结点为空 新建结点</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键与结点的键比较</span></span><br><span class="line">        <span class="keyword">int</span> compareTo =key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//大于结点的键，则向右子树加入键</span></span><br><span class="line">            node.right = put(node.right,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//小于结点的键，则向左子树加入键</span></span><br><span class="line">           node.left=  put(node.left,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//相等则替换结点的值</span></span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重新计数</span></span><br><span class="line">        node.N = size(node.left)+<span class="number">1</span>+size(node.right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node== <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 结点为null返回null</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键与结点的键比较</span></span><br><span class="line">        <span class="keyword">int</span> compareTo =key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo &gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> get(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span> )&#123;</span><br><span class="line">           <span class="keyword">return</span>  get(node.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">min</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> min(node.left)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小于等于key的最大key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> floor(node,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">floor</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键与结点的键比较</span></span><br><span class="line">        <span class="keyword">int</span> compare = key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//找到右子树小于等于该键的键</span></span><br><span class="line">            Key rightMin = floor(node.right,key);</span><br><span class="line">            <span class="comment">//没有找到 自己为小于等于该键最大的键</span></span><br><span class="line">            <span class="keyword">if</span>(rightMin == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node.key;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//有则返回该键</span></span><br><span class="line">                <span class="keyword">return</span> rightMin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//从左子树查找</span></span><br><span class="line">           <span class="keyword">return</span>  floor(node.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> rank)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(root,rank);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">select</span><span class="params">(Node node,<span class="keyword">int</span> rank)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size =size(node.left);</span><br><span class="line">        <span class="keyword">if</span>(size&lt; rank)&#123;</span><br><span class="line">            <span class="keyword">return</span> select(node.right,(rank-size-<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size&gt;rank)&#123;</span><br><span class="line">            <span class="keyword">return</span> select(node.left,rank);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">int</span> compareTo =key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo&lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rank(node.left,key));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> size(node.left)+<span class="number">1</span>+rank(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">      root =  deleteMin(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           node.left =  deleteMin(node.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        node.N = size(node.left)+size(node.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">      root =  delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> compareTo = key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.right = delete(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.left = delete(node.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 右树为空 新结点为左子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左子树为空，新节点为右子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">             Node minNode = min(node.right);</span><br><span class="line">            Node t= node;</span><br><span class="line">            node = minNode;</span><br><span class="line">            node.right = deleteMin(t.right);</span><br><span class="line">            node.left = t.left; </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        node.N = size(node.left)+size(node.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys(min(),max());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo ,Key hi)</span></span>&#123;</span><br><span class="line">        Queue&lt;Key&gt; queue = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">         keys(root,queue,lo,hi);</span><br><span class="line">         <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node node,Queue&lt;Key&gt; queue,Key lo ,Key hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> compareLo = lo.compareTo(node.key);</span><br><span class="line">        <span class="keyword">int</span> compareHi = hi.compareTo(node.key);</span><br><span class="line">        <span class="comment">//查左树</span></span><br><span class="line">        <span class="keyword">if</span>(compareLo&lt;<span class="number">0</span> )&#123;</span><br><span class="line">            keys(node.left,lo,hi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结点</span></span><br><span class="line">        <span class="keyword">if</span>(compareHi&gt;=<span class="number">0</span> || compareLo&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">             queue.enqueue(node.key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查右树</span></span><br><span class="line">        <span class="keyword">if</span>(compareHi&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            keys(node.right,lo,hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>3.性能：</p>
<blockquote>
<p>在由N个随机键构成的二叉查找树中，查找命中平均所需的比较次数为~2lnN(约1.39lgN)</p>
<p>在由N个随机键构成的二叉查找树中插入和查找命中未命中的元素平均所需的比较次数为~2lnN(约1.39lgN)</p>
</blockquote>
<h2 id="3-3-平衡查找树"><a href="#3-3-平衡查找树" class="headerlink" title="3.3 平衡查找树"></a>3.3 平衡查找树</h2><h3 id="3-3-1-2-3查找树"><a href="#3-3-1-2-3查找树" class="headerlink" title="3.3.1 2-3查找树"></a>3.3.1 2-3查找树</h3><ol>
<li>定义：一棵2-3查找树或为一棵空疏，或由以下结点组成：<ul>
<li>2-结点：含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向2-3树中的键都大于该结点。</li>
<li>3-结点：含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向2-3树中的键都位于该结点的两个键之间，右链接指向2-3树中的键都大于该结点。</li>
</ul>
</li>
<li>原理：<ul>
<li>向2-结点插入新结点:只要变成3-结点即可</li>
<li>向一棵只含有一个3-结点的树中插入新键：<ul>
<li>变成4-结点，然后中键上移变成由3个2-结点组成的2-3树</li>
</ul>
</li>
<li>向一个父节点为2-结点的3-结点中插入新键<ul>
<li>变成4-结点，然后中键上移父节点变成3-结点</li>
</ul>
</li>
<li>向一个父节点为3-结点的3-结点中插入新键<ul>
<li>变成4-结点，然后中键上移父节点变成4-结点，父节点再逐级向上分解。</li>
</ul>
</li>
</ul>
</li>
<li>性能：</li>
</ol>
<blockquote>
<p>  在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个</p>
</blockquote>
<h3 id="3-3-2-红黑树"><a href="#3-3-2-红黑树" class="headerlink" title="3.3.2 红黑树"></a>3.3.2 红黑树</h3><ol>
<li><p>定义：将树的类型分为两种：红链接将两个2-结点连接起来构成3-结点，黑链接则是2-3树种的普通链接。<br>另外一种定义：</p>
<ul>
<li>红链接都为左链接</li>
<li>没有任意一个结点与两条红链接相连</li>
<li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="keyword">boolean</span> color;</span><br><span class="line">    Key key;</span><br><span class="line">    Value value;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key,Value value,<span class="keyword">boolean</span> color,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.N = N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    Node x = h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    h.N = size(h.left)+<span class="number">1</span>+size(h.right);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    Node x = h.left;</span><br><span class="line">    x.right = h;</span><br><span class="line">    h.left = h.right;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    h.N = size(h.left)+<span class="number">1</span>+size(h.right);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//颜色转换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flipColor</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    h.left.color = BLACK;</span><br><span class="line">    h.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackBST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">   Node root;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">        root.color =BLACK;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.color;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node node,Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,RED,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跟二叉查找树一样</span></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           node.right =  put(node.right,key,value);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                node.left =  put(node.left,key,value);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  node.value = value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右子结点为红链接且左子结点是黑链接-》左旋</span></span><br><span class="line">        <span class="keyword">if</span>(isRed(node.right) &amp;&amp; !isRed(node.left))&#123;</span><br><span class="line">           <span class="keyword">return</span>  rotateLeft(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子结点为红链接且左子结点的左子结点是红链接-》右旋</span></span><br><span class="line">        <span class="keyword">if</span>(isRed(node.left) &amp;&amp; isRed(node.left.left))&#123;</span><br><span class="line">           <span class="keyword">return</span> rotateRight(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子结点为红链接且右子结点是红链接-》颜色转换</span></span><br><span class="line">        <span class="keyword">if</span>(isRed(node.left &amp;&amp; isRed(node.right)))&#123;</span><br><span class="line">            flipColor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.N = size(node.left)+<span class="number">1</span>size(node.right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.性能：</p>
<blockquote>
<p>一棵大小为N的红黑树的高度不会超过2lgN</p>
<p>一棵大小为N的红黑树中，根结点到任意结点的平均路径长度为~1.00lgN。</p>
</blockquote>
<h2 id="3-4-散列表"><a href="#3-4-散列表" class="headerlink" title="3.4 散列表"></a>3.4 散列表</h2><ol>
<li>原理：<ul>
<li>第一步用 <strong><em>散列函数</em></strong>将被查找的键转化为数组的一个索引</li>
<li>第二步处理碰撞冲突（用散列函数生成的索引冲突）<ul>
<li>解决的方法：<strong><em>拉链法</em></strong>   和  <strong><em>碰撞法</em></strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-4-1-散列函数"><a href="#3-4-1-散列函数" class="headerlink" title="3.4.1 散列函数"></a>3.4.1 散列函数</h3><ol>
<li>对于每一种类型的键都需要一个与之对应的散列函数。</li>
<li><p>方法：</p>
<ul>
<li>整型：除留余数法 选择一个素数M；然后键的索引=<code>k%M</code></li>
<li>浮点数：将键编程二进制数然后再使用除留余数法</li>
<li><p>字符串：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.length();i++)&#123;</span><br><span class="line">   hash = (R * hash + s.charAt(i)) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将hashCode()的返回值转化为一个数组索引</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x.hashCode() &amp;&amp; <span class="number">0x7fffffff</span>)%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="3-4-2-基于拉链法的散列表"><a href="#3-4-2-基于拉链法的散列表" class="headerlink" title="3.4.2 基于拉链法的散列表"></a>3.4.2 基于拉链法的散列表</h3><ol>
<li>原理：选择足够大的M，使得所有链表都尽可能短以保证高效的查找。</li>
<li>查找：先根据散列值找到链表。然后沿着链表顺序查找相应的键。</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparteChainingHashST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对的总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;<span class="comment">//散列表的大小</span></span><br><span class="line">    <span class="keyword">private</span> SquenticalSearchST&lt;Key,Value&gt;[] st;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparteChainingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">997</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparteChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        SquenticalSearchST&lt;Key,Value&gt;[] st = <span class="keyword">new</span> (SquenticalSearchST&lt;Key,Value&gt;)SquenticalSearchST[M];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;M; i++)&#123;</span><br><span class="line">            st[i] = <span class="keyword">new</span> SquenticalSearchST();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        st[hash(key)].put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Value)st[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>性质：</p>
<ul>
<li>在一张含有M条链表和N个键的散列表中，任意一条链表中的键的数量均在N/M的常数因子内的概率无限接近于1.</li>
<li>在一张含有M条链表和N个键的散列表中，未命中查找和插入操作所需的比较次数为~N/M;</li>
</ul>
</li>
</ol>
<h3 id="3-4-2-基于线性探测法的散列表"><a href="#3-4-2-基于线性探测法的散列表" class="headerlink" title="3.4.2 基于线性探测法的散列表"></a>3.4.2 基于线性探测法的散列表</h3><ol>
<li>原理：用大小为M的数组保存N个键对。M&gt;N。利用数组中的空位解决碰撞。这种方法统称为 <strong><em>开放地址散列表</em></strong>。（思想：预期将内存用作链表，不如将它们作为在散列表的空元素）</li>
<li>当碰撞发生时，我们直接检查散列表中的下一个位置。有以下三种情况<ul>
<li>命中，该位置的键与被查找的键相同</li>
<li>未命中，该位置的键为空</li>
<li>继续查找，该位置的键与被查找的键不相同</li>
</ul>
</li>
<li>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashSt</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;<span class="comment">//数组大小</span></span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] values;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashSt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        keys = <span class="keyword">new</span> (Key[]) Object[M];</span><br><span class="line">        values = <span class="keyword">new</span> (Value[]) Object[M];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode()&amp;<span class="number">0x7fffffff</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 确保有空位存放元素</span></span><br><span class="line">        <span class="keyword">if</span>(n&gt;M/<span class="number">2</span>)resize(<span class="number">2</span>*M);</span><br><span class="line">        <span class="comment">//假如key[hash] !=null 索引逐渐加1；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hash(key); keys[i]!=<span class="keyword">null</span> ; i = (i+<span class="number">1</span>)%M)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key[i].equals(key))&#123;</span><br><span class="line">                values[i] = value;<span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i] = key;</span><br><span class="line">        values[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hash(key); keys[i]!=<span class="keyword">null</span> ; i = (i+<span class="number">1</span>)%M)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key[i].equals(key))&#123;</span><br><span class="line">               <span class="keyword">return</span> values[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!contains(key))<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = keys[hash(key)];</span><br><span class="line">        <span class="comment">//找到对应的key的索引</span></span><br><span class="line">        <span class="keyword">while</span>(!key.equals(keys[i])  )&#123;</span><br><span class="line">            i = (i+<span class="number">1</span>)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除该索引的键值</span></span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        values[i] = <span class="keyword">null</span>;</span><br><span class="line">        i = (i+<span class="number">1</span>)%M;</span><br><span class="line">        <span class="comment">//先删除再插入</span></span><br><span class="line">        <span class="keyword">while</span>(keys[i]!=<span class="keyword">null</span>)&#123; </span><br><span class="line">            Key keyToRedo = keys[i];</span><br><span class="line">            Value valueToRedo = values[i];</span><br><span class="line">            keys[i] =<span class="keyword">null</span>;</span><br><span class="line">            values[i] =<span class="keyword">null</span>;</span><br><span class="line">             N--;</span><br><span class="line">             put(keyToRedo,valueToRedo);</span><br><span class="line">              i = (i+<span class="number">1</span>)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N&gt;<span class="number">0</span> &amp;&amp; N==M/<span class="number">8</span>)resize(M/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/06/algorithms-find/" itemprop="url">
                  《算法》读书笔记-查找
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-06T23:16:00+08:00" content="2016-12-06">
              2016-12-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/06/algorithms-find/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/06/algorithms-find/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;查找</p>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="3-1-符号表"><a href="#3-1-符号表" class="headerlink" title="3.1 符号表"></a>3.1 符号表</h2><p>&nbsp;&nbsp;</p>
<h3 id="3-1-1-API"><a href="#3-1-1-API" class="headerlink" title="3.1.1 API"></a>3.1.1 API</h3><h3 id="3-1-4-无序链表中的顺序查找"><a href="#3-1-4-无序链表中的顺序查找" class="headerlink" title="3.1.4 无序链表中的顺序查找"></a>3.1.4 无序链表中的顺序查找</h3><ol>
<li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearchST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node first;</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            Key key;</span><br><span class="line">            Value value;</span><br><span class="line">            Node next;</span><br><span class="line">            Node(Key key,Value value,Node next)&#123;</span><br><span class="line">                <span class="keyword">this</span>.key = key;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">this</span>.next = next;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">            Node node =first;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.key.equals(key))&#123;</span><br><span class="line">                    node.value = value;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            first = <span class="keyword">new</span> Node(key,value,first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">            Node node =first;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.key.equals(key))&#123;</span><br><span class="line">                    <span class="keyword">return</span> node.value;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.性能：</p>
<blockquote>
<p>在含有N对键值的基于链表的符号表中，未命中的查找和插入操作都需要N次比较。命中的查找最坏情况下需要N次比较。特别地，向一个空表中插入N个不同的键需要~N^2次比较</p>
</blockquote>
<h3 id="3-1-5-有序数组中的二分查找"><a href="#3-1-5-有序数组中的二分查找" class="headerlink" title="3.1.5 有序数组中的二分查找"></a>3.1.5 有序数组中的二分查找</h3><ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    Key[] keys;</span><br><span class="line">    Value[] values;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchST</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        keys = <span class="keyword">new</span> (Key[]) Comparable[capacity];</span><br><span class="line">        values = <span class="keyword">new</span> (Value[]) Comparable[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小于等于key个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi = keys.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> middle;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">            middle = lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> compare =key.compareTo(keys[middle]);</span><br><span class="line">            <span class="keyword">if</span>(compare&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                lo = middle +<span class="number">1</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compare &lt;<span class="number">0</span>)&#123;</span><br><span class="line">                hi = middle -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rank = rank(key);</span><br><span class="line">        <span class="keyword">if</span>(keys[rank].key.compareTo(key) == <span class="number">0</span>)&#123;</span><br><span class="line">            keys[rank].value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N;i&gt;rank;i--)&#123;</span><br><span class="line">            keys[i] = keys[i-<span class="number">1</span>];</span><br><span class="line">            values[i] = values[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        keys[rank] = key;</span><br><span class="line">        values[rank] = value;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rank = rank(key);</span><br><span class="line">        <span class="keyword">if</span>(rank&lt; N &amp;&amp; keys[rank].compareTo(key)== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> keys[rank].value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">          <span class="keyword">return</span> ;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rank = rank(key);</span><br><span class="line">        <span class="keyword">if</span>(rank&lt; N &amp;&amp; keys[rank].compareTo(key)== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = rank;i&lt;N-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                keys[i] = keys[i+<span class="number">1</span>]; </span><br><span class="line">                values[i] = values[i+<span class="number">1</span>]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[N-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> key <span class="title">select</span><span class="params">(<span class="keyword">int</span> rank)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[rank];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//大于等于key的最大键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> key <span class="title">ceiling</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[rank(key)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小于等于key的最大键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rank = rank(key);</span><br><span class="line">        <span class="keyword">if</span>(keys[rank].compareTo(key)== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> keys[rank];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rank == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> keys[rank - <span class="number">1</span>];    </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>性能：</p>
</li>
</ol>
<blockquote>
<p>   在由N个键构成的有序数组中进行二分查找最多需要lgN+1次数比较（无论是否成功）</p>
<p>  在由N个键构成的有序数组中插入一个新的元素在最坏情况下需要访问~2N次数组，因此向一个空符号表中插入N个元素的最坏情况需要访问~N^2次数组</p>
</blockquote>
<h2 id="3-2-二叉查找树"><a href="#3-2-二叉查找树" class="headerlink" title="3.2 二叉查找树"></a>3.2 二叉查找树</h2><ol>
<li>定义：二叉查找树就是一个二叉树。其中每个借点都含有一个compareable的键且每个结点都含有一个左连接和右连接，且每个结点上的都大于左子树上任意结点的键，小于右子树上任意结点的键。</li>
<li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.N = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">       root =  put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Node node, Key key, Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果结点为空 新建结点</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键与结点的键比较</span></span><br><span class="line">        <span class="keyword">int</span> compareTo =key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//大于结点的键，则向右子树加入键</span></span><br><span class="line">            node.right = put(node.right,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//小于结点的键，则向左子树加入键</span></span><br><span class="line">           node.left=  put(node.left,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//相等则替换结点的值</span></span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重新计数</span></span><br><span class="line">        node.N = size(node.left)+<span class="number">1</span>+size(node.right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node== <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 结点为null返回null</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键与结点的键比较</span></span><br><span class="line">        <span class="keyword">int</span> compareTo =key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo &gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> get(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span> )&#123;</span><br><span class="line">           <span class="keyword">return</span>  get(node.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">min</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> min(node.left)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小于等于key的最大key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> floor(node,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">floor</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键与结点的键比较</span></span><br><span class="line">        <span class="keyword">int</span> compare = key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//找到右子树小于等于该键的键</span></span><br><span class="line">            Key rightMin = floor(node.right,key);</span><br><span class="line">            <span class="comment">//没有找到 自己为小于等于该键最大的键</span></span><br><span class="line">            <span class="keyword">if</span>(rightMin == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node.key;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//有则返回该键</span></span><br><span class="line">                <span class="keyword">return</span> rightMin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//从左子树查找</span></span><br><span class="line">           <span class="keyword">return</span>  floor(node.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> rank)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(root,rank);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">select</span><span class="params">(Node node,<span class="keyword">int</span> rank)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size =size(node.left);</span><br><span class="line">        <span class="keyword">if</span>(size&lt; rank)&#123;</span><br><span class="line">            <span class="keyword">return</span> select(node.right,(rank-size-<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size&gt;rank)&#123;</span><br><span class="line">            <span class="keyword">return</span> select(node.left,rank);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">int</span> compareTo =key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo&lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rank(node.left,key));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> size(node.left)+<span class="number">1</span>+rank(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">      root =  deleteMin(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           node.left =  deleteMin(node.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        node.N = size(node.left)+size(node.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">      root =  delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> compareTo = key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.right = delete(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.left = delete(node.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 右树为空 新结点为左子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左子树为空，新节点为右子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">             Node minNode = min(node.right);</span><br><span class="line">            Node t= node;</span><br><span class="line">            node = minNode;</span><br><span class="line">            node.right = deleteMin(t.right);</span><br><span class="line">            node.left = t.left; </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        node.N = size(node.left)+size(node.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys(min(),max());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo ,Key hi)</span></span>&#123;</span><br><span class="line">        Queue&lt;Key&gt; queue = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">         keys(root,queue,lo,hi);</span><br><span class="line">         <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node node,Queue&lt;Key&gt; queue,Key lo ,Key hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> compareLo = lo.compareTo(node.key);</span><br><span class="line">        <span class="keyword">int</span> compareHi = hi.compareTo(node.key);</span><br><span class="line">        <span class="comment">//查左树</span></span><br><span class="line">        <span class="keyword">if</span>(compareLo&lt;<span class="number">0</span> )&#123;</span><br><span class="line">            keys(node.left,lo,hi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结点</span></span><br><span class="line">        <span class="keyword">if</span>(compareHi&gt;=<span class="number">0</span> || compareLo&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">             queue.enqueue(node.key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查右树</span></span><br><span class="line">        <span class="keyword">if</span>(compareHi&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            keys(node.right,lo,hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>3.性能：</p>
<blockquote>
<p>在由N个随机键构成的二叉查找树中，查找命中平均所需的比较次数为~2lnN(约1.39lgN)</p>
<p>在由N个随机键构成的二叉查找树中插入和查找命中未命中的元素平均所需的比较次数为~2lnN(约1.39lgN)</p>
</blockquote>
<h2 id="3-3-平衡查找树"><a href="#3-3-平衡查找树" class="headerlink" title="3.3 平衡查找树"></a>3.3 平衡查找树</h2><h3 id="3-3-1-2-3查找树"><a href="#3-3-1-2-3查找树" class="headerlink" title="3.3.1 2-3查找树"></a>3.3.1 2-3查找树</h3><ol>
<li>定义：一棵2-3查找树或为一棵空疏，或由以下结点组成：<ul>
<li>2-结点：含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向2-3树中的键都大于该结点。</li>
<li>3-结点：含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向2-3树中的键都位于该结点的两个键之间，右链接指向2-3树中的键都大于该结点。</li>
</ul>
</li>
<li>原理：<ul>
<li>向2-结点插入新结点:只要变成3-结点即可</li>
<li>向一棵只含有一个3-结点的树中插入新键：<ul>
<li>变成4-结点，然后中键上移变成由3个2-结点组成的2-3树</li>
</ul>
</li>
<li>向一个父节点为2-结点的3-结点中插入新键<ul>
<li>变成4-结点，然后中键上移父节点变成3-结点</li>
</ul>
</li>
<li>向一个父节点为3-结点的3-结点中插入新键<ul>
<li>变成4-结点，然后中键上移父节点变成4-结点，父节点再逐级向上分解。</li>
</ul>
</li>
</ul>
</li>
<li>性能：</li>
</ol>
<blockquote>
<p>  在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个</p>
</blockquote>
<h3 id="3-3-2-红黑树"><a href="#3-3-2-红黑树" class="headerlink" title="3.3.2 红黑树"></a>3.3.2 红黑树</h3><ol>
<li><p>定义：将树的类型分为两种：红链接将两个2-结点连接起来构成3-结点，黑链接则是2-3树种的普通链接。<br>另外一种定义：</p>
<ul>
<li>红链接都为左链接</li>
<li>没有任意一个结点与两条红链接相连</li>
<li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="keyword">boolean</span> color;</span><br><span class="line">    Key key;</span><br><span class="line">    Value value;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key,Value value,<span class="keyword">boolean</span> color,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.N = N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    Node x = h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    h.N = size(h.left)+<span class="number">1</span>+size(h.right);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    Node x = h.left;</span><br><span class="line">    x.right = h;</span><br><span class="line">    h.left = h.right;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    h.N = size(h.left)+<span class="number">1</span>+size(h.right);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//颜色转换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flipColor</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    h.left.color = BLACK;</span><br><span class="line">    h.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackBST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">   Node root;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">        root.color =BLACK;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.color;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node node,Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,RED,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跟二叉查找树一样</span></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           node.right =  put(node.right,key,value);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                node.left =  put(node.left,key,value);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  node.value = value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右子结点为红链接且左子结点是黑链接-》左旋</span></span><br><span class="line">        <span class="keyword">if</span>(isRed(node.right) &amp;&amp; !isRed(node.left))&#123;</span><br><span class="line">           <span class="keyword">return</span>  rotateLeft(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子结点为红链接且左子结点的左子结点是红链接-》右旋</span></span><br><span class="line">        <span class="keyword">if</span>(isRed(node.left) &amp;&amp; isRed(node.left.left))&#123;</span><br><span class="line">           <span class="keyword">return</span> rotateRight(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子结点为红链接且右子结点是红链接-》颜色转换</span></span><br><span class="line">        <span class="keyword">if</span>(isRed(node.left &amp;&amp; isRed(node.right)))&#123;</span><br><span class="line">            flipColor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.N = size(node.left)+<span class="number">1</span>size(node.right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.性能：</p>
<blockquote>
<p>一棵大小为N的红黑树的高度不会超过2lgN</p>
<p>一棵大小为N的红黑树中，根结点到任意结点的平均路径长度为~1.00lgN。</p>
</blockquote>
<h2 id="3-4-散列表"><a href="#3-4-散列表" class="headerlink" title="3.4 散列表"></a>3.4 散列表</h2><ol>
<li>原理：<ul>
<li>第一步用 <strong><em>散列函数</em></strong>将被查找的键转化为数组的一个索引</li>
<li>第二步处理碰撞冲突（用散列函数生成的索引冲突）<ul>
<li>解决的方法：<strong><em>拉链法</em></strong>   和  <strong><em>碰撞法</em></strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-4-1-散列函数"><a href="#3-4-1-散列函数" class="headerlink" title="3.4.1 散列函数"></a>3.4.1 散列函数</h3><ol>
<li>对于每一种类型的键都需要一个与之对应的散列函数。</li>
<li><p>方法：</p>
<ul>
<li>整型：除留余数法 选择一个素数M；然后键的索引=<code>k%M</code></li>
<li>浮点数：将键编程二进制数然后再使用除留余数法</li>
<li><p>字符串：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.length();i++)&#123;</span><br><span class="line">   hash = (R * hash + s.charAt(i)) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将hashCode()的返回值转化为一个数组索引</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x.hashCode() &amp;&amp; <span class="number">0x7fffffff</span>)%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="3-4-2-基于拉链法的散列表"><a href="#3-4-2-基于拉链法的散列表" class="headerlink" title="3.4.2 基于拉链法的散列表"></a>3.4.2 基于拉链法的散列表</h3><ol>
<li>原理：选择足够大的M，使得所有链表都尽可能短以保证高效的查找。</li>
<li>查找：先根据散列值找到链表。然后沿着链表顺序查找相应的键。</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparteChainingHashST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对的总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;<span class="comment">//散列表的大小</span></span><br><span class="line">    <span class="keyword">private</span> SquenticalSearchST&lt;Key,Value&gt;[] st;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparteChainingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">997</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparteChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        SquenticalSearchST&lt;Key,Value&gt;[] st = <span class="keyword">new</span> (SquenticalSearchST&lt;Key,Value&gt;)SquenticalSearchST[M];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;M; i++)&#123;</span><br><span class="line">            st[i] = <span class="keyword">new</span> SquenticalSearchST();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        st[hash(key)].put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Value)st[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>性质：</p>
<ul>
<li>在一张含有M条链表和N个键的散列表中，任意一条链表中的键的数量均在N/M的常数因子内的概率无限接近于1.</li>
<li>在一张含有M条链表和N个键的散列表中，未命中查找和插入操作所需的比较次数为~N/M;</li>
</ul>
</li>
</ol>
<h3 id="3-4-2-基于线性探测法的散列表"><a href="#3-4-2-基于线性探测法的散列表" class="headerlink" title="3.4.2 基于线性探测法的散列表"></a>3.4.2 基于线性探测法的散列表</h3><ol>
<li>原理：用大小为M的数组保存N个键对。M&gt;N。利用数组中的空位解决碰撞。这种方法统称为 <strong><em>开放地址散列表</em></strong>。（思想：预期将内存用作链表，不如将它们作为在散列表的空元素）</li>
<li>当碰撞发生时，我们直接检查散列表中的下一个位置。有以下三种情况<ul>
<li>命中，该位置的键与被查找的键相同</li>
<li>未命中，该位置的键为空</li>
<li>继续查找，该位置的键与被查找的键不相同</li>
</ul>
</li>
<li>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashSt</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;<span class="comment">//数组大小</span></span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] values;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashSt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        keys = <span class="keyword">new</span> (Key[]) Object[M];</span><br><span class="line">        values = <span class="keyword">new</span> (Value[]) Object[M];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode()&amp;<span class="number">0x7fffffff</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 确保有空位存放元素</span></span><br><span class="line">        <span class="keyword">if</span>(n&gt;M/<span class="number">2</span>)resize(<span class="number">2</span>*M);</span><br><span class="line">        <span class="comment">//假如key[hash] !=null 索引逐渐加1；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hash(key); keys[i]!=<span class="keyword">null</span> ; i = (i+<span class="number">1</span>)%M)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key[i].equals(key))&#123;</span><br><span class="line">                values[i] = value;<span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i] = key;</span><br><span class="line">        values[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hash(key); keys[i]!=<span class="keyword">null</span> ; i = (i+<span class="number">1</span>)%M)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key[i].equals(key))&#123;</span><br><span class="line">               <span class="keyword">return</span> values[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!contains(key))<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = keys[hash(key)];</span><br><span class="line">        <span class="comment">//找到对应的key的索引</span></span><br><span class="line">        <span class="keyword">while</span>(!key.equals(keys[i])  )&#123;</span><br><span class="line">            i = (i+<span class="number">1</span>)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除该索引的键值</span></span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        values[i] = <span class="keyword">null</span>;</span><br><span class="line">        i = (i+<span class="number">1</span>)%M;</span><br><span class="line">        <span class="comment">//先删除再插入</span></span><br><span class="line">        <span class="keyword">while</span>(keys[i]!=<span class="keyword">null</span>)&#123; </span><br><span class="line">            Key keyToRedo = keys[i];</span><br><span class="line">            Value valueToRedo = values[i];</span><br><span class="line">            keys[i] =<span class="keyword">null</span>;</span><br><span class="line">            values[i] =<span class="keyword">null</span>;</span><br><span class="line">             N--;</span><br><span class="line">             put(keyToRedo,valueToRedo);</span><br><span class="line">              i = (i+<span class="number">1</span>)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N&gt;<span class="number">0</span> &amp;&amp; N==M/<span class="number">8</span>)resize(M/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="各个查找方法对比"><a href="#各个查找方法对比" class="headerlink" title="各个查找方法对比"></a>各个查找方法对比</h3><p><a href="http://oa5ova13h.bkt.clouddn.com/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.PNG" target="_blank" rel="external">对比图</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/24/linux-vbird-chapter-10/" itemprop="url">
                  《鸟哥的私房菜》读书笔记-第十章、vim 程序编辑器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-24T08:26:13+08:00" content="2016-11-24">
              2016-11-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/24/linux-vbird-chapter-10/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/24/linux-vbird-chapter-10/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-vi-与-vim"><a href="#1-vi-与-vim" class="headerlink" title="1. vi 与 vim"></a>1. vi 与 vim</h4><h5 id="1-1-为何要学-vim"><a href="#1-1-为何要学-vim" class="headerlink" title="1.1 为何要学 vim"></a>1.1 为何要学 vim</h5><pre><code>*  所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在；
* 很多个别软件的编辑接口都会 ***主动呼叫 vi*** (例如未来会谈到的 crontab, visudo, edquota 等指令)；
* vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计；
</code></pre><p>因为程序简单，编辑速度相当快速。</p>
<h4 id="2-vi-的使用"><a href="#2-vi-的使用" class="headerlink" title="2. vi 的使用"></a>2. vi 的使用</h4><h5 id="2-1-简易执行范例"><a href="#2-1-简易执行范例" class="headerlink" title="2.1 简易执行范例"></a>2.1 简易执行范例</h5><pre><code>2.2.1 vi [filename]
2.2.2 模式：编辑模式和命令模式之间不能切换
    一般模式：按[i,o,a]切换到编辑模式，按Esc退出
    编辑模式：
    命令模式：
</code></pre><h5 id="2-2-按键说明"><a href="#2-2-按键说明" class="headerlink" title="2.2 按键说明"></a>2.2 按键说明</h5><h6 id="2-2-1-一般模式可用的按钮说明，光标移动、复制贴上、搜寻取代等"><a href="#2-2-1-一般模式可用的按钮说明，光标移动、复制贴上、搜寻取代等" class="headerlink" title="2.2.1 一般模式可用的按钮说明，光标移动、复制贴上、搜寻取代等"></a>2.2.1 一般模式可用的按钮说明，光标移动、复制贴上、搜寻取代等</h6><pre><code>2.2.1.1 移动光标的方法：
    `crtl+f`:下一页[Page Down]
    `crtl+b`：上一页[Page Up]
    `0`：移动到这一行的最前面字符处 [Home]
    `$`：移动到这一行的最后面字符处 [End]
    `gg`：第一行
    `G`：最后一行
    `n&lt;space&gt;`:那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20space 则光标会向后面移动 20 个字符距离。
    `n&lt;Enter&gt;`:n 为数字。光标向下移动 n 行(
    `nG`：到第几行
2.2.1.2 寻找替换：
    `/word`：向下查找word
    `:n1,$n2s/word1/word2/g`： 从n1行到n2行把word1替换成word2
    `:n1,$s/word1/word2/g`： 从第n2行开始到最后一行把word1替换成word2
    `:n1,$s/word1/word2/gc`：    从第n2行开始到最后一行把word1替换成word2,需要confirm确定
2.2.1.3 删除、复制与贴上：
    `x`和`X`：`x`为删除光标后的一个字符，即向后删[delete],`X` 为删除光标前的一个字符,即向前删[backspace]
    `xn`：连续删除n个字符
    `dd`：删除该行
    `ndd`:n 为数字。删除光标所在的向下 n 列（包括该行），例如 20dd     则是删除 20 列 
    `yy`：复制该行
    `nyy`：n为数字，复制光标所在的向下 n 列（包括该行），例如 20yy  则是复制 20 列
    `p`和`P`：p 为将已复制的数据在光标下一行贴上，P    则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了    10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20  行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20    行会被推到变成 30 行。
    `crtl +r`:重做上一个动作
    `u`：撤销
    `.`：重做上一个动作
</code></pre><h6 id="2-2-2-一般模式切换到编辑模式的可用的按钮说明"><a href="#2-2-2-一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="2.2.2 一般模式切换到编辑模式的可用的按钮说明"></a>2.2.2 一般模式切换到编辑模式的可用的按钮说明</h6><pre><code>2.2.2.1 进入插入或取代的编辑模式：
`i, I`：进入插入模式(Insert mode)：
</code></pre><p>i 为『从目前光标所在处插入』， I 为『在目前所在行的第一个非空格符处开始插入』<br>            <code>a, A</code>：进入插入模式(Insert mode)：<br>a 为『从目前光标所在的下一个字符处开始插入』， A 为『从光标所在行的最后一个字符处开始插入』<br>            <code>o, O</code>：进入插入模式(Insert mode)：<br>这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处插入新的一行』； O 为在目前光标所在处的上一行插入新的一行！<br>            <code>r, R</code>：进入取代模式(Replace mode)：<br>r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；</p>
<h6 id="2-2-3-一般模式切换到指令列模式的可用的按钮说明"><a href="#2-2-3-一般模式切换到指令列模式的可用的按钮说明" class="headerlink" title="2.2.3 一般模式切换到指令列模式的可用的按钮说明"></a>2.2.3 一般模式切换到指令列模式的可用的按钮说明</h6><pre><code>2.2.3.1 指令列的储存、离开等指令
    `:w`：将编辑的数据写入硬盘档案中
    `:q`：离开
    `:wq`：储存后离开，若为 :wq! 则为强制储存后离开
2.2.3.2 vim 环境的变更
    `:set nu` ：显示行号
    `:set nonu`:不显示行号
</code></pre><h5 id="2-3-一个案例的练习"><a href="#2-3-一个案例的练习" class="headerlink" title="2.3 一个案例的练习"></a>2.3 一个案例的练习</h5><h5 id="2-4-vim-的暂存档、救援回复与开启时的警告讯息"><a href="#2-4-vim-的暂存档、救援回复与开启时的警告讯息" class="headerlink" title="2.4 vim 的暂存档、救援回复与开启时的警告讯息"></a>2.4 vim 的暂存档、救援回复与开启时的警告讯息</h5><h4 id="3-vim-的额外功能"><a href="#3-vim-的额外功能" class="headerlink" title="3. vim 的额外功能"></a>3. vim 的额外功能</h4><h5 id="3-1-区块选择-Visual-Block"><a href="#3-1-区块选择-Visual-Block" class="headerlink" title="3.1 区块选择(Visual Block)"></a>3.1 区块选择(Visual Block)</h5><pre><code>    `v`：字符选择，会将光标经过的地方反白选择！
    `V`：行选择，会将光标经过的行反白选择！
`[Ctrl]+v`：区块选择，可以用长方形的方式选择资料
    `y`：将反白的地方复制起来
</code></pre><p>d   将反白的地方删除掉</p>
<h5 id="3-2-多档案编辑"><a href="#3-2-多档案编辑" class="headerlink" title="3.2 多档案编辑"></a>3.2 多档案编辑</h5><pre><code>`vim filename1 filename2`
:n  编辑下一个档案
:N  编辑上一个档案
:files  列出目前这个 vim 的开启的所有档案
</code></pre><h5 id="3-3-多窗口功能"><a href="#3-3-多窗口功能" class="headerlink" title="3.3 多窗口功能"></a>3.3 多窗口功能</h5><pre><code>`:sp [filename]`  开启一个新窗口，如果有加 filename， 表示在新窗口开启一个新档案，否则表示两个窗口为同一个档案内容(同步显示)。
`[ctrl]+w+ j`和`[ctrl]+w+↓`  按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j (或向下箭头键)，则光标可移动到下方的窗口。
`[ctrl]+w+ k` 和`[ctrl]+w+↑`同上，不过光标移动到上面的窗口。
`[ctrl]+w+ q` 其实就是 :q 结束离开啦！ 举例来说，如果我想要结束下方的窗口，那么利用 [ctrl]+w+↓ 移动到下方窗口后，按下 :q 即可离开， 也可以按下 [ctrl]+w+q 啊！
</code></pre><h5 id="3-4-vim-环境设定与记录：-vimrc-viminfo"><a href="#3-4-vim-环境设定与记录：-vimrc-viminfo" class="headerlink" title="3.4 vim 环境设定与记录： ~/.vimrc, ~/.viminfo"></a>3.4 vim 环境设定与记录： ~/.vimrc, ~/.viminfo</h5><h5 id="3-5-vim-常用指令示意图"><a href="#3-5-vim-常用指令示意图" class="headerlink" title="3.5 vim 常用指令示意图"></a>3.5 vim 常用指令示意图</h5><h4 id="4-其他-vim-使用注意事项"><a href="#4-其他-vim-使用注意事项" class="headerlink" title="4. 其他 vim 使用注意事项"></a>4. 其他 vim 使用注意事项</h4><h5 id="4-1-中文编码的问题"><a href="#4-1-中文编码的问题" class="headerlink" title="4.1 中文编码的问题"></a>4.1 中文编码的问题</h5><pre><code>LANG= xxx
</code></pre><h5 id="4-2-DOS-与-Linux-的断行字符：-dos2unix-unix2dos"><a href="#4-2-DOS-与-Linux-的断行字符：-dos2unix-unix2dos" class="headerlink" title="4.2 DOS 与 Linux 的断行字符： dos2unix, unix2dos"></a>4.2 DOS 与 Linux 的断行字符： dos2unix, unix2dos</h5><pre><code>而 Linux 的 Enter 为 LF 符号， 不过，由于 DOS 的断行符号是 CRLF ，也就是多了一个 ^M 的符号出来
</code></pre><h5 id="4-3-语系编码转换：-iconv"><a href="#4-3-语系编码转换：-iconv" class="headerlink" title="4.3 语系编码转换： iconv"></a>4.3 语系编码转换： iconv</h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/24/linux-vbird-chapter-7/" itemprop="url">
                  《鸟哥的私房菜》读书笔记-第七章、Linux 文件与目录管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-24T08:26:13+08:00" content="2016-11-24">
              2016-11-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/24/linux-vbird-chapter-7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/24/linux-vbird-chapter-7/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-目录与路径"><a href="#1-目录与路径" class="headerlink" title="1. 目录与路径"></a>1. 目录与路径</h4><h5 id="1-1-相对路径与绝对路径"><a href="#1-1-相对路径与绝对路径" class="headerlink" title="1.1 相对路径与绝对路径"></a>1.1 相对路径与绝对路径</h5><pre><code>相对路径：./
绝对路径: /xx/xx
</code></pre><h5 id="1-2-目录的相关操作：-cd-pwd-mkdir-rmdir"><a href="#1-2-目录的相关操作：-cd-pwd-mkdir-rmdir" class="headerlink" title="1.2 目录的相关操作： cd, pwd, mkdir, rmdir"></a>1.2 目录的相关操作： cd, pwd, mkdir, rmdir</h5><pre><code>cd: change directory
    cd ~ 
    cd ~[username]
    cd - 上个视图的目录
    cd .. 当前目录的父目录
pwd：print working directory
    pwd -P ：显示真正的目录，非连接文件夹的名称
mkdir: make directory
    mkdir -p test1/test2/test3 ：创建test3，当其父目录不存在的时候一并创建
rmdir: remove directory 删除空文件夹
    rmdir xxx 只能删除空文件夹
    rmdir -r xxx 递归删除文件夹里面所有的东西
</code></pre><h5 id="1-3-关於运行档路径的变量：-PATH"><a href="#1-3-关於运行档路径的变量：-PATH" class="headerlink" title="1.3 关於运行档路径的变量： $PATH"></a>1.3 关於运行档路径的变量： $PATH</h5><pre><code>echo $PATH 执行文件所在的文件路径，即环境变量
</code></pre><h4 id="2-文件与目录管理"><a href="#2-文件与目录管理" class="headerlink" title="2. 文件与目录管理"></a>2. 文件与目录管理</h4><h5 id="2-1-文件与目录的检视：-ls"><a href="#2-1-文件与目录的检视：-ls" class="headerlink" title="2.1 文件与目录的检视： ls"></a>2.1 文件与目录的检视： ls</h5><pre><code>ls -l：当前目录的属性和权限
ls -a：显示隐藏文件
ls -d：只显示目录
</code></pre><h5 id="2-2-复制、删除与移动：-cp-rm-mv"><a href="#2-2-复制、删除与移动：-cp-rm-mv" class="headerlink" title="2.2 复制、删除与移动： cp, rm, mv"></a>2.2 复制、删除与移动： cp, rm, mv</h5><pre><code>cp:
    cp -a xxx：相当於 -pdr 的意思
    cp -i xxx：询问，假如目标文件存在
    cp -p xxx:连同文件属性一并复制过去
    cp -r xxx:递归复制，如复制文件夹
rm:
    rm -r xxx：因为该目录或文件『肯定』会被 root 杀掉！
mv: 移动更名
    mv xxx xxx
</code></pre><h5 id="2-3-取得路径的文件名称与目录名称"><a href="#2-3-取得路径的文件名称与目录名称" class="headerlink" title="2.3 取得路径的文件名称与目录名称"></a>2.3 取得路径的文件名称与目录名称</h5><h4 id="3-文件内容查阅："><a href="#3-文件内容查阅：" class="headerlink" title="3. 文件内容查阅："></a>3. 文件内容查阅：</h4><h5 id="3-1-直接检视文件内容：-cat-tac-nl"><a href="#3-1-直接检视文件内容：-cat-tac-nl" class="headerlink" title="3.1 直接检视文件内容： cat, tac, nl"></a>3.1 直接检视文件内容： cat, tac, nl</h5><h5 id="3-2-可翻页检视：-more-less"><a href="#3-2-可翻页检视：-more-less" class="headerlink" title="3.2 可翻页检视： more, less"></a>3.2 可翻页检视： more, less</h5><h5 id="3-3-数据撷取：-head-tail"><a href="#3-3-数据撷取：-head-tail" class="headerlink" title="3.3 数据撷取： head, tail"></a>3.3 数据撷取： head, tail</h5><h5 id="3-4-非纯文字档：-od"><a href="#3-4-非纯文字档：-od" class="headerlink" title="3.4 非纯文字档： od"></a>3.4 非纯文字档： od</h5><h5 id="3-5-修改文件时间与建置新档：-touch"><a href="#3-5-修改文件时间与建置新档：-touch" class="headerlink" title="3.5 修改文件时间与建置新档： touch"></a>3.5 修改文件时间与建置新档： touch</h5><h4 id="4-文件与目录的默认权限与隐藏权限"><a href="#4-文件与目录的默认权限与隐藏权限" class="headerlink" title="4. 文件与目录的默认权限与隐藏权限"></a>4. 文件与目录的默认权限与隐藏权限</h4><h5 id="4-1-文件默认权限：umask"><a href="#4-1-文件默认权限：umask" class="headerlink" title="4.1 文件默认权限：umask"></a>4.1 文件默认权限：umask</h5><h5 id="4-2-文件隐藏属性：-chattr-lsattr"><a href="#4-2-文件隐藏属性：-chattr-lsattr" class="headerlink" title="4.2 文件隐藏属性： chattr, lsattr"></a>4.2 文件隐藏属性： chattr, lsattr</h5><h5 id="4-4-文件特殊权限：SUID-SGID-SBIT-权限配置"><a href="#4-4-文件特殊权限：SUID-SGID-SBIT-权限配置" class="headerlink" title="4.4 文件特殊权限：SUID, SGID, SBIT, 权限配置"></a>4.4 文件特殊权限：SUID, SGID, SBIT, 权限配置</h5><pre><code>SUID： Set UID 替代x，就是说有了s后在运行该程序的时候具有该程序拥有者的权限，就能够通过该程序修改属于改程序拥有者的文件
    SUID 权限仅对二进位程序(binary program)有效；
    运行者对於该程序需要具有 x 的可运行权限；
    本权限仅在运行该程序的过程中有效 (run-time)；
    运行者将具有该程序拥有者 (owner) 的权限。
SGID：与SUID类似只是把运行时拥有该程序所在群组的权限
    对于文件：
        SGID 对二进位程序有用还有目录！！！
        程序运行者对於该程序来说，需具备 x 的权限；
        运行者在运行的过程中将会获得该程序群组的支持
    对于目录：
        使用者若对於此目录具有 r 与 x 的权限时，该使用者能够进入此目录；
        使用者在此目录下的有效群组(effective group)将会变成该目录的群组；
        用途：若使用者在此目录下具有 w 的权限(可以新建文件)                ，则使用者所创建的新文件，该新文件的群组与此目录的群组 ***相同***。
SBIT：Sticky Bit
    当使用者对於此目录具有 w, x 权限，亦即具有写入的权限时；
    当使用者在该目录下创建文件或目录时，***仅有***自己与 root 才有权力删除该文件
权限配置
     4 为 SUID
    2 为 SGID
    1 为 SBIT
</code></pre><h5 id="4-3-观察文件类型：file"><a href="#4-3-观察文件类型：file" class="headerlink" title="4.3 观察文件类型：file"></a>4.3 观察文件类型：file</h5><pre><code>file xxx
</code></pre><h4 id="5-命令与文件的搜寻："><a href="#5-命令与文件的搜寻：" class="headerlink" title="5. 命令与文件的搜寻："></a>5. 命令与文件的搜寻：</h4><h5 id="5-1-命令档名的搜寻：which"><a href="#5-1-命令档名的搜寻：which" class="headerlink" title="5.1 命令档名的搜寻：which"></a>5.1 命令档名的搜寻：which</h5><pre><code>which xxx
</code></pre><h5 id="5-2-文件档名的搜寻：whereis-locate-find"><a href="#5-2-文件档名的搜寻：whereis-locate-find" class="headerlink" title="5.2 文件档名的搜寻：whereis, locate, find"></a>5.2 文件档名的搜寻：whereis, locate, find</h5><pre><code>1. whereis
2. locate
3. find
    find path -user name
    find path -group name
    find path -perm mode 权限刚好
    find path -perm -mode 必须要全部囊括 mode 的权限的文件
    find path -perm +mode 
        搜寻文件权限『包含任一 mode 的权限』的文件，举例来说，我们搜寻
         -rwxr-xr-x ，亦即 -perm +755 时，但一个文件属性为 -rw-------也会被列出来，因为他有 -rw.... 的属性存在！
    find / -perm +7000 -exec ls -l {} \;
        {} 代表的是『由 find 找到的内容』，如上图所示，find 的结果会被放置到 {} 位置中；-exec 一直到 \; 是关键字，代表 find 额外动作的开始 (-exec) 到结束 (\;) ，在这中间的就是 find 命令内的额外动作。 在本例中就是『 ls -l {} 』罗！因为『 ; 』在 bash 环境下是有特殊意义的，因此利用反斜线来跳脱。
</code></pre><h4 id="6-极重要！权限与命令间的关系："><a href="#6-极重要！权限与命令间的关系：" class="headerlink" title="6. 极重要！权限与命令间的关系："></a>6. 极重要！权限与命令间的关系：</h4><pre><code>一、让使用者能进入某目录成为『可工作目录』的基本权限为何：
    可使用的命令：例如 cd 等变换工作目录的命令；
    目录所需权限：使用者对这个目录至少需要具有 x 的权限
    额外需求：如果使用者想要在这个目录内利用 ls 查阅档名，则使用者对此目录还需要 r 的权限。
二、使用者在某个目录内读取一个文件的基本权限为何？
    可使用的命令：例如本章谈到的 cat, more, less等等
    目录所需权限：使用者对这个目录至少需要具有 x 权限；
    文件所需权限：使用者对文件至少需要具有 r 的权限才行！
三、让使用者可以修改一个文件的基本权限为何？
    可使用的命令：例如 nano 或未来要介绍的 vi 编辑器等；
    目录所需权限：使用者在该文件所在的目录至少要有 x 权限；
    文件所需权限：使用者对该文件至少要有 r, w 权限
四、让一个使用者可以创建一个文件的基本权限为何？
    目录所需权限：使用者在该目录要具有 w,x 的权限，重点在 w 啦！
五、让使用者进入某目录并运行该目录下的某个命令之基本权限为何？
    目录所需权限：使用者在该目录至少要有 x 的权限；
    文件所需权限：使用者在该文件至少需要有 x 的权限
</code></pre><p>-a 是and 的意思<br>-o 是or的意思<br>! 条件  是非的意思<br>find / ! -user root 查找非root的文件</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/24/linux-vbird-chapter-6/" itemprop="url">
                  《鸟哥的私房菜》读书笔记-第六章、Linux 的文件权限与目录配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-24T00:17:13+08:00" content="2016-11-24">
              2016-11-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/24/linux-vbird-chapter-6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/24/linux-vbird-chapter-6/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-使用者与群组"><a href="#1-使用者与群组" class="headerlink" title="1. 使用者与群组"></a>1. 使用者与群组</h4><pre><code>1. user，group 和others
</code></pre><h4 id="2-Linux文件权限概念"><a href="#2-Linux文件权限概念" class="headerlink" title="2. Linux文件权限概念"></a>2. Linux文件权限概念</h4><h5 id="2-1-Linux文件属性"><a href="#2-1-Linux文件属性" class="headerlink" title="2.1 Linux文件属性"></a>2.1 Linux文件属性</h5><pre><code>-rwrwx---
d 为目录
- 为文件
l 连结档(link file
b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；
c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。
三个rwx，分别为文件拥有者的权限，同群组的权限，其他非本群组的权限
</code></pre><p>第二组为『同群组的权限』；<br>第三组为『其他非本群组的权限』。</p>
<h5 id="2-2-如何改变文件属性与权限：-chgrp-chown-chmod"><a href="#2-2-如何改变文件属性与权限：-chgrp-chown-chmod" class="headerlink" title="2.2 如何改变文件属性与权限： chgrp, chown, chmod"></a>2.2 如何改变文件属性与权限： chgrp, chown, chmod</h5><pre><code>chgrp: `chgrp 群组 文件` 
chown：`chown 用户 文件`
chmod：`chmod 文件权限 文件名` `chmod 644 test.txt`
chmod   u g o       a +(加入)  -(除去)      =(设定)
        r
        w
        x   文件或目录
        如`chmod  u=rwx,go=rx  .bashrc`、`chmod  a+w  .bashrc`、`chmod  a-x  .bashrc`
</code></pre><h5 id="2-3-目录与文件之权限意义"><a href="#2-3-目录与文件之权限意义" class="headerlink" title="2.3 目录与文件之权限意义"></a>2.3 目录与文件之权限意义</h5><pre><code>对文件：
    r:读取文件内容
    w:修改，编辑，新增但***不包含删除该文件***
    x：跟window根据扩展名判断文件是否执行不同,Linux系统是根据x这个权限来决定文件是否可以被执行
对目录：
    r:具有读取目录结构列表的权限。即可以使用`ls`,但是只看到文件名，要看到文件详细需要`x`,不然只会有问号
    w:建立新文件和新文件夹，删除已存在的文件和文件夹（*无论其权限如何*）,修改文件夹和文件名，移动目录内文件和文件夹的位置。
    要判断用户是否有权限删除一个文件，就 *判断用户对该文件所处的父目录是否有w权限*
    x:用户能否进入该目录成为工作目录
    假如要开放目录给其他人：应该至少也要给予r及x的权限，但w权限不可随便给.
</code></pre><h5 id="2-4-Linux文件种类与扩展名"><a href="#2-4-Linux文件种类与扩展名" class="headerlink" title="2.4 Linux文件种类与扩展名"></a>2.4 Linux文件种类与扩展名</h5><h4 id="3-Linux目录配置"><a href="#3-Linux目录配置" class="headerlink" title="3. Linux目录配置"></a>3. Linux目录配置</h4><h5 id="3-1-Linux目录配置的依据–FHS：-usr-var"><a href="#3-1-Linux目录配置的依据–FHS：-usr-var" class="headerlink" title="3.1 Linux目录配置的依据–FHS：/, /usr, /var"></a>3.1 Linux目录配置的依据–FHS：/, /usr, /var</h5><h5 id="3-2-目录树-directory-tree"><a href="#3-2-目录树-directory-tree" class="headerlink" title="3.2 目录树(directory tree)"></a>3.2 目录树(directory tree)</h5><h5 id="3-3-绝对路径与相对路径"><a href="#3-3-绝对路径与相对路径" class="headerlink" title="3.3 绝对路径与相对路径"></a>3.3 绝对路径与相对路径</h5><h5 id="3-4-CentOS-的观察：-lsb-release"><a href="#3-4-CentOS-的观察：-lsb-release" class="headerlink" title="3.4 CentOS 的观察： lsb_release"></a>3.4 CentOS 的观察： lsb_release</h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/24/linux-vbird-chapter-5/" itemprop="url">
                  《鸟哥的私房菜》读书笔记-第五章、首次登陆与在线求助 man page
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-24T00:16:13+08:00" content="2016-11-24">
              2016-11-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/24/linux-vbird-chapter-5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/24/linux-vbird-chapter-5/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-首次登陆系统"><a href="#1-首次登陆系统" class="headerlink" title="1. 首次登陆系统"></a>1. 首次登陆系统</h4><h5 id="1-1-首次登陆CentOS-5-x图形接口"><a href="#1-1-首次登陆CentOS-5-x图形接口" class="headerlink" title="1.1 首次登陆CentOS 5.x图形接口"></a>1.1 首次登陆CentOS 5.x图形接口</h5><h5 id="1-2-GNOME的操作与注销"><a href="#1-2-GNOME的操作与注销" class="headerlink" title="1.2 GNOME的操作与注销"></a>1.2 GNOME的操作与注销</h5><h5 id="1-3-KDE的操作与注销"><a href="#1-3-KDE的操作与注销" class="headerlink" title="1.3 KDE的操作与注销"></a>1.3 KDE的操作与注销</h5><h5 id="1-4-X-Window与文本模式的切换"><a href="#1-4-X-Window与文本模式的切换" class="headerlink" title="1.4 X Window与文本模式的切换"></a>1.4 X Window与文本模式的切换</h5><h5 id="1-5-在终端界面登陆linux"><a href="#1-5-在终端界面登陆linux" class="headerlink" title="1.5 在终端界面登陆linux"></a>1.5 在终端界面登陆linux</h5><pre><code>至于提示字符方面，在Linux当中，默认root的提示字符为 # ，而一般身份用户的提示字符为 $ 。
</code></pre><h4 id="2-文本模式下命令的下达"><a href="#2-文本模式下命令的下达" class="headerlink" title="2. 文本模式下命令的下达"></a>2. 文本模式下命令的下达</h4><h5 id="2-1-开始下达命令-语系的支持"><a href="#2-1-开始下达命令-语系的支持" class="headerlink" title="2.1 开始下达命令, 语系的支持"></a>2.1 开始下达命令, 语系的支持</h5><pre><code>命令格式：`command [-options] parameter1 parameter2`
大小写区分
使用反斜杠 `(\)` 来替代[Enter]符号达到换行的作用
命令, 选项, 参数等这几个咚咚中间以空格来区分，不论空几格 shell 都视为一格；
</code></pre><h5 id="2-2-基础命令的操作-date-cal-bc"><a href="#2-2-基础命令的操作-date-cal-bc" class="headerlink" title="2.2 基础命令的操作, date, cal, bc"></a>2.2 基础命令的操作, date, cal, bc</h5><h5 id="2-3-重要的几个热键-Tab-ctrl-c-ctrl-d"><a href="#2-3-重要的几个热键-Tab-ctrl-c-ctrl-d" class="headerlink" title="2.3 重要的几个热键[Tab], [ctrl]-c, [ctrl]-d"></a>2.3 重要的几个热键[Tab], [ctrl]-c, [ctrl]-d</h5><pre><code>1. TAB 
    [Tab] 接在一串命令的第一个字的后面，则为命令补全；
    [Tab] 接在一串命令的第二个字以后时，则为『文件补齐』(因为参数有可能是文件)！
2. [Ctrl]-c 按键：停止
3. [Ctrl]-d 按键：相当于输入exit啊
</code></pre><h5 id="2-4-错误信息的查看"><a href="#2-4-错误信息的查看" class="headerlink" title="2.4 错误信息的查看"></a>2.4 错误信息的查看</h5><h4 id="3-Linux系统的在线求助man-page与info-page"><a href="#3-Linux系统的在线求助man-page与info-page" class="headerlink" title="3. Linux系统的在线求助man page与info page"></a>3. Linux系统的在线求助man page与info page</h4><h5 id="3-1-man-page"><a href="#3-1-man-page" class="headerlink" title="3.1 man page"></a>3.1 man page</h5><pre><code>1. man xxx :manual(操作说明)的简写 xxx为命令
2. 『DATE(1)』 ***1，3和8***
        |代号  代表内容|
        |1|           使用者在shell环境中可以操作的命令或可运行文件|
        |2|           系统核心可呼叫的函数与工具等|
        |3|           一些常用的函数(function)与函式库(library)，大部分为C的函式库(libc)|
        |4|           装置文件的说明，通常在/dev下的文件|
        |5|           配置文件或者是某些文件的格式|
        |6|           游戏(games)|
        |7|           惯例与协议等，例如Linux文件系统、网络协议、ASCII code等等的说明|
        |8|           系统管理员可用的管理命令|
        |9|           跟kernel有关的文件|
3. `man -f [命令或者是数据]`  `man -f man`-&gt;`man 1 man`
    左边为该命令的名字和数字
    右边为简易说明
    等于 `whatis [命令或者是数据]`
4. `man -k 命令或者文件关键词` 通过关键词搜索
    等于`apropos [命令或者是数据]`
5. ***记住常见命令，通过man去查找相关说明 再通过`tab`补全去查找相关的命名，再通过man去查看细节。***
</code></pre><h5 id="3-2-info-page"><a href="#3-2-info-page" class="headerlink" title="3.2 info page"></a>3.2 info page</h5><pre><code>File：代表这个info page的数据是来自info.info文件所提供的；
Node：代表目前的这个页面是属于Top节点。意思是info.info内含有很多信息，而Top仅是info.info文件内的一个节点内容而已；
Next：下一个节点的名称为Getting Started，你也可以按『N』到下个节点去；
Up：回到上一层的节点总揽画面，你也可以按下『U』回到上一层；
Prev：前一个节点。但由于Top是info.info的第一个节点，所以上面没有前一个节点的信息。
</code></pre><h5 id="3-3-其他有用的文件-documents"><a href="#3-3-其他有用的文件-documents" class="headerlink" title="3.3 其他有用的文件(documents)"></a>3.3 其他有用的文件(documents)</h5><pre><code>在文字接口下，有任何你不知道的命令或文件格式这种玩意儿，但是你想要了解他，请赶快使用man或者是info来查询！
而如果你想要架设一些其他的服务，或想要利用一整组软件来达成某项功能时，请赶快到/usr/share/doc 底下查一查有没有该服务的说明档喔！
</code></pre><h4 id="4-超简单文书编辑器：-nano"><a href="#4-超简单文书编辑器：-nano" class="headerlink" title="4. 超简单文书编辑器： nano"></a>4. 超简单文书编辑器： nano</h4><pre><code>[ctrl]-G：取得联机帮助(help)，很有用的！
[ctrl]-X：离开naon软件，若有修改过文件会提示是否需要储存喔！
[ctrl]-O：储存文件，若你有权限的话就能够储存文件了；
[ctrl]-R：从其他文件读入数据，可以将某个文件的内容贴在本文件中；
[ctrl]-W：搜寻字符串，这个也是很有帮助的命令喔！
[ctrl]-C：说明目前光标所在处的行数与列数等信息；
[ctrl]-_：可以直接输入行号，让光标快速移动到该行；
[alt]-Y：校正语法功能开启或关闭(单击开、再单击关)
[alt]-M：可以支持鼠标来移动光标的功能
</code></pre><h4 id="5-正确的关机方法-sync-shutdown-reboot-halt-poweroff-init"><a href="#5-正确的关机方法-sync-shutdown-reboot-halt-poweroff-init" class="headerlink" title="5. 正确的关机方法: sync, shutdown, reboot, halt, poweroff, init"></a>5. 正确的关机方法: sync, shutdown, reboot, halt, poweroff, init</h4><pre><code>将数据同步写入硬盘中的命令： sync
惯用的关机命令： shutdown
重新启动，关机： reboot, halt, poweroff
    可以自由选择关机模式：是要关机、重新启动或进入单人操作模式均可；
    可以配置关机时间: 可以配置成现在立刻关机,      也可以配置某一个特定的时间才关机。
    可以自定义关机信息：在关机之前，可以将自己配置的信息传送给在线 user 。
    可以仅发出警告信息：有时有可能你要进行一些测试，而不想让其他的使用者干扰，         或者是明白的告诉使用者某段时间要注意一下！这个时候可以使用 shutdown        来吓一吓使用者，但却不是真的要关机啦！
    可以选择是否要 fsck 检查文件系统 。
    [root@www ~]# /sbin/shutdown [-t 秒] [-arkhncfF] 时间 [警告信息] 
    选项与参数： 
    -t sec ： -t 后面加秒数，亦即『过几秒后关机』的意思 
    -k     ： 不要真的关机，只是发送警告信息出去！ 
    -r     ： 在将系统的服务停掉之后就重新启动(常用) 
    -h     ： 将系统的服务停掉后，立即关机。 (常用) 
    -n     ： 不经过 init 程序，直接以 shutdown 的功能来关机 
    -f     ： 关机并启动之后，强制略过 fsck 的磁盘检查 
    -F     ： 系统重新启动之后，强制进行 fsck 的磁盘检查 
    -c     ： 取消已经在进行的 shutdown 命令内容。 
</code></pre><h4 id="6-启动过程的问题排解"><a href="#6-启动过程的问题排解" class="headerlink" title="6. 启动过程的问题排解"></a>6. 启动过程的问题排解</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/22/linux-vbird-chapter-0/" itemprop="url">
                  《鸟哥的私房菜》读书笔记-第零章：计算机概论
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-22T22:16:13+08:00" content="2016-11-22">
              2016-11-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/22/linux-vbird-chapter-0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/22/linux-vbird-chapter-0/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第零章-计算机概论"><a href="#第零章-计算机概论" class="headerlink" title="第零章 计算机概论"></a>第零章 计算机概论</h3><h4 id="1-計算机：辅助人脑的好工具"><a href="#1-計算机：辅助人脑的好工具" class="headerlink" title="1. 計算机：辅助人脑的好工具"></a>1. 計算机：辅助人脑的好工具</h4><h5 id="1-1-計算机硬件的五大单元"><a href="#1-1-計算机硬件的五大单元" class="headerlink" title="1.1 計算机硬件的五大单元"></a>1.1 計算机硬件的五大单元</h5><pre><code>1. 输入单元：鼠标、触摸板、键盘等
2. 输出单元：显示器、打印机等
3. cpu中的控制单元
4. cpu中的算数逻辑单元
5. 主内存
</code></pre><h5 id="1-2-CPU的种类"><a href="#1-2-CPU的种类" class="headerlink" title="1.2 CPU的种类"></a>1.2 CPU的种类</h5><pre><code>1. 精简指令集（RISC）reduced instruction set computer
    特点：指令简单，运行快，执行效果好。但是复杂需要多个指令完成
    应用：绝大部分手机
2. 复杂指令集（CISC） complex instruction set computer
    特点：每个小指令可以执行一些低阶的硬件操作，指令多且复杂，长度不一
    应用：PC
</code></pre><h5 id="1-3-周边设备"><a href="#1-3-周边设备" class="headerlink" title="1.3 周边设备"></a>1.3 周边设备</h5><h5 id="1-4-运作流程"><a href="#1-4-运作流程" class="headerlink" title="1.4 运作流程"></a>1.4 运作流程</h5><pre><code>1. cpu-大脑
2. 主板-神经网络
3. 各项周边设备-手脚皮肤
4. 显卡：脑袋中的影像
5. 硬盘：大脑的记忆区块。
6. 主内存：与外界交互短暂保存的影像，***硬盘的数据需要转换到主内存中才能被CPU使用***
</code></pre><h5 id="1-5-計算机分类"><a href="#1-5-計算机分类" class="headerlink" title="1.5 計算机分类"></a>1.5 計算机分类</h5><pre><code>* 超级计算机(Supercomputer)
* 大型计算机(Mainframe Computer)
* 迷你计算机(Minicomputer)
* 工作站(Workstation)
* 微计算机(Microcomputer) 又可以称为个人计算机
</code></pre><h5 id="1-6-計算机上面常用的计算单位-容量、速度等"><a href="#1-6-計算机上面常用的计算单位-容量、速度等" class="headerlink" title="1.6 計算机上面常用的计算单位 (容量、速度等)"></a>1.6 計算机上面常用的计算单位 (容量、速度等)</h5><pre><code>1. bit:0/1 的单位我们称为bit
2. byte: 1byte = 8bits
3. 容量单位用二进制
4. 速度单位用十进制：1GHz = 1000 * 1000 * 1000 Hz
5. 带宽：Mbps Mbit per second 每秒多少Mbit。8M带宽=8Mbits/s = 1Mbytes/s上行和下行速度
6. 硬盘用十进位的单位，所以500GByte代表为500*1000*1000*1000Byte之意。 转成档案的容量单位时使用二进位(1024为底)，所以就成为466GB左右的容量了
7. 硬盘的最小物理量为512Bytes，最小的组成单位为磁区(sector)， 通常硬盘容量的计算采用『多少个sector』
</code></pre><h4 id="2-个人计算机架构与周边设备"><a href="#2-个人计算机架构与周边设备" class="headerlink" title="2. 个人计算机架构与周边设备"></a>2. 个人计算机架构与周边设备</h4><h5 id="2-1-CPU：-CPU的外频与倍频-32位与64位-CPU等级"><a href="#2-1-CPU：-CPU的外频与倍频-32位与64位-CPU等级" class="headerlink" title="2.1 CPU： CPU的外频与倍频, 32位与64位, CPU等级"></a>2.1 CPU： CPU的外频与倍频, 32位与64位, CPU等级</h5><pre><code>0. PC的CPU架构：
    * 北桥：负责连结速度较快的CPU、主内存与显示卡等组件；
    * 南桥：负责连接速度较慢的周边介面， 包括硬盘、USB、网络卡等等。
1. 多核是指一颗cpu封装多个运算核心
2. 不同cpu的脚位不同，需要配套相应主板才能使用
3. cpu的性能影响因素：*微指令集* 和 *频率*
CPU频率为3.0GHz， 表示这颗CPU在一秒内可以进行3.0x109次工作
4. 不同的CPU之间不能单纯的以频率来判断运算效能喔！这是因为每颗CPU的微指令集不相同，架构也不见得一样， 每次频率能够进行的工作指令数也不同之故！所以，频率目前仅能用来比较同款CPU的速度！
5. 外频和倍频：外频指的是CPU与外部组件进行数据传输时的速度，倍频则是 CPU 内部用来加速工作效能的一个倍数， 两者相乘才是CPU的频率速度。我们以刚刚Intel Core 2 Duo E8400 CPU来说，他的频率是3.0GHz， 而外频是333MHz，因此倍频就是9倍罗！(3.0G=333Mx9, 其中1G=1000M)
6. 32位和64位：指北桥的系统总线（前端系统总线）的频宽。
7. 我们看到内存与北桥的频宽为12.8GBytes/s，亦即是1600MHz*64bits = 1600MHz*8Bytes = 12800MByes/s = 12.8GBytes/s
8. CPU每次能够处理的数据量称为字长大小(word size)， 字长大小依据CPU的设计而有32位与64位。我们现在所称的计算机是32或64位主要是依据这个 CPU解析的字长大小而来的！
9. 这也导致32位的CPU最多只能支持最大到4GBytes的内存。
</code></pre><h5 id="2-2-內存"><a href="#2-2-內存" class="headerlink" title="2.2 內存"></a>2.2 內存</h5><pre><code>1. 所以，通常越大的内存代表越快速的系统，这是因为系统不用常常释放一些内存内部的数据。 以服务器来说，主内存的容量有时比CPU的速度还要来的重要的！
2. 双通道：由於所有的数据都必须要存放在主内存，所以主内存的***数据宽度***当然是越大越好。 但传统的系统总线宽度一般大约仅达64位，为了要加大这个宽度，因此芯片组厂商就将两个主内存汇整在一起， 如果一支内存可达64位，两支内存就可以达到128位了，这就是双通道的设计理念。
3. CPU频率与主内存的关系：理论上两者的外频应该 ***一致***
4. CPU内部有第二层缓存(L2 cache)：就不需要北桥传输数据了。DRAM不能满足要求，此时就需要静态随机访问内存(Static Random Access Memory, SRAM)。但是其工艺成本高，不易做成大容量。
5. ROM（只读内存）：BIOS(Basic Input Output System)是一套程序，这套程序是写死到主机板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就是只读内存(Read Only Memory, ROM)。
6. 
</code></pre><h5 id="2-3-显卡（VGA-Video-Graphics-Array-）："><a href="#2-3-显卡（VGA-Video-Graphics-Array-）：" class="headerlink" title="2.3 显卡（VGA(Video Graphics Array)）："></a>2.3 显卡（VGA(Video Graphics Array)）：</h5><pre><code>一般对於图形影像的显示重点在於***解析度与色彩深度***，因为每个图像显示的颜色会占用掉内存， 因此显示卡上面会有一个内存的容量，这个显示卡内存容量将会影响到最终你的萤幕解析度与色彩深度的喔！
</code></pre><h5 id="2-4-硬盘与储存设备"><a href="#2-4-硬盘与储存设备" class="headerlink" title="2.4 硬盘与储存设备"></a>2.4 硬盘与储存设备</h5><pre><code>1. 简介：硬盘、软盘、MO、CD、DVD、磁带机、随身碟(快闪内存)、还有新一代的蓝光光驱等， 乃至於大型机器的区域网络储存设备(SAN, NAS)等等，都是可以用来储存数据的。而其中最常见的应该就是硬盘了吧！ 
2. 在硬盘盒里面其实是由许许多多的圆形磁碟盘、机械手臂、 磁碟读取头与主轴马达所组成的
3. 实际运作时， 主轴马达让磁碟盘转动，然后机械手臂可伸展让读取头在磁碟盘上头进行读写的动作。 
4. 整个磁碟盘上头好像有多个同心圆绘制出的圆形图，而由圆心以放射状的方式分割出磁碟的最小储存单位，那就是磁区(Sector)， 在物理组成分面，每个磁区大小为512Bytes，这个值是不会改变的。而磁区组成一个圆就成为磁轨(track)， 如果是在多碟的硬盘上面，在所有磁碟盘上面的同一个磁轨可以组成一个磁柱(Cylinder)， 磁柱也是一般我们分割硬盘时的最小单位了！
</code></pre><h5 id="2-5-PCI介面卡"><a href="#2-5-PCI介面卡" class="headerlink" title="2.5 PCI介面卡"></a>2.5 PCI介面卡</h5><h5 id="2-6-主机板"><a href="#2-6-主机板" class="headerlink" title="2.6 主机板"></a>2.6 主机板</h5><pre><code>CMOS与BIOS： CMOS主要的功能为记录主机板上面的重要参数， 包括系统时间、CPU电压与频率、各项设备的I/O位址与IRQ等，由於这些数据的记录要花费电力，因此主机板上面才有电池。 BIOS为写入到主机板上某一块 flash 或 EEPROM 的程序，他可以在开机的时候执行，以载入CMOS当中的参数， 并尝试呼叫储存装置中的开机程序，进一步进入操作系统当中。BIOS程序也可以修改CMOS中的数据， 每种主机板呼叫BIOS设定程序的按键都不同，一般桌上型计算机常见的是使用[del]按键进入BIOS设定画面。
</code></pre><h5 id="2-7-电源供应器"><a href="#2-7-电源供应器" class="headerlink" title="2.7 电源供应器"></a>2.7 电源供应器</h5><h5 id="2-8-选购须知"><a href="#2-8-选购须知" class="headerlink" title="2.8 选购须知"></a>2.8 选购须知</h5><h4 id="3-数据表示方式"><a href="#3-数据表示方式" class="headerlink" title="3. 数据表示方式"></a>3. 数据表示方式</h4><h5 id="3-1-数字系统"><a href="#3-1-数字系统" class="headerlink" title="3.1 数字系统"></a>3.1 数字系统</h5><pre><code>1. 使用二进制。
</code></pre><h5 id="3-2-文字编码系统"><a href="#3-2-文字编码系统" class="headerlink" title="3.2 文字编码系统"></a>3.2 文字编码系统</h5><pre><code>1. 既然计算机都只有记录0/1而已，甚至记录的数据都是使用byte/bit等单位来记录的，那么文字该如何记录啊？ 事实上文字档案也是被记录为0与1而已，而这个档案的内容要被取出来查阅时，必须要经过一个编码系统的处理才行。 所谓的『编码系统』可以想成是一个『字码对照表』
2. 常用的英文编码表为***ASCII系统*** ，这个编码系统中， 每个符号(英文、数字或符号等)都会占用***1bytes***的记录， 因此总共会有28=256种变化。至於中文字当中的编码系统目前最常用的就是big5这个编码表了。 每个中文字会占用2bytes，理论上最多可以有216=65536
3. 由国际组织ISO/IEC跳出来制订了所谓的Unicode编码系统， 我们常常称呼的UTF8或万国码的编码就是这个咚咚。
</code></pre><h4 id="4-软件程序运作"><a href="#4-软件程序运作" class="headerlink" title="4. 软件程序运作"></a>4. 软件程序运作</h4><h5 id="4-1-机器程序与编译程序"><a href="#4-1-机器程序与编译程序" class="headerlink" title="4.1 机器程序与编译程序"></a>4.1 机器程序与编译程序</h5><pre><code>1. 机器码运行的缺点
    需要了解机器语言：机器只认识0与1，因此你必须要学习直接写给机器看的语言！
    需要了解所有硬件的相关功能函数
    程序不具有可携性：每个CPU都有独特的微指令集，同样的，***每个硬件都有其功能函数***。 因此，你为A计算机写的程序，理论上是没有办法在B计算机上面运作的！而且程序码的修改非常困难！ 
    程序具有专一性：因为这样的程序必须要针对硬件功能函数来撰写
2. 高级程序语言编写完成通过编译器编译成机器码，解决了在不同计算机上运行的问题
3. 但是读取数据写入内存，需要分配内存区间并定位，需要重复撰写控制码问题。这就有了操作系统（System Operation）的诞生。
</code></pre><h5 id="4-2-操作系统"><a href="#4-2-操作系统" class="headerlink" title="4.2 操作系统"></a>4.2 操作系统</h5><pre><code>1. 操作系统核心(Kernel)
    1. 定义：操作系统(Operating System, OS)其实也是一组程序， 这组程序的重点在於管理计算机的所有活动以及驱动系统中的所有硬件。
    2. 那么操作系统的功能就是让CPU可以开始判断逻辑与运算数值、 让主内存可以开始载入/读出数据与程序码、让硬盘可以开始被存取、让网络卡可以开始传输数据、 让所有周边可以开始运转等等。总之，硬件的所有动作都必须要透过这个操作系统来达成就是了
    3. 核心程序所放置到内存当中的区块是受保护的！ 并且开机后就一直常驻在内存当中。
2. 系统呼叫(System Call)
    计算机系统主要由硬件构成，然后核心程序主要在管理硬件，提供合理的计算机系统资源分配(包括CPU资源、内存使用资源等等)， 因此只要硬件不同(如x86架构与RISC架构的CPU)，核心就得要进行修改才行。 
3. 在定义上，只要能够让计算机硬件正确无误的运作，那就算是操作系统了。所以说， 操作系统其实就是核心与其提供的介面工具，不过就如同上面讲的，因为最简单的核心缺乏了与使用者沟通的亲和介面， 所以在目前，一般我们提到的『操作系统』都会包含核心与相关的使用者应用软件呢！
4. 基本概念：
    操作系统是参照硬件的规格写成的
    操作系统只是在管理整个硬件资源，包括CPU，内存，输入输出设备
    应用程序都是参考OS提供的开发介面（接口）interface写成的。
5. 核心功能：
    1. 系统呼叫接口 system call interface
    2. 程序管理 process control
    3. 内存管理 memory management
    4. 文件系统管理 filesystem management
    5. 硬件驱动 device driver
6. 驱动程序
    1. 操作系统需要能驱动一个硬件，才能使用它
    2. 一般来说，硬件厂商根据操作系统提供的接口和规范开发驱动程序并提供给消费者。
</code></pre><h5 id="4-3-应用程序"><a href="#4-3-应用程序" class="headerlink" title="4.3 应用程序"></a>4.3 应用程序</h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/headicon.jpg"
               alt="AaronChan" />
          <p class="site-author-name" itemprop="name">AaronChan</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Aaron-Chan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AaronChan</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"aaronchan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  

</body>
</html>
