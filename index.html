<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="AaronChan Blog">
<meta property="og:url" content="https://yoursite.com/index.html">
<meta property="og:site_name" content="AaronChan Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AaronChan Blog">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://yoursite.com/"/>

  <title> AaronChan Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?51f0c6f8829e2634ec8f9bfc8220f514";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">AaronChan Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">陈晓城</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/17/《重构》读书笔记/" itemprop="url">
                  《重构》读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-03-17T08:21:00+08:00" content="2017-03-17">
              2017-03-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/03/17/《重构》读书笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/17/《重构》读书笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="《重构》读书笔记"><a href="#《重构》读书笔记" class="headerlink" title="《重构》读书笔记"></a>《重构》读书笔记</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><p>第一章从实例程序出发，展示设计的缺陷，对其重构可以了解重构的过程和方法。</p>
<h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><p>第二章讨论重构的一般性原则、定义和进行重构的原因。主要讲述概念性的东西。</p>
<h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h4><p>第三章介绍如何嗅出代码的“坏味道”以及如何用重构对其消除。</p>
<h4 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h4><p>第四章讲述构建java的测试环境</p>
<h4 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h4><p>第五章到第十二章介绍作者整理下来重构的方法。</p>
<h4 id="第六部分"><a href="#第六部分" class="headerlink" title="第六部分"></a>第六部分</h4><p>第十三章重构技术在商业化应用中出现的问题</p>
<h3 id="第1章-重构，第一个案例1"><a href="#第1章-重构，第一个案例1" class="headerlink" title="第1章 重构，第一个案例1"></a>第1章 重构，第一个案例1</h3><h4 id="1-1-起点1"><a href="#1-1-起点1" class="headerlink" title="1.1 起点1"></a>1.1 起点1</h4><p>如果发现需要为程序添加新特性，而代码结构使你无法很方便的达到目的，那就需要先进行重构，然后使新特性的添加容易进行，再添加新特性。</p>
<h4 id="1-2-重构的第一步7"><a href="#1-2-重构的第一步7" class="headerlink" title="1.2 重构的第一步7"></a>1.2 重构的第一步7</h4><p>首先检查自己是否有一套可靠的测试机制。这些测试必须有自我检测的能力。因为重构有可能引入bug。</p>
<h4 id="1-3-分解并重组statement-8"><a href="#1-3-分解并重组statement-8" class="headerlink" title="1.3 分解并重组statement()8"></a>1.3 分解并重组statement()8</h4><p>重构技术就是以 <strong><em>微小的步伐</em></strong>修改程序，如果发现错误，很容易可以发现它。<br>优秀的程序员应该写出人类容易理解的代码，而非仅仅是计算机能理解的代码。</p>
<ul>
<li>搬移金额计算代码（Move Method）</li>
<li>去除不必要的临时变量（Replace Temp with Query）</li>
<li>提炼常客积分计算（Move Method）</li>
<li>Move Method 如果一个方法运用目标对象的属性进行计算，那么请把这个方法抽象到目标对象的类中。<h4 id="1-4-运用多态取代与价格相关的条件逻辑34"><a href="#1-4-运用多态取代与价格相关的条件逻辑34" class="headerlink" title="1.4 运用多态取代与价格相关的条件逻辑34"></a>1.4 运用多态取代与价格相关的条件逻辑34</h4></li>
<li>最好不要在另一个对象的属性基础上运用switch语句。如果不得不使用，也应该在对象自己的数据上使用，而不是别人的数据上。</li>
<li>当一个类需要运用多态的时候，但是假如其在生命周期内有可能变成另一个同胞类，那么就应该使用state设计模式来解决这个问题。<h4 id="1-5-结语52"><a href="#1-5-结语52" class="headerlink" title="1.5 结语52"></a>1.5 结语52</h4></li>
</ul>
<h3 id="第2章-重构原则53"><a href="#第2章-重构原则53" class="headerlink" title="第2章 重构原则53"></a>第2章 重构原则53</h3><h4 id="2-1-何谓重构53"><a href="#2-1-何谓重构53" class="headerlink" title="2.1 何谓重构53"></a>2.1 何谓重构53</h4><ul>
<li>名词含义：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高理解性和降低修改成本。</li>
<li>动词含义<br>使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</li>
<li>重构让软件更容易理解和修改</li>
<li>重构不会改变软件的可观察行为，即使改变也只能是微小的影响，软件功能一如既往。</li>
<li>两顶 <strong><em>帽子</em></strong>（时间分配）<ul>
<li>添加新功能：不应该修改已有代码，只关注新功能。增加新测试，通过测试衡量工作进度</li>
<li>重构：只改变程序内部结构，不应该添加测试（存在遗漏），不修改测试（除非接口发生变化）</li>
<li>软件开发在这两者之间切换</li>
</ul>
</li>
</ul>
<h4 id="2-2-为何重构55"><a href="#2-2-为何重构55" class="headerlink" title="2.2 为何重构55"></a>2.2 为何重构55</h4><ul>
<li><p>改进软件设计：</p>
<ul>
<li>程序的设计在没有重构的情况下逐渐腐败变质，功能的增加或者修改可能使代码越来越难以理解，就越难保护其中的设计</li>
<li>消除重复的代码一方面是程序运行更快，一方面是方便未来的修改，只用在一处修改即可不用修改多处。</li>
</ul>
</li>
<li><p>软件更容易理解：</p>
<ul>
<li>及时填补“想要它做什么”和“告诉它做什么”之间的缝隙。重构的核心就是要“准确说出我所要的”</li>
<li>重新阅读代码的人有可能是自己，他人。</li>
<li>通过重构可以把不熟悉的代码的用途理一遍，加深对代码的理解</li>
</ul>
</li>
<li>帮助找出bug：这个是建立在代码容易理解之上的</li>
<li>提高编程速度：重构达到良好的设计，而良好的设计更容易修改，增加功能，调试。</li>
</ul>
<h4 id="2-3-何时重构57"><a href="#2-3-何时重构57" class="headerlink" title="2.3 何时重构57"></a>2.3 何时重构57</h4><ul>
<li>三次法则：第一次的时候做某事尽管去做。第二次的时候对它产生反感，还是继续去做。第三次再做类似的时候，就应该重构了。</li>
<li>添加功能时重构：一方面可能是需要理解需要修改的代码，另一方面是使增加新特性更加容易。</li>
<li>修补错误时重构：出现bug的时候，难以找出问题所在的时候，很有可能是代码不清晰导致查找bug的困难。</li>
<li>复审代码时重构：<ul>
<li>复审代码有助于知识的传播，有利于代码被编写者之外的人理解。</li>
<li>重构是有利于增强复审代码的能力，重构需要先阅读代码得到一定程度的理解，得到一些建议，然后动手实现。所以重构有利于知道合理的代码应当是怎么样的。</li>
<li>复审团队需要精炼，就 <strong><em>一个审查者和一个原作者</em></strong>。较大的项目可以通过 <strong><em>UML图</em></strong>去展示代码的逻辑。</li>
</ul>
</li>
<li>程序难以相与的原因：<ul>
<li>难以阅读的程序，难以修改</li>
<li>逻辑重复的程序，难以修改</li>
<li>添加新特性需要修改已有代码的程序，难以修改</li>
<li>带复杂逻辑判断的程序，难以修改</li>
</ul>
</li>
<li>对应的期望：<ul>
<li>容易阅读</li>
<li>所有逻辑都只有唯一地点指定</li>
<li>新的改动不会危及现有行为</li>
<li>尽可能简单表达逻辑</li>
</ul>
</li>
</ul>
<h4 id="2-4-怎么对经理说60"><a href="#2-4-怎么对经理说60" class="headerlink" title="2.4 怎么对经理说60"></a>2.4 怎么对经理说60</h4><ul>
<li>不要告诉经理：经理是进度驱动，就是要求开发者尽快完成任务。而对于我来说最快完成任务的方式就是先重构。</li>
<li>很多时候重构都为程序引入间接层。把大型对象拆分成小对象，把大型函数拆分为小型函数。<ul>
<li>允许逻辑共享：一个函数在不同地点被调用。子类共享超类的方法。</li>
<li>分开解释意图和实现：通过类名和函数名解释自己的意图</li>
<li>隔离变化：在不同地方使用同一个对象，需要修改一处逻辑，那么可以做出子类，并在需要的时候修改这个子类。</li>
<li>封装条件逻辑：运用多态。将条件逻辑转化为消息模式。</li>
</ul>
</li>
<li>减少间接层:当间接层只在一处使用，那么需要将其消除。</li>
</ul>
<h4 id="2-5-重构的难题62"><a href="#2-5-重构的难题62" class="headerlink" title="2.5 重构的难题62"></a>2.5 重构的难题62</h4><ul>
<li>数据库：<ul>
<li>程序与数据库耦合在一起。另一方面是数据迁移，是向繁琐的事项。</li>
<li>在非关系型数据库，可以在数据库和对象模型中插入一个分离层，隔离两者之间的变化</li>
</ul>
</li>
<li>修改接口<ul>
<li>对于已经发布的接口需要可能需要维护旧接口和新接口，用deprecated修饰旧接口。</li>
<li>不发布新接口，在旧接口中调用新接口。</li>
<li>假如新接口抛出编译时异常，那么可以在旧接口中调用新接口并将编译时异常转化为运行时异常。</li>
</ul>
</li>
<li>何时不重构<ul>
<li>重构之前，代码必须能够在大部分情况下 <em>正常运行</em>，不然就不应该重构，而应该是 <strong><em>重写</em></strong>。</li>
<li>到了Deadline，应该避免重构。</li>
</ul>
</li>
</ul>
<h4 id="2-6-重构与设计66"><a href="#2-6-重构与设计66" class="headerlink" title="2.6 重构与设计66"></a>2.6 重构与设计66</h4><ul>
<li>重构与设计是彼此互补的。</li>
<li>预先设计是必须，预先设计不可能做到完全正确，随着对问题的逐渐深入，通过重构可以改善程序的质量。</li>
<li>重构减轻了设计的难度和压力，在程序不断修改的过程逐步完善程序的设计。</li>
</ul>
<h4 id="2-7-重构与性能69"><a href="#2-7-重构与性能69" class="headerlink" title="2.7 重构与性能69"></a>2.7 重构与性能69</h4><ul>
<li>重构是有可能导致程序运行变慢的。</li>
<li>除了对实时有严格要求的程序，编写快速软件的秘诀是：<strong><em>首先写出可调的程序，然后调整它以达到足够的速度</em></strong>。</li>
<li>经过分析大部分程序的大半部分时间是运行在一小半代码上，所以对所有代码一视同仁是错误的。 </li>
<li>性能优化放在开发的后期，通过分析工具找出消耗大量时间空间的地方，然后集中精力优化这些地方。</li>
</ul>
<h4 id="2-8-重构起源何处71"><a href="#2-8-重构起源何处71" class="headerlink" title="2.8 重构起源何处71"></a>2.8 重构起源何处71</h4><h3 id="第3章-代码的坏味道75"><a href="#第3章-代码的坏味道75" class="headerlink" title="第3章 代码的坏味道75"></a>第3章 代码的坏味道75</h3><h4 id="3-1-DuplicatedCode（重复代码）76"><a href="#3-1-DuplicatedCode（重复代码）76" class="headerlink" title="3.1 DuplicatedCode（重复代码）76"></a>3.1 DuplicatedCode（重复代码）76</h4><ul>
<li>同个类两个函数存在相同表达式：ExtractMethod（提炼函数）</li>
<li>互为兄弟类内存在相同表达式：<ul>
<li>ExtractMethod-》PullUpMethod（函数上移）</li>
<li>如果代码只是相似：先运用ExtractMethod（提炼函数）分开再Form TemPlate Method（塑造模板函数）</li>
</ul>
</li>
<li>两个毫不相干的类存在重复代码：ExtractClass（提炼类）</li>
</ul>
<h4 id="3-2-LongMethod（过长函数）76"><a href="#3-2-LongMethod（过长函数）76" class="headerlink" title="3.2 LongMethod（过长函数）76"></a>3.2 LongMethod（过长函数）76</h4><ul>
<li>原则：每当感觉需要以注释来说明什么的时候，我就将需要说明的代码放到一个独立的函数里面</li>
<li>只要函数名称能够 <strong><em>解释用途</em></strong>，我们就应该毫不犹豫地做。</li>
<li>关键不在函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。</li>
<li>具体情况<ul>
<li>函数有大量参数和临时变量：ExtractMethod（提炼函数）</li>
<li>用ReplaceTempwithQuery（以查询取代临时变量）消除临时变量</li>
<li>用IntroduceParameterObject（引入参数对象）或者PreserveWholeObject（保持对象完整）来将多长的参数列表变得简洁一点。</li>
<li>如果按照上述步骤还存在太多变量和参数就需要用到ReplaceMethodwithMethodObject（以函数对象取代函数）</li>
<li>条件表达式可以用DecomposeConditional（分解条件表达式）解决</li>
<li>可以将循环内的代码提炼为函数。</li>
</ul>
</li>
</ul>
<h4 id="3-3-LargeClass（过大的类）78"><a href="#3-3-LargeClass（过大的类）78" class="headerlink" title="3.3 LargeClass（过大的类）78"></a>3.3 LargeClass（过大的类）78</h4><ul>
<li>有时候类并非在所有时刻都使用实例变量：使用ExtractMethod和ExtractSubclass（提炼子类）</li>
<li>类中有太多代码：ExtractClass（提炼类）ExtractSubclass（提炼子类），甚至可以使用提炼接口的方式分解类的行为。</li>
<li>存在GUI的时候，可以DuplicateObservedData（复制“被监视数据”），分离数据和行为到领域模型中去。</li>
</ul>
<h4 id="3-4-LongParameterList（过长参数列）78"><a href="#3-4-LongParameterList（过长参数列）78" class="headerlink" title="3.4 LongParameterList（过长参数列）78"></a>3.4 LongParameterList（过长参数列）78</h4><ul>
<li>如果可以调用已有对象获取的话可以使用ReplaceParameterwithMethods（以函数取代参数）</li>
<li>将来自同一对象的数据收集起来，以该对象替代：PreserveWholeObject（保持对象完整）</li>
<li>如果几个参数总是同时出现，那么可以考虑IntroduceParameterObject（引入参数对象）</li>
</ul>
<h4 id="3-5-DivergentChange（发散式变化）79"><a href="#3-5-DivergentChange（发散式变化）79" class="headerlink" title="3.5 DivergentChange（发散式变化）79"></a>3.5 DivergentChange（发散式变化）79</h4><ul>
<li>一个类受多种变化影响：加上一个功能需要修改类中多个函数</li>
<li>目标是每个对象都可以只因一种变化而需要修改</li>
<li>方法：可以将提炼类来达到。</li>
</ul>
<h4 id="3-6-ShotgunSurgery（霰弹式修改）80"><a href="#3-6-ShotgunSurgery（霰弹式修改）80" class="headerlink" title="3.6 ShotgunSurgery（霰弹式修改）80"></a>3.6 ShotgunSurgery（霰弹式修改）80</h4><ul>
<li>遇到某种变化，需要在许多不同类做小修改。</li>
<li>可以通过移动函数、移动字段、内联类把一种变化一系列变化放到同一个类中。</li>
<li>对比：DivergentChange（发散式变化）是一个类受多个变化影响；ShotgunSurgery（霰弹式修改）是一个变化引起多个类相应修改。</li>
</ul>
<h4 id="3-7-FeatureEnvy（依恋情结）80"><a href="#3-7-FeatureEnvy（依恋情结）80" class="headerlink" title="3.7 FeatureEnvy（依恋情结）80"></a>3.7 FeatureEnvy（依恋情结）80</h4><ul>
<li>函数对某个类的兴趣高过对自己类的兴趣</li>
<li>通过移动函数放到该合适的位置。</li>
</ul>
<h4 id="3-8-DataClumps（数据泥团）81"><a href="#3-8-DataClumps（数据泥团）81" class="headerlink" title="3.8 DataClumps（数据泥团）81"></a>3.8 DataClumps（数据泥团）81</h4><ul>
<li>数据项总是成群结队出现</li>
<li>判断方法：删除众多数据项的一项，这么做其他数据是否失去意义。如果不再有意义就需要提炼为参数对象。</li>
</ul>
<h4 id="3-9-PrimitiveObsession（基本类型偏执）81"><a href="#3-9-PrimitiveObsession（基本类型偏执）81" class="headerlink" title="3.9 PrimitiveObsession（基本类型偏执）81"></a>3.9 PrimitiveObsession（基本类型偏执）81</h4><ul>
<li>有些字段可以用对象表示更准确ReplaceDataValuewithObject（以对象取代数据值）</li>
<li>对于不影响行为的类型码可以ReplaceTypeCodewithClass（以类取代类型码）</li>
<li>影响行为的类型码可以ReplaceTypeCodewithSubclasses（以子类取代类型码），类型码在运行时会变化就用ReplaceTypeCodewithState/Strategy（以State/Strategy取代类型码）</li>
</ul>
<h4 id="3-10-SwitchStatements（switch惊悚现身）82"><a href="#3-10-SwitchStatements（switch惊悚现身）82" class="headerlink" title="3.10 SwitchStatements（switch惊悚现身）82"></a>3.10 SwitchStatements（switch惊悚现身）82</h4><ul>
<li>使用ReplaceTypeCodewithSubclasses（以子类取代类型码）或者ReplaceTypeCodewithState/Strategy（以State/Strategy取代类型码）</li>
<li>轻量级的解决方法：ReplaceParameterwithExplicitMethods（以明确函数取代参数）</li>
</ul>
<h4 id="3-11-ParallelInheritanceHierarchies（平行继承体系）83"><a href="#3-11-ParallelInheritanceHierarchies（平行继承体系）83" class="headerlink" title="3.11 ParallelInheritanceHierarchies（平行继承体系）83"></a>3.11 ParallelInheritanceHierarchies（平行继承体系）83</h4><ul>
<li>每当为一个类增加子类必须也为另外一个类增加一个子类</li>
<li>策略是让一个继承体系的实例引用另一个继承体系的实例。</li>
</ul>
<h4 id="3-12-LazyClass（冗赘类）83"><a href="#3-12-LazyClass（冗赘类）83" class="headerlink" title="3.12 LazyClass（冗赘类）83"></a>3.12 LazyClass（冗赘类）83</h4><ul>
<li>内联类或者Collapse Hierarchy（折叠继承体系）来解决</li>
</ul>
<h4 id="3-13-SpeculativeGenerality（夸夸其谈未来性）83"><a href="#3-13-SpeculativeGenerality（夸夸其谈未来性）83" class="headerlink" title="3.13 SpeculativeGenerality（夸夸其谈未来性）83"></a>3.13 SpeculativeGenerality（夸夸其谈未来性）83</h4><ul>
<li>内联类或者Collapse Hierarchy（折叠继承体系）来解决</li>
<li>函数参数没被用上RemoveParameter（移除参数）</li>
<li>函数名称过于抽象RenameMethod（函数改名）</li>
</ul>
<h4 id="3-14-TemporaryField（令人迷惑的暂时字段）84"><a href="#3-14-TemporaryField（令人迷惑的暂时字段）84" class="headerlink" title="3.14 TemporaryField（令人迷惑的暂时字段）84"></a>3.14 TemporaryField（令人迷惑的暂时字段）84</h4><ul>
<li>对象中某个字段仅为特定情况而设。</li>
<li>提炼类来解决</li>
</ul>
<h4 id="3-15-MessageChains（过度耦合的消息链）84"><a href="#3-15-MessageChains（过度耦合的消息链）84" class="headerlink" title="3.15 MessageChains（过度耦合的消息链）84"></a>3.15 MessageChains（过度耦合的消息链）84</h4><ul>
<li>获取一个对象，再通过该对象获取另外一个对象进行操作：HideDelegate（隐藏“委托关系”）</li>
</ul>
<h4 id="3-16-MiddleMan（中间人）85"><a href="#3-16-MiddleMan（中间人）85" class="headerlink" title="3.16 MiddleMan（中间人）85"></a>3.16 MiddleMan（中间人）85</h4><ul>
<li>过度委托形成中间人:RemoveMiddleMan（移除中间人）</li>
<li>如果中间人还有其他行为,Replace Delegation with Inherited（以继承取代委托）</li>
</ul>
<h4 id="3-17-InappropriateIntimacy（狎昵关系）85"><a href="#3-17-InappropriateIntimacy（狎昵关系）85" class="headerlink" title="3.17 InappropriateIntimacy（狎昵关系）85"></a>3.17 InappropriateIntimacy（狎昵关系）85</h4><ul>
<li>两个类过于亲密，花费太多时间去探究彼此private成分</li>
<li>移动字段和移动方法减少狎昵</li>
<li>ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）</li>
<li>如果两个类实在情投意合：可以使用ExtractClass（提炼类）,让他们使用新类进行交互。</li>
</ul>
<h4 id="3-18-AlternativeClasseswithDifferentInterfaces（异曲同工的类）85"><a href="#3-18-AlternativeClasseswithDifferentInterfaces（异曲同工的类）85" class="headerlink" title="3.18 AlternativeClasseswithDifferentInterfaces（异曲同工的类）85"></a>3.18 AlternativeClasseswithDifferentInterfaces（异曲同工的类）85</h4><ul>
<li>两个函数做了相同的事情却有不同的签名</li>
</ul>
<h4 id="3-19-IncompleteLibraryClass（不完美的库类）86"><a href="#3-19-IncompleteLibraryClass（不完美的库类）86" class="headerlink" title="3.19 IncompleteLibraryClass（不完美的库类）86"></a>3.19 IncompleteLibraryClass（不完美的库类）86</h4><ul>
<li>库函数不够好，需要加入一些操作，其实类似于 <strong><em>适配</em></strong>IntroduceForeignMethod（引入外加函数）</li>
<li>如果需要加入大量的操作，IntroduceLocalExtension（引入本地扩展）</li>
</ul>
<h4 id="3-20-DataClass（纯稚的数据类）86"><a href="#3-20-DataClass（纯稚的数据类）86" class="headerlink" title="3.20 DataClass（纯稚的数据类）86"></a>3.20 DataClass（纯稚的数据类）86</h4><ul>
<li>类只有数据没有行为，其他类存在对该类的数据进行取值设值操作</li>
<li>有public字段：EncapsulateField（封装字段）</li>
<li>对于不该被其他类修改的字段:RemoveSettingMethod（移除设值函数）</li>
</ul>
<h4 id="3-21-RefusedBequest（被拒绝的遗赠）87"><a href="#3-21-RefusedBequest（被拒绝的遗赠）87" class="headerlink" title="3.21 RefusedBequest（被拒绝的遗赠）87"></a>3.21 RefusedBequest（被拒绝的遗赠）87</h4><ul>
<li>如果类不想得到另一个类全部东西，只对部分感兴趣。</li>
<li>可以使用Replace inherited with Delegation（以委托取代继承）来处理</li>
</ul>
<h4 id="3-22-Comments（过多的注释）87"><a href="#3-22-Comments（过多的注释）87" class="headerlink" title="3.22 Comments（过多的注释）87"></a>3.22 Comments（过多的注释）87</h4><ul>
<li>试试提炼方法来解决注释过多问题</li>
</ul>
<h3 id="第4章-构筑测试体系89"><a href="#第4章-构筑测试体系89" class="headerlink" title="第4章 构筑测试体系89"></a>第4章 构筑测试体系89</h3><h4 id="4-1-自测试代码的价值89"><a href="#4-1-自测试代码的价值89" class="headerlink" title="4.1 自测试代码的价值89"></a>4.1 自测试代码的价值89</h4><h4 id="4-2-JUnit测试框架91"><a href="#4-2-JUnit测试框架91" class="headerlink" title="4.2 JUnit测试框架91"></a>4.2 JUnit测试框架91</h4><h4 id="4-3-添加更多测试97"><a href="#4-3-添加更多测试97" class="headerlink" title="4.3 添加更多测试97"></a>4.3 添加更多测试97</h4><h3 id="第5章-重构列表103"><a href="#第5章-重构列表103" class="headerlink" title="第5章 重构列表103"></a>第5章 重构列表103</h3><h4 id="5-1-重构的记录格式103"><a href="#5-1-重构的记录格式103" class="headerlink" title="5.1 重构的记录格式103"></a>5.1 重构的记录格式103</h4><h4 id="5-2-寻找引用点105"><a href="#5-2-寻找引用点105" class="headerlink" title="5.2 寻找引用点105"></a>5.2 寻找引用点105</h4><h4 id="5-3-这些重构手法有多成熟106"><a href="#5-3-这些重构手法有多成熟106" class="headerlink" title="5.3 这些重构手法有多成熟106"></a>5.3 这些重构手法有多成熟106</h4><h3 id="第6章-重新组织函数109"><a href="#第6章-重新组织函数109" class="headerlink" title="第6章 重新组织函数109"></a>第6章 重新组织函数109</h3><h4 id="6-1-ExtractMethod（提炼函数）110"><a href="#6-1-ExtractMethod（提炼函数）110" class="headerlink" title="6.1 ExtractMethod（提炼函数）110"></a>6.1 ExtractMethod（提炼函数）110</h4><ul>
<li>无局部变量：直接抽取方法</li>
<li>含有局部变量<ul>
<li>局部变量只在提炼代码块内被读取值：将局部变量作为方法参数</li>
<li>局部变量在提炼代码块内被赋值：1只在提炼代码内被使用-&gt;将局部变量提炼到新该方法内;2在提炼代码块后-&gt;使用就返回局部变量修改后的值</li>
</ul>
</li>
</ul>
<h4 id="6-2-InlineMethod（内联函数）117"><a href="#6-2-InlineMethod（内联函数）117" class="headerlink" title="6.2 InlineMethod（内联函数）117"></a>6.2 InlineMethod（内联函数）117</h4><ul>
<li>当函数的名称与其本体都一眼清晰明了，在函数调用点插入函数本体，移除该函数。</li>
<li>有一群不甚合理的函数，可以先内联到大型函数然后再提炼出合理的小函数</li>
</ul>
<h4 id="6-3-InlineTemp（内联临时变量）119"><a href="#6-3-InlineTemp（内联临时变量）119" class="headerlink" title="6.3 InlineTemp（内联临时变量）119"></a>6.3 InlineTemp（内联临时变量）119</h4><ul>
<li>当临时变量只是被一个简单表达式赋值一次，而它妨碍其他重构方法</li>
<li>方法：将所有对该变量的引用动作替代成对它赋值的表达式本身。</li>
<li>情形：<ul>
<li>InlineTemp多半是为ReplaceTempwithQuery（以查询取代临时变量）准备</li>
<li>临时变量被一次赋值后，临时变量作为函数的返回值。</li>
</ul>
</li>
</ul>
<h4 id="6-4-ReplaceTempwithQuery（以查询取代临时变量）120"><a href="#6-4-ReplaceTempwithQuery（以查询取代临时变量）120" class="headerlink" title="6.4 ReplaceTempwithQuery（以查询取代临时变量）120"></a>6.4 ReplaceTempwithQuery（以查询取代临时变量）120</h4><ul>
<li>情况：你的程序以一个临时变量保存一个表达式的计算结果</li>
<li>做法：将表达式提炼出独立的函数，然后临时变量的调用替换成新函数的调用。此后新函数也能被调用。</li>
<li>具体做法：<ul>
<li>将提炼出来的函数用private修饰</li>
<li>如果独立函数有副作用，那对它进行SeparateQueryfromModifier（将查询函数和修改函数分离）</li>
</ul>
</li>
</ul>
<h4 id="6-5-IntroduceExplainingVariable（引入解释性变量）124"><a href="#6-5-IntroduceExplainingVariable（引入解释性变量）124" class="headerlink" title="6.5 IntroduceExplainingVariable（引入解释性变量）124"></a>6.5 IntroduceExplainingVariable（引入解释性变量）124</h4><ul>
<li>将复杂表达式的结果赋值给一个临时变量，用临时变量名称来解释表达式的用途</li>
</ul>
<h4 id="6-6-SplitTemporaryVariable（分解临时变量）128"><a href="#6-6-SplitTemporaryVariable（分解临时变量）128" class="headerlink" title="6.6 SplitTemporaryVariable（分解临时变量）128"></a>6.6 SplitTemporaryVariable（分解临时变量）128</h4><ul>
<li>临时变量被赋值超过一次，但是既不是 <em>循环变量</em>也不是被用于 <em>收集计算结果</em></li>
<li>原因：一个变量应该承担一个责任，如果被赋值多次很可能承担了多个责任</li>
<li>做法：针对每次赋值，创建新的临时变量</li>
</ul>
<h4 id="6-7-RemoveAssignmentstoParameters（移除对参数的赋值）131"><a href="#6-7-RemoveAssignmentstoParameters（移除对参数的赋值）131" class="headerlink" title="6.7 RemoveAssignmentstoParameters（移除对参数的赋值）131"></a>6.7 RemoveAssignmentstoParameters（移除对参数的赋值）131</h4><ul>
<li>java是值传递，对参数的任何修改都不会再调用端造成影响，所以对于 <strong><em>用过引用传递的人可能会发生理解错误</em></strong></li>
<li>参数应该仅表示“被传递过来的东西”</li>
</ul>
<h4 id="6-8-ReplaceMethodwithMethodObject（以函数对象取代函数）135"><a href="#6-8-ReplaceMethodwithMethodObject（以函数对象取代函数）135" class="headerlink" title="6.8 ReplaceMethodwithMethodObject（以函数对象取代函数）135"></a>6.8 ReplaceMethodwithMethodObject（以函数对象取代函数）135</h4><ul>
<li>情形：在大型函数内，对局部变量的使用导致难以使用ExtractMethod（提炼函数）进行重构</li>
<li>做法：将这个函数放入一个对象里，局部变量变成对象成员变量，然后可以在同一对象中将这个大型函数分解为多个小型函数。</li>
<li>原因：局部变量会增加分解函数的困难度</li>
</ul>
<h4 id="6-9-SubstituteAlgorithm（替换算法）139"><a href="#6-9-SubstituteAlgorithm（替换算法）139" class="headerlink" title="6.9 SubstituteAlgorithm（替换算法）139"></a>6.9 SubstituteAlgorithm（替换算法）139</h4><ul>
<li>把某个算法替换成更清晰的做法（算法）（有点废话）。</li>
</ul>
<h3 id="第7章-在对象之间搬移特性141"><a href="#第7章-在对象之间搬移特性141" class="headerlink" title="第7章 在对象之间搬移特性141"></a>第7章 在对象之间搬移特性141</h3><h4 id="7-1-MoveMethod（搬移函数）142"><a href="#7-1-MoveMethod（搬移函数）142" class="headerlink" title="7.1 MoveMethod（搬移函数）142"></a>7.1 MoveMethod（搬移函数）142</h4><ul>
<li>情形：程序中有个函数与所驻类之外的另一个类进行更多交流，调用后者或者后者调用该函数</li>
<li>做法：在该函数最常引用的类中定义相似行为的新接口，将旧函数变成委托函数或者将旧函数删除。</li>
<li>具体做法：<ul>
<li>检查源类中被源函数使用的一切特性，如果特性被其他函数使用，考虑这些函数一起搬移</li>
<li>检查源类的子类和超类，看看是否有该函数的声明，如果出现，很可能不能搬移。</li>
<li>目标类需要使用源类的特性：1将该特性转移到目标类；2建立目标类到源类之间引用。3将源类作为参数传给目标类4将该特性作为参数传给目标类</li>
<li>如果源函数包含 <em>异常处理</em>，需要考虑是在目标类还是源函数处理</li>
</ul>
</li>
</ul>
<h4 id="7-2-MoveField（搬移字段）146"><a href="#7-2-MoveField（搬移字段）146" class="headerlink" title="7.2 MoveField（搬移字段）146"></a>7.2 MoveField（搬移字段）146</h4><ul>
<li>情形：程序中有个字段与所驻类之外被另一个类使用（包括设置取值函数的间接调用），后者调用该字段</li>
<li>做法：将该字段搬移到目标类</li>
<li>具体做法：建立从“旧类访问新类”的连接关系，除非真正需要 <strong><em>不要建立从“新类到旧类”的关系</em></strong></li>
</ul>
<h4 id="7-3-ExtractClass（提炼类）149"><a href="#7-3-ExtractClass（提炼类）149" class="headerlink" title="7.3 ExtractClass（提炼类）149"></a>7.3 ExtractClass（提炼类）149</h4><ul>
<li>情形：一个类做了两个类的事</li>
<li>做法：建立新类，将相应的字段和函数放到新类</li>
</ul>
<h4 id="7-4-InlineClass（将类内联化）154"><a href="#7-4-InlineClass（将类内联化）154" class="headerlink" title="7.4 InlineClass（将类内联化）154"></a>7.4 InlineClass（将类内联化）154</h4><ul>
<li>情形：某个类没做太多的事情，与ExtractClass（提炼类）相反</li>
<li>做法：将这个类的所有特性搬移到另一类中，移除该类。</li>
<li>判断依据：当一个类不再承担足够责任</li>
</ul>
<h4 id="7-5-HideDelegate（隐藏“委托关系”）157"><a href="#7-5-HideDelegate（隐藏“委托关系”）157" class="headerlink" title="7.5 HideDelegate（隐藏“委托关系”）157"></a>7.5 HideDelegate（隐藏“委托关系”）157</h4><ul>
<li>情形：客户端通过委托类来调用另一个对象</li>
<li>做法：在服务类上建立客户端所需的函数，然后隐藏委托关系</li>
<li>依据：符合“封装”的特性。当委托类发生变化不会对客户端造成影响</li>
</ul>
<h4 id="7-6-RemoveMiddleMan（移除中间人）160"><a href="#7-6-RemoveMiddleMan（移除中间人）160" class="headerlink" title="7.6 RemoveMiddleMan（移除中间人）160"></a>7.6 RemoveMiddleMan（移除中间人）160</h4><ul>
<li>情形：某个类做了过多的委托动作</li>
<li>做法：让客户端直接调用委托类</li>
<li>依据：当原委托类的特性越来越多，服务类的委托函数将越来越长，需要让客户端直接调用，避免服务类沦为中间人。</li>
</ul>
<h4 id="7-7-IntroduceForeignMethod（引入外加函数）162"><a href="#7-7-IntroduceForeignMethod（引入外加函数）162" class="headerlink" title="7.7 IntroduceForeignMethod（引入外加函数）162"></a>7.7 IntroduceForeignMethod（引入外加函数）162</h4><ul>
<li>情形：需要为服务类某个函数增加功能，但是不能修改该类</li>
<li>做法：新建函数并将服务类的对象实例作为参数传入。</li>
<li>具体情形：如果需要为服务类增加 <strong><em>大量的方法</em></strong>，请考虑使用IntroduceLocalExtension（引入本地扩展）</li>
</ul>
<h4 id="7-8-IntroduceLocalExtension（引入本地扩展）164"><a href="#7-8-IntroduceLocalExtension（引入本地扩展）164" class="headerlink" title="7.8 IntroduceLocalExtension（引入本地扩展）164"></a>7.8 IntroduceLocalExtension（引入本地扩展）164</h4><ul>
<li>情形：需要为服务类某个函数增加函数，但是不能修改该类</li>
<li>做法：建立新类，使它包括这些额外函数，让这个扩展类作为服务类的子类或者包装类。</li>
<li>具体情况：如果需要对数据进行修改要波及服务类对象，那么使用包装类的方式。如果不需要，使用子类化的方式</li>
</ul>
<h3 id="第8章-重新组织数据169"><a href="#第8章-重新组织数据169" class="headerlink" title="第8章 重新组织数据169"></a>第8章 重新组织数据169</h3><h4 id="8-1-SelfEncapsulateField（自封装字段）171"><a href="#8-1-SelfEncapsulateField（自封装字段）171" class="headerlink" title="8.1 SelfEncapsulateField（自封装字段）171"></a>8.1 SelfEncapsulateField（自封装字段）171</h4><ul>
<li>情形：直接访问一个字段，但是字段之间的耦合关系逐渐变得笨拙。</li>
<li>做法：自封装就是在对于类内部的字段也封装一个设值取值的函数。</li>
<li>争论：字段访问方式是直接访问还是间接访问一致争论不断</li>
<li>间接访问的好处<ul>
<li>修改获取数据的途径；</li>
<li>支持更灵活的数据管理；如延迟加载（需要用到才加载）等。</li>
</ul>
</li>
<li>直接访问的好处<ul>
<li>容易阅读代码，不会需要转换一下这个函数是取值函数。</li>
</ul>
</li>
</ul>
<h4 id="8-2-ReplaceDataValuewithObject（以对象取代数据值）175"><a href="#8-2-ReplaceDataValuewithObject（以对象取代数据值）175" class="headerlink" title="8.2 ReplaceDataValuewithObject（以对象取代数据值）175"></a>8.2 ReplaceDataValuewithObject（以对象取代数据值）175</h4><ul>
<li>情形：假如一个数据项需要与其他数据一起使用才有意义。</li>
<li>做法：将数据变成对象。</li>
</ul>
<h4 id="8-3-ChangeValuetoReference（将值对象改为引用对象）179"><a href="#8-3-ChangeValuetoReference（将值对象改为引用对象）179" class="headerlink" title="8.3 ChangeValuetoReference（将值对象改为引用对象）179"></a>8.3 ChangeValuetoReference（将值对象改为引用对象）179</h4><ul>
<li>情形：从一个类衍生出彼此相似的对象的实例，希望把它们替换为同一个对象，ps:方便统一修改</li>
<li>做法：将值对象变成引用对象</li>
<li>区别：<ul>
<li>引用对象每个都对应现实中一个对象(==)</li>
<li>值对象只关心其值是否相等。（重写equals()和hashcode()方法）</li>
</ul>
</li>
<li>具体做法：<ul>
<li>需要使用工厂模式来创建对象</li>
<li>需要一个类（或者是自身）用字典或者静态表来保存对象</li>
<li>决定对象是预先创建还是动态创建</li>
</ul>
</li>
</ul>
<h4 id="8-4-ChangeReferencetoValue（将引用对象改为值对象）183"><a href="#8-4-ChangeReferencetoValue（将引用对象改为值对象）183" class="headerlink" title="8.4 ChangeReferencetoValue（将引用对象改为值对象）183"></a>8.4 ChangeReferencetoValue（将引用对象改为值对象）183</h4><ul>
<li>情形：有一个引用对象且 <strong><em>很小</em></strong>（创建太多值对象内存消耗大） <strong><em>不可变</em></strong>（无需修改对象），那么应该将其转换为值对象</li>
<li>具体做法：<ul>
<li>查看是否是不可变对象或者可修改成不可变对象</li>
<li>重写hashCode和equals()方法</li>
<li>取消使用工厂模式和将对象的构造函数设为public</li>
</ul>
</li>
</ul>
<h4 id="8-5-ReplaceArraywithObject（以对象取代数组）186"><a href="#8-5-ReplaceArraywithObject（以对象取代数组）186" class="headerlink" title="8.5 ReplaceArraywithObject（以对象取代数组）186"></a>8.5 ReplaceArraywithObject（以对象取代数组）186</h4><ul>
<li>情形：如果数据存储了不相似的数据，元素代表不同的东西。</li>
<li>做法：将数组变成对象，数组的每个元素用字段表示</li>
</ul>
<h4 id="8-6-DuplicateObservedData（复制“被监视数据”）189"><a href="#8-6-DuplicateObservedData（复制“被监视数据”）189" class="headerlink" title="8.6 DuplicateObservedData（复制“被监视数据”）189"></a>8.6 DuplicateObservedData（复制“被监视数据”）189</h4><ul>
<li>情形： 有领域数据置身于GUI控件中，而领域函数需要访问这些数据</li>
<li>做法：将该数据复制到领域模型中。建立Observer模式，同步UI和领域模型的数据。</li>
</ul>
<h4 id="8-7-ChangeUnidirectionalAssociationtoBidirectional（将单向关联改为双向关联）197"><a href="#8-7-ChangeUnidirectionalAssociationtoBidirectional（将单向关联改为双向关联）197" class="headerlink" title="8.7 ChangeUnidirectionalAssociationtoBidirectional（将单向关联改为双向关联）197"></a>8.7 ChangeUnidirectionalAssociationtoBidirectional（将单向关联改为双向关联）197</h4><ul>
<li>情形：被引用类需要得到引用类做一些处理</li>
<li>具体做法：<ul>
<li>两者是一对多关系，有单一引用承担控制关联关系责任</li>
<li>如果某个对象（Task）是另一个对象（Project）的组件，由后者负责控制。</li>
<li>如果两者之间都是多对多关系，那么由谁负责都没关系</li>
</ul>
</li>
</ul>
<h4 id="8-8-ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）200"><a href="#8-8-ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）200" class="headerlink" title="8.8 ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）200"></a>8.8 ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）200</h4><ul>
<li>情形：两个类有双向关联，但是一个类不关心另一个类的特性</li>
<li>做法：去除双向关联</li>
<li>原因：<ul>
<li>双向关联可能造成僵尸对象，不能被清除释放内存。</li>
<li>使两个类存在耦合关系，一个类的变化会导致另一类的变化。</li>
</ul>
</li>
</ul>
<h4 id="8-9-ReplaceMagicNumberwithSymbolicConstant（以字面常量取代魔法数）204"><a href="#8-9-ReplaceMagicNumberwithSymbolicConstant（以字面常量取代魔法数）204" class="headerlink" title="8.9 ReplaceMagicNumberwithSymbolicConstant（以字面常量取代魔法数）204"></a>8.9 ReplaceMagicNumberwithSymbolicConstant（以字面常量取代魔法数）204</h4><ul>
<li>情形：有一个字面常量（除了0和1之外）</li>
<li>做法：创建常量赋值以该字面常量，给予命名。</li>
</ul>
<h4 id="8-10-EncapsulateField（封装字段）206"><a href="#8-10-EncapsulateField（封装字段）206" class="headerlink" title="8.10 EncapsulateField（封装字段）206"></a>8.10 EncapsulateField（封装字段）206</h4><ul>
<li>情形：一个类有public字段</li>
<li>将它声明为private，并提供相应的访问函数</li>
</ul>
<h4 id="8-11-EncapsulateCollection（封装集合）208"><a href="#8-11-EncapsulateCollection（封装集合）208" class="headerlink" title="8.11 EncapsulateCollection（封装集合）208"></a>8.11 EncapsulateCollection（封装集合）208</h4><ul>
<li>情形：有函数返回集合</li>
<li>做法：让该函数返回只读副本，并在该类提供增加和删除集合元素的函数</li>
<li>具体做法：不应该提供集合的设值函数</li>
</ul>
<h4 id="8-12-ReplaceRecordwithDataClass（以数据类取代记录）217"><a href="#8-12-ReplaceRecordwithDataClass（以数据类取代记录）217" class="headerlink" title="8.12 ReplaceRecordwithDataClass（以数据类取代记录）217"></a>8.12 ReplaceRecordwithDataClass（以数据类取代记录）217</h4><ul>
<li>情形：面对传统编程环境的记录数据</li>
<li>做法：为该记录创建一个“哑”数据对象。</li>
</ul>
<h4 id="8-13-ReplaceTypeCodewithClass（以类取代类型码）218"><a href="#8-13-ReplaceTypeCodewithClass（以类取代类型码）218" class="headerlink" title="8.13 ReplaceTypeCodewithClass（以类取代类型码）218"></a>8.13 ReplaceTypeCodewithClass（以类取代类型码）218</h4><ul>
<li>情形：类中有个数值型类型码，不影响类的行为</li>
<li>做法：以一个新类替代类型码</li>
</ul>
<h4 id="8-14-ReplaceTypeCodewithSubclasses（以子类取代类型码）223"><a href="#8-14-ReplaceTypeCodewithSubclasses（以子类取代类型码）223" class="headerlink" title="8.14 ReplaceTypeCodewithSubclasses（以子类取代类型码）223"></a>8.14 ReplaceTypeCodewithSubclasses（以子类取代类型码）223</h4><ul>
<li>情形：有一个不可变的类型码且影响类的行为</li>
<li>做法：以子类取代这个类型码</li>
</ul>
<h4 id="8-15-ReplaceTypeCodewithState-Strategy（以State-Strategy取代类型码）227"><a href="#8-15-ReplaceTypeCodewithState-Strategy（以State-Strategy取代类型码）227" class="headerlink" title="8.15 ReplaceTypeCodewithState/Strategy（以State/Strategy取代类型码）227"></a>8.15 ReplaceTypeCodewithState/Strategy（以State/Strategy取代类型码）227</h4><ul>
<li>情形：有一个类型码且影响类的行为，但是无法通过继承消除（类型码可变化）</li>
<li>做法：以状态对象取代。</li>
</ul>
<h4 id="8-16-ReplaceSubclasswithFields（以字段取代子类）232"><a href="#8-16-ReplaceSubclasswithFields（以字段取代子类）232" class="headerlink" title="8.16 ReplaceSubclasswithFields（以字段取代子类）232"></a>8.16 ReplaceSubclasswithFields（以字段取代子类）232</h4><ul>
<li>情形：各个子类唯一区别只在“返回常量的数据”的函数上</li>
<li>做法：修改这些函数使它们返回超类的某个（新增）字段，然后销毁子类。</li>
</ul>
<h3 id="第9章-简化条件表达式237"><a href="#第9章-简化条件表达式237" class="headerlink" title="第9章 简化条件表达式237"></a>第9章 简化条件表达式237</h3><h4 id="9-1-DecomposeConditional（分解条件表达式）238"><a href="#9-1-DecomposeConditional（分解条件表达式）238" class="headerlink" title="9.1 DecomposeConditional（分解条件表达式）238"></a>9.1 DecomposeConditional（分解条件表达式）238</h4><ul>
<li>情形：if-then-else语句，不同分支做不同事情形成大型函数，本身就难以阅读，尤其在带有复杂条件的逻辑中。</li>
<li>做法：<ul>
<li>将if语句提炼为函数</li>
<li>将then和else段落提炼为函数</li>
<li>存在 <strong><em>嵌套</em></strong>，先判断是否可以用ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）消除。不行再分解每个条件</li>
</ul>
</li>
</ul>
<h4 id="9-2-ConsolidateConditionalExpression（合并条件表达式）240"><a href="#9-2-ConsolidateConditionalExpression（合并条件表达式）240" class="headerlink" title="9.2 ConsolidateConditionalExpression（合并条件表达式）240"></a>9.2 ConsolidateConditionalExpression（合并条件表达式）240</h4><ul>
<li>情形：有一系列条件判断都返回相同结果</li>
<li>做法：将这些测试合并为同一个表达式并将这个表达式提炼为独立函数</li>
<li>原因：<ul>
<li>只是一次检查，只是存在并列条件需要检查而已</li>
<li>为ExtractMethod（提炼函数）做准备，通过 <em>函数名 告知“为什么这么做”</em></li>
</ul>
</li>
<li>特殊情形：条件表达式 <em>存在副作用</em>。</li>
</ul>
<h4 id="9-3-ConsolidateDuplicateConditionalFragments（合并重复的条件片段）243"><a href="#9-3-ConsolidateDuplicateConditionalFragments（合并重复的条件片段）243" class="headerlink" title="9.3 ConsolidateDuplicateConditionalFragments（合并重复的条件片段）243"></a>9.3 ConsolidateDuplicateConditionalFragments（合并重复的条件片段）243</h4><ul>
<li>情形：在条件表达式的分支上有相同的代码</li>
<li>做法：将这段重复代码搬移到条件表达式之外，多行代码可以提炼为独立函数。</li>
<li>当try和catch执行相同代码，可以将代码移到final区段。</li>
</ul>
<h4 id="9-4-RemoveControlFlag（移除控制标记）245"><a href="#9-4-RemoveControlFlag（移除控制标记）245" class="headerlink" title="9.4 RemoveControlFlag（移除控制标记）245"></a>9.4 RemoveControlFlag（移除控制标记）245</h4><ul>
<li>情形：在一系列布尔表达式中，某个变量存在控制标记（control flag）作用。</li>
<li>做法：以break或者continue代替</li>
</ul>
<h4 id="9-5-ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）250"><a href="#9-5-ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）250" class="headerlink" title="9.5 ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）250"></a>9.5 ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）250</h4><ul>
<li>情形：函数中的条件逻辑使人难以看清正确的执行路径。</li>
<li>做法：使用卫语句表现特殊情况</li>
</ul>
<h4 id="9-6-ReplaceConditionalwithPolymorphism（以多态取代条件表达式）255"><a href="#9-6-ReplaceConditionalwithPolymorphism（以多态取代条件表达式）255" class="headerlink" title="9.6 ReplaceConditionalwithPolymorphism（以多态取代条件表达式）255"></a>9.6 ReplaceConditionalwithPolymorphism（以多态取代条件表达式）255</h4><ul>
<li>情形：存在条件表达式根据对象的类型不同选择不同的行为</li>
<li>做法：将表达式分支放进不同子类的重写方法，将原始函数提炼为抽象函数。</li>
</ul>
<h4 id="9-7-IntroduceNullObject（引入Null对象）260"><a href="#9-7-IntroduceNullObject（引入Null对象）260" class="headerlink" title="9.7 IntroduceNullObject（引入Null对象）260"></a>9.7 IntroduceNullObject（引入Null对象）260</h4><ul>
<li>情形：需要再三检查对象是否为null</li>
<li>做法：将null值替代为null对象</li>
</ul>
<h4 id="9-8-IntroduceAssertion（引入断言）267"><a href="#9-8-IntroduceAssertion（引入断言）267" class="headerlink" title="9.8 IntroduceAssertion（引入断言）267"></a>9.8 IntroduceAssertion（引入断言）267</h4><ul>
<li>情形：某段代码需要对程序状态做出某种假设</li>
<li>做法：以断言明确表现这种假设</li>
<li>具体做法：<ul>
<li>断言在 <strong><em>发布</em></strong>的时候统统 <strong><em>被去除</em></strong></li>
<li>断言应该检查 <strong><em>一定必须为真 </em></strong> 的条件</li>
</ul>
</li>
</ul>
<h3 id="第10章-简化函数调用271"><a href="#第10章-简化函数调用271" class="headerlink" title="第10章 简化函数调用271"></a>第10章 简化函数调用271</h3><h4 id="10-1-RenameMethod（函数改名）273"><a href="#10-1-RenameMethod（函数改名）273" class="headerlink" title="10.1 RenameMethod（函数改名）273"></a>10.1 RenameMethod（函数改名）273</h4><ul>
<li>情形：命名不好</li>
<li>做法：<ul>
<li>增加函数，将旧函数代码复制到新函数</li>
<li>修改旧函数，让其转发调用新函数，如果旧函数引用点少可跳过</li>
<li>编译测试</li>
<li>找出旧函数引用，调用新函数</li>
<li>编译测试</li>
<li>删除旧函数</li>
</ul>
</li>
</ul>
<h4 id="10-2-AddParameter（添加参数）275"><a href="#10-2-AddParameter（添加参数）275" class="headerlink" title="10.2 AddParameter（添加参数）275"></a>10.2 AddParameter（添加参数）275</h4><ul>
<li>情形：某个函数需要调用端更多的信息</li>
<li>做法：为此函数添加对象参数，让该对象带进函数所需信息。</li>
<li>其他考虑：<ul>
<li>现有参数是否提供足够的信息？</li>
<li>这个函数是否应该移动到拥有该信息的对象中？</li>
<li>加入新参数是否合适，是否需要使用IntroduceParameterObject（引入参数对象）</li>
</ul>
</li>
</ul>
<h4 id="10-3-RemoveParameter（移除参数）277"><a href="#10-3-RemoveParameter（移除参数）277" class="headerlink" title="10.3 RemoveParameter（移除参数）277"></a>10.3 RemoveParameter（移除参数）277</h4><ul>
<li>情形：函数不需要某个参数</li>
<li>做法：将该参数移除</li>
<li>具体做法同10.1</li>
</ul>
<h4 id="10-4-SeparateQueryfromModifier（将查询函数和修改函数分离）279"><a href="#10-4-SeparateQueryfromModifier（将查询函数和修改函数分离）279" class="headerlink" title="10.4 SeparateQueryfromModifier（将查询函数和修改函数分离）279"></a>10.4 SeparateQueryfromModifier（将查询函数和修改函数分离）279</h4><ul>
<li>情形：某个函数既返回对象状态值，又修改对象状态</li>
<li>做法：建立两个不同的函数，其中一个负责查询，另一个负责修改。</li>
<li>原则：任何一个有返回值的函数都不应该有副作用。</li>
<li>多线程：将修改和查询函数封装在一个同步函数中分开调用。</li>
</ul>
<h4 id="10-5-ParameterizeMethod（令函数携带参数）283"><a href="#10-5-ParameterizeMethod（令函数携带参数）283" class="headerlink" title="10.5 ParameterizeMethod（令函数携带参数）283"></a>10.5 ParameterizeMethod（令函数携带参数）283</h4><ul>
<li>情形：若干个函数做了类似的工作，但在函数本体中却包含了不同的值。</li>
<li>做法：建立单一函数，以参数表达那些不同的值。</li>
<li>要点： <strong><em>可将少量数值视为参数</em></strong></li>
</ul>
<h4 id="10-6-ReplaceParameterwithExplicitMethods（以明确函数取代参数）285"><a href="#10-6-ReplaceParameterwithExplicitMethods（以明确函数取代参数）285" class="headerlink" title="10.6 ReplaceParameterwithExplicitMethods（以明确函数取代参数）285"></a>10.6 ReplaceParameterwithExplicitMethods（以明确函数取代参数）285</h4><ul>
<li>情形：有个函数完全有数值不同采取不同的行为</li>
<li>做法：针对该参数的每个可能值，建立独立函数。</li>
<li>对比：与ParameterizeMethod（令函数携带参数）相反</li>
<li>目的：提供清晰的入口。</li>
<li>如果参数值对函数行为影响不大，不应该采用此方法。</li>
</ul>
<h4 id="10-7-PreserveWholeObject（保持对象完整）288"><a href="#10-7-PreserveWholeObject（保持对象完整）288" class="headerlink" title="10.7 PreserveWholeObject（保持对象完整）288"></a>10.7 PreserveWholeObject（保持对象完整）288</h4><ul>
<li>情形：从某个对象取若干值，把他们作为参数传给函数</li>
<li>做法：改为调用整个对象</li>
<li>目的：避免过长参数</li>
<li>不使用该方法：<ul>
<li>如果函数只依赖那些值不依赖对象，那么不能采用此方法，会导致耦合</li>
<li>有时候函数使用了很多来自对象的数据，那么应该考虑使用（Move Method）</li>
</ul>
</li>
</ul>
<h4 id="10-8-ReplaceParameterwithMethods（以函数取代参数）292"><a href="#10-8-ReplaceParameterwithMethods（以函数取代参数）292" class="headerlink" title="10.8 ReplaceParameterwithMethods（以函数取代参数）292"></a>10.8 ReplaceParameterwithMethods（以函数取代参数）292</h4><ul>
<li>情形：对象调用某个函数，并将所得结果作为参数传递给另一个函数，而接受该参数的函数本身也能够调用前一个函数</li>
<li>做法：让参数接受者去除该项参数，并直接调用前一个函数</li>
</ul>
<h4 id="10-9-IntroduceParameterObject（引入参数对象）295"><a href="#10-9-IntroduceParameterObject（引入参数对象）295" class="headerlink" title="10.9 IntroduceParameterObject（引入参数对象）295"></a>10.9 IntroduceParameterObject（引入参数对象）295</h4><ul>
<li>情形：有些参数总是自然地同时出现</li>
<li>做法：以一个对象取代这些参数</li>
<li>目的：缩短参数长度，函数具有一致性，降低理解和修改代码的难度</li>
</ul>
<h4 id="10-10-RemoveSettingMethod（移除设值函数）300"><a href="#10-10-RemoveSettingMethod（移除设值函数）300" class="headerlink" title="10.10 RemoveSettingMethod（移除设值函数）300"></a>10.10 RemoveSettingMethod（移除设值函数）300</h4><ul>
<li>情形：类的某个字段应该对象创建的时候被设置，然后不再改变</li>
<li>做法：去掉该字段的设置函数</li>
</ul>
<h4 id="10-11-HideMethod（隐藏函数）303"><a href="#10-11-HideMethod（隐藏函数）303" class="headerlink" title="10.11 HideMethod（隐藏函数）303"></a>10.11 HideMethod（隐藏函数）303</h4><ul>
<li>情形：有一个函数，从来没有被任何类调用</li>
<li>做法：将该函数设为private</li>
</ul>
<h4 id="10-12-ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）304"><a href="#10-12-ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）304" class="headerlink" title="10.12 ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）304"></a>10.12 ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）304</h4><ul>
<li>情形：创建对象时不仅仅是做简单的构建动作</li>
<li>做法：将构造函数替换为工厂模式</li>
</ul>
<h4 id="10-13-EncapsulateDowncast（封装向下转型）308"><a href="#10-13-EncapsulateDowncast（封装向下转型）308" class="headerlink" title="10.13 EncapsulateDowncast（封装向下转型）308"></a>10.13 EncapsulateDowncast（封装向下转型）308</h4><ul>
<li>情形：某个函数返回的对象，需要由函数调用者执行向下转型（）downcast</li>
<li>做法：将向下转型移到函数中</li>
</ul>
<h4 id="10-14-ReplaceErrorCodewithException（以异常取代错误码）310"><a href="#10-14-ReplaceErrorCodewithException（以异常取代错误码）310" class="headerlink" title="10.14 ReplaceErrorCodewithException（以异常取代错误码）310"></a>10.14 ReplaceErrorCodewithException（以异常取代错误码）310</h4><ul>
<li>情形：某个函数返回一个特定的代码，表示某个错误的情况</li>
<li>做法：改用异常</li>
</ul>
<h4 id="10-15-ReplaceExceptionwithTest（以测试取代异常）315"><a href="#10-15-ReplaceExceptionwithTest（以测试取代异常）315" class="headerlink" title="10.15 ReplaceExceptionwithTest（以测试取代异常）315"></a>10.15 ReplaceExceptionwithTest（以测试取代异常）315</h4><ul>
<li>情形：面对一个调用者可以预先检查条件，你抛出了一个异常</li>
<li>做法：修改调用者，使它在调用函数之前检查。</li>
</ul>
<h3 id="第11章-处理概括关系319"><a href="#第11章-处理概括关系319" class="headerlink" title="第11章 处理概括关系319"></a>第11章 处理概括关系319</h3><h4 id="11-1-PullUpField（字段上移）320"><a href="#11-1-PullUpField（字段上移）320" class="headerlink" title="11.1 PullUpField（字段上移）320"></a>11.1 PullUpField（字段上移）320</h4><ul>
<li>情形：两个子类拥有相同的字段</li>
<li>做法：将该字段移动到超类，去除重复数据声明和关于数据的重复行为。并堆超类该字段使用-SelfEncapsulateField（自封装字段）</li>
</ul>
<h4 id="11-2-PullUpMethod（函数上移）322"><a href="#11-2-PullUpMethod（函数上移）322" class="headerlink" title="11.2 PullUpMethod（函数上移）322"></a>11.2 PullUpMethod（函数上移）322</h4><ul>
<li>情形：有些函数，在各个子类产生相同的结果。</li>
<li>做法：将该函数移动到超类</li>
</ul>
<h4 id="11-3-PullUpConstructorBody（构造函数本体上移）325"><a href="#11-3-PullUpConstructorBody（构造函数本体上移）325" class="headerlink" title="11.3 PullUpConstructorBody（构造函数本体上移）325"></a>11.3 PullUpConstructorBody（构造函数本体上移）325</h4><ul>
<li>情形：你在各个子类拥有一些构造函数，它们的本地几乎完全一致</li>
<li>做法：在超类新建一个构造函数，并在子类构造函数中调用它。</li>
<li>具体做法：<ul>
<li>将共同代码复制到超类构造函数中</li>
<li>将共同代码放在子类构造函数起始处，然后再复制到超类构造函数中。</li>
<li>将子类构造函数中共同代码删除，改用调用新建的超类构造函数。</li>
</ul>
</li>
</ul>
<h4 id="11-4-PushDownMethod（函数下移）328"><a href="#11-4-PushDownMethod（函数下移）328" class="headerlink" title="11.4 PushDownMethod（函数下移）328"></a>11.4 PushDownMethod（函数下移）328</h4><ul>
<li>情形：超类中的某个函数只与部分而非全部子类有关</li>
<li>做法：将这个函数移到相关的子类去。</li>
</ul>
<h4 id="11-5-PushDownField（字段下移）329"><a href="#11-5-PushDownField（字段下移）329" class="headerlink" title="11.5 PushDownField（字段下移）329"></a>11.5 PushDownField（字段下移）329</h4><ul>
<li>情形：超类中的某个字段只被部分而非全部子类使用</li>
<li>做法：将这个字段移到需要它的那些子类去。</li>
</ul>
<h4 id="11-6-ExtractSubclass（提炼子类）330"><a href="#11-6-ExtractSubclass（提炼子类）330" class="headerlink" title="11.6 ExtractSubclass（提炼子类）330"></a>11.6 ExtractSubclass（提炼子类）330</h4><ul>
<li>情形：类中的某些特性只被某些而非全部实例用到。</li>
<li>做法：新建一个子类，将上面所说的那一部分特性移到子类中。</li>
<li>具体情况：<ul>
<li>并不是出现类型码就表示需要用到子类，可以在委托和继承之间做选择。</li>
<li>为子类新建构造函数，如果需要  <em>隐藏子类</em>，可使用ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）<ul>
<li>找出超类调用点，如超类构造函数与子类不同，通过rename method方法可以解决。</li>
<li>如果不需要超类实例，可以将超类声明为抽象类。</li>
</ul>
</li>
<li>逐一使用字段下移、函数下移将源类的特性移动到子类。</li>
</ul>
</li>
</ul>
<h4 id="11-7-ExtractSuperclass（提炼超类）336"><a href="#11-7-ExtractSuperclass（提炼超类）336" class="headerlink" title="11.7 ExtractSuperclass（提炼超类）336"></a>11.7 ExtractSuperclass（提炼超类）336</h4><ul>
<li>情形：两个类有相似特性。</li>
<li>做法：为两个类建立一个超类，将相同特性移至超类。</li>
</ul>
<h4 id="11-8-Extract-Interface（提炼接口）341"><a href="#11-8-Extract-Interface（提炼接口）341" class="headerlink" title="11.8 Extract Interface（提炼接口）341"></a>11.8 Extract Interface（提炼接口）341</h4><ul>
<li>情形：某组用户只使用类责任区中一个特定子集或者两个类的接口有部分相同。</li>
<li>做法：将相同子集提炼到独立的接口中。</li>
<li>区别：提炼超类是提炼共同代码，提炼接口时提炼共同接口。</li>
<li>具体情形：如果某个类在不同环境下扮演截然不同的角色，使用接口就是个好主意。</li>
</ul>
<h4 id="11-9-Collapse-Hierarchy（折叠继承体系）344"><a href="#11-9-Collapse-Hierarchy（折叠继承体系）344" class="headerlink" title="11.9 Collapse Hierarchy（折叠继承体系）344"></a>11.9 Collapse Hierarchy（折叠继承体系）344</h4><ul>
<li>情形：超类和子类之间区别不大。</li>
<li>做法：将它们合为一体。</li>
</ul>
<h4 id="11-10-Form-TemPlate-Method（塑造模板函数）344"><a href="#11-10-Form-TemPlate-Method（塑造模板函数）344" class="headerlink" title="11.10 Form TemPlate Method（塑造模板函数）344"></a>11.10 Form TemPlate Method（塑造模板函数）344</h4><ul>
<li>情形：你有一些子类，其中相应的函数以相同顺序执行类似的操作，但各个操作的细节有所不同。</li>
<li>做法：将这些小操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也变得相同了。然后将原函数上移至超类，运用多态来避免重复代码。</li>
<li>原因：虽然使用了继承，但是函数重复应尽量避免。</li>
</ul>
<h4 id="11-11-Replace-inherited-with-Delegation（以委托取代继承）352"><a href="#11-11-Replace-inherited-with-Delegation（以委托取代继承）352" class="headerlink" title="11.11 Replace inherited with Delegation（以委托取代继承）352"></a>11.11 Replace inherited with Delegation（以委托取代继承）352</h4><ul>
<li>情形：某个子类只使用超类接口中一部分，或是根本不需要继承而来的数据</li>
<li>做法：在子类中新建一个字段用以保存超类，调整子类函数，令它委托超类，然后去掉两者之间的继承关系。</li>
</ul>
<h4 id="11-12-Replace-Delegation-with-Inherited（以继承取代委托）352"><a href="#11-12-Replace-Delegation-with-Inherited（以继承取代委托）352" class="headerlink" title="11.12 Replace Delegation with Inherited（以继承取代委托）352"></a>11.12 Replace Delegation with Inherited（以继承取代委托）352</h4><ul>
<li>情形：在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数，</li>
<li>做法：让委托类继承受托类。</li>
<li>告诫：<ul>
<li>如果并没有使用受托类的所有函数，那么就不要使用这个方法。因为子类应该总是遵循超类的接口，如果委托过多可以通过移除“中间人”方法让客户端调用受托函数，或者“提炼超类”，让两个类的接口提炼到超类中。类似的还可以使用“提炼接口”方法。</li>
<li>如果受托对象被不止一个其他对象共享，而且受托对象是可变的时候，那么这湿乎乎不能讲委托关系替换为继承关系。</li>
</ul>
</li>
</ul>
<p>……</p>
<h3 id="第12章-大型重构359"><a href="#第12章-大型重构359" class="headerlink" title="第12章 大型重构359"></a>第12章 大型重构359</h3><h3 id="第13章-重构，复用与现实379"><a href="#第13章-重构，复用与现实379" class="headerlink" title="第13章 重构，复用与现实379"></a>第13章 重构，复用与现实379</h3><h3 id="第14章-重构工具401"><a href="#第14章-重构工具401" class="headerlink" title="第14章 重构工具401"></a>第14章 重构工具401</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/15/unit-test-java/" itemprop="url">
                  《单元测试之道Java版》读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-02-15T22:58:00+08:00" content="2017-02-15">
              2017-02-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/02/15/unit-test-java/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/15/unit-test-java/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="单元测试的定义"><a href="#单元测试的定义" class="headerlink" title="单元测试的定义"></a>单元测试的定义</h4><p>来自：<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" title="维基百科" target="_blank" rel="external">维基百科</a></p>
<blockquote>
<p>在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。<br>通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到软件规格书要求的工作目标，没有程序错误；虽然单元测试不是什么必须的，但也不坏，这牵涉到项目管理的政策决定。</p>
</blockquote>
<h4 id="单元测试的内容（Right-BICEP）"><a href="#单元测试的内容（Right-BICEP）" class="headerlink" title="单元测试的内容（Right-BICEP）"></a>单元测试的内容（Right-BICEP）</h4><h5 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h5><ul>
<li>Right：结果是否正确？</li>
<li>B：是否所有边界条件都是正确？</li>
<li>I：能查下反向关联？</li>
<li>C：能用 <strong><em>交叉手段</em></strong>检查一下结果？</li>
<li>E：是否强制错误条件发生（模拟错误发生）</li>
<li>P：是否满足性能要求</li>
</ul>
<h5 id="结果是否正确"><a href="#结果是否正确" class="headerlink" title="结果是否正确"></a>结果是否正确</h5><ol>
<li>验证结果的正确性需要 <strong><em>了解需求</em></strong>,可以通过需求文档来了解；在需求文档不充足或者不完整的情况下，可以站在用户的角度去思考期望的结果是什么。</li>
<li>针对大量测试需要数据文件，在构造 <strong><em>测试数据</em></strong>的时候需要倍加小心</li>
</ol>
<h5 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h5><ol>
<li>举例：<ol>
<li>格式错误的数据（如输入手机号是包含英文字母）</li>
<li>空值或者不完整的数据（如null,””等）</li>
<li>不在预期的合理值范围内（目前没有大于1000岁的人）</li>
<li>事情的到达的次序不一样，可以理解为是前提条件（如未登录就尝试读取用户数据）</li>
</ol>
</li>
<li>总结：<ol>
<li>一致性 Conformance ：值是否与预期一致</li>
<li>顺序性 Ordering ：值是有序还是无序</li>
<li>区间性 Range ：值是否在合理的区间内</li>
<li>依赖性 Reference ：代码是否引用了代码无法控制的外部资源（如数据库）</li>
<li>存在性 Existence ：值是否存在（是否非null，非0，非””）</li>
<li>基数性 Cardinatity ：是否有足够的值</li>
<li>相对或者绝对的时间性 Time ：所有事情是否发生有序？是否在正确时间执行？是否恰好及时？</li>
</ol>
</li>
</ol>
<h5 id="检查反向关联"><a href="#检查反向关联" class="headerlink" title="检查反向关联"></a>检查反向关联</h5><ol>
<li>通过反向的逻辑关系来验证</li>
<li>例子：<ul>
<li>插入数据库，可以通过查询数据库来验证</li>
<li>写入文件，可以通过读取文件内容来验证</li>
</ul>
</li>
</ol>
<h5 id="使用其他手段来交叉检查"><a href="#使用其他手段来交叉检查" class="headerlink" title="使用其他手段来交叉检查"></a>使用其他手段来交叉检查</h5><ol>
<li>交叉检查就是被测试的方法A有与其相同功能但使用了另一套算法的方法B，但由于一些原因（性能不佳）不在项目中使用，利用B来验证A的结果正确性</li>
<li>使用与操作值有约束关系的其他数据来验证：如在图书管理系统中，借出数增加，留存数肯定是下降的</li>
</ol>
<h5 id="强制错误发生条件"><a href="#强制错误发生条件" class="headerlink" title="强制错误发生条件"></a>强制错误发生条件</h5><ol>
<li>主要是人为制作硬件环境或者运行环境的错误</li>
<li>checkList：<ul>
<li>内存耗光</li>
<li>磁盘用满</li>
<li>时钟出问题</li>
<li>网络不可用</li>
<li>系统过载</li>
</ul>
</li>
</ol>
<h5 id="性能特性"><a href="#性能特性" class="headerlink" title="性能特性"></a>性能特性</h5><ol>
<li>不是性能而是性能特性：性能随着规模的增加的变化趋势</li>
</ol>
<h5 id="边界条件详解"><a href="#边界条件详解" class="headerlink" title="边界条件详解"></a>边界条件详解</h5><ol>
<li>一致性：类似于数据的格式是否跟预期一致</li>
<li>有序性：数据是否按照某种特定顺序排序</li>
<li>区间性：<ul>
<li>索引：负 越界等</li>
<li>值的预期区间</li>
</ul>
</li>
<li>依赖性/耦合性：<ul>
<li>前条件：方法运行需要系统处于什么状态</li>
<li>后条件：方法存在任何副作用都需要检查</li>
</ul>
</li>
<li>存在性：给定事物是否存在</li>
<li>基数性：考虑0-1-n三种情况，其中n是随着业务的变化而变化<ul>
<li>例子：订单的前十名：订单少于10个；订单等于10个；订单为0</li>
</ul>
</li>
<li>时间性：<ul>
<li>相对时间（方法执行顺序）</li>
<li>绝对时间（耗时（超时）或者时钟的时间）</li>
<li>并发问题（多线程或者多进程问题）</li>
</ul>
</li>
</ol>
<h4 id="使用MOCK对象"><a href="#使用MOCK对象" class="headerlink" title="使用MOCK对象"></a>使用MOCK对象</h4><h5 id="合适使用MOCK对象"><a href="#合适使用MOCK对象" class="headerlink" title="合适使用MOCK对象"></a>合适使用MOCK对象</h5><ol>
<li>真实对象具有不可确定的行为</li>
<li>真实对象很难被创建</li>
<li>真实对象的某些行为很难触发（如网络错误）</li>
<li>真实对象令程序的运行速度很慢</li>
<li>真实对象有用户界面</li>
<li>测试需要询问真实对象是如何被调用的（验证对象某个函数是否被调用）</li>
<li>真实对象并不存在（需要不同开发小组或者跟新硬件系统打交道）</li>
</ol>
<h5 id="MOCK步骤"><a href="#MOCK步骤" class="headerlink" title="MOCK步骤"></a>MOCK步骤</h5><ol>
<li>使用一个接口来描述一个对象</li>
<li>为产品代码实现这个接口</li>
<li>以测试为目的，在mock对象中实现这个接口</li>
</ol>
<h4 id="好的测试需要具备的品质（A-TRIP）"><a href="#好的测试需要具备的品质（A-TRIP）" class="headerlink" title="好的测试需要具备的品质（A-TRIP）"></a>好的测试需要具备的品质（A-TRIP）</h4><h5 id="自动化（Automatic）"><a href="#自动化（Automatic）" class="headerlink" title="自动化（Automatic）"></a>自动化（Automatic）</h5><ol>
<li>概述：调用测试自动化和检查结果自动化</li>
<li>拓展：持续构建</li>
</ol>
<h5 id="彻底的（Thorough）"><a href="#彻底的（Thorough）" class="headerlink" title="彻底的（Thorough）"></a>彻底的（Thorough）</h5><ol>
<li>取舍：是测试都覆盖全部代码分支还是仅仅测试最可能的情况</li>
<li>通过相关的代码覆盖工具进行检查</li>
</ol>
<h5 id="可重复（Repeatable）"><a href="#可重复（Repeatable）" class="headerlink" title="可重复（Repeatable）"></a>可重复（Repeatable）</h5><ol>
<li>测试必须不随顺序影响或者外部条件变化，每次都出现 <strong><em>相同的结果</em></strong>，也就是说必要时应该Mock来隔离外部因素，使测试能够独立与外部，也就是说测试是运行在 <strong><em>sanbox</em></strong>沙盒里面</li>
</ol>
<h5 id="独立的（Independent）"><a href="#独立的（Independent）" class="headerlink" title="独立的（Independent）"></a>独立的（Independent）</h5><ol>
<li>一个测试函数应该专注于一个目标函数或者组合起来的共同提供某个特性的一组函数</li>
<li>一个测试函数不能依赖与另一个测试函数，也就是不能假定测试函数的执行顺序，因为随着测试数目的增加，这种顺序将变得难以管理。最好是通过setup和teardown来确保每个测试都有一个新的开始。</li>
<li>每个测试函数都是一个 <strong><em>孤岛</em></strong></li>
</ol>
<h5 id="专业的（Professional）"><a href="#专业的（Professional）" class="headerlink" title="专业的（Professional）"></a>专业的（Professional）</h5><ol>
<li>跟编写产品代码一样，一旦发现有代码冗余重复，就应该重构将该功能放到一个函数里面。</li>
<li>保持简洁和精炼，设计要良好且重构充分，<strong><em>对待测试代码应该对待产品代码一样</em></strong></li>
<li>不要为了测试而测试，对于发生可能性很低的错误不要进行测试</li>
<li>自设圈套:让产品产生想要测试的bug，验证测试是否失败</li>
</ol>
<h4 id="项目中进行测试"><a href="#项目中进行测试" class="headerlink" title="项目中进行测试"></a>项目中进行测试</h4><h5 id="测试与评审"><a href="#测试与评审" class="headerlink" title="测试与评审"></a>测试与评审</h5><ol>
<li>编写test case 和/或测试代码</li>
<li>评审test case 和/或测试代码</li>
<li>经评审修改test case 和/或测试代码</li>
<li>编写能通过所有测试的产品代码</li>
<li>评审产品代码和测试代码</li>
<li>在每次评审后，修改测试代码和产品代码</li>
</ol>
<h4 id="设计话题"><a href="#设计话题" class="headerlink" title="设计话题"></a>设计话题</h4><h5 id="面向测试设计"><a href="#面向测试设计" class="headerlink" title="面向测试设计"></a>面向测试设计</h5><ol>
<li>关注点分离，包括：封装性，正交性、耦合性和所有一切编写shycode的计算机科学概念</li>
<li>比如一个函数有多个操作，可以将多个操作分离到各个方法里面这样就可以独立进行测试</li>
</ol>
<h5 id="为测试而重构"><a href="#为测试而重构" class="headerlink" title="为测试而重构"></a>为测试而重构</h5><h5 id="测试类的不变性"><a href="#测试类的不变性" class="headerlink" title="测试类的不变性"></a>测试类的不变性</h5><ol>
<li>跟上述测试的内容有重合的部分，不再赘述</li>
</ol>
<h5 id="测试驱动设计-TDD"><a href="#测试驱动设计-TDD" class="headerlink" title="测试驱动设计 TDD"></a>测试驱动设计 TDD</h5><p>TDD：在编写代码之前先编写测试代码</p>
<p>只是做了简单的介绍；TDD好处在于你把自己当成产品的用户，在这个角度你对代码所提供的接口有了更多的感知，从而做出更好的设计</p>
<h5 id="测试无效参数"><a href="#测试无效参数" class="headerlink" title="测试无效参数"></a>测试无效参数</h5><p>无效参数在哪里检查呢？</p>
<ul>
<li>要是在系统任意部分都做检查，显然会出现重复检查的情况（违反DRY）原则且浪费精力和时间</li>
<li>通常是采用“不让野蛮人入门”的想法，在系统的入口对参数进行检查，然后系统内部就可以信任这些数据了</li>
</ul>
<p>[2]: </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/23/算法-查找/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-23T22:38:59+08:00" content="2016-12-23">
              2016-12-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/23/算法-查找/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/23/算法-查找/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="3-2-二叉查找树"><a href="#3-2-二叉查找树" class="headerlink" title="3.2 二叉查找树"></a>3.2 二叉查找树</h2><ol>
<li>定义：二叉查找树就是一个二叉树。其中每个借点都含有一个compareable的键且每个结点都含有一个左连接和右连接，且每个结点上的都大于左子树上任意结点的键，小于右子树上任意结点的键。</li>
<li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.N = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">       root =  put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Node node, Key key, Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果结点为空 新建结点</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键与结点的键比较</span></span><br><span class="line">        <span class="keyword">int</span> compareTo =key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//大于结点的键，则向右子树加入键</span></span><br><span class="line">            node.right = put(node.right,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//小于结点的键，则向左子树加入键</span></span><br><span class="line">           node.left=  put(node.left,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//相等则替换结点的值</span></span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重新计数</span></span><br><span class="line">        node.N = size(node.left)+<span class="number">1</span>+size(node.right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node== <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 结点为null返回null</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键与结点的键比较</span></span><br><span class="line">        <span class="keyword">int</span> compareTo =key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo &gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> get(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span> )&#123;</span><br><span class="line">           <span class="keyword">return</span>  get(node.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">min</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> min(node.left)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小于等于key的最大key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> floor(node,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">floor</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键与结点的键比较</span></span><br><span class="line">        <span class="keyword">int</span> compare = key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//找到右子树小于等于该键的键</span></span><br><span class="line">            Key rightMin = floor(node.right,key);</span><br><span class="line">            <span class="comment">//没有找到 自己为小于等于该键最大的键</span></span><br><span class="line">            <span class="keyword">if</span>(rightMin == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node.key;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//有则返回该键</span></span><br><span class="line">                <span class="keyword">return</span> rightMin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//从左子树查找</span></span><br><span class="line">           <span class="keyword">return</span>  floor(node.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> rank)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(root,rank);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">select</span><span class="params">(Node node,<span class="keyword">int</span> rank)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size =size(node.left);</span><br><span class="line">        <span class="keyword">if</span>(size&lt; rank)&#123;</span><br><span class="line">            <span class="keyword">return</span> select(node.right,(rank-size-<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size&gt;rank)&#123;</span><br><span class="line">            <span class="keyword">return</span> select(node.left,rank);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">int</span> compareTo =key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo&lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rank(node.left,key));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> size(node.left)+<span class="number">1</span>+rank(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">      root =  deleteMin(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           node.left =  deleteMin(node.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        node.N = size(node.left)+size(node.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">      root =  delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> compareTo = key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.right = delete(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.left = delete(node.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 右树为空 新结点为左子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左子树为空，新节点为右子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">             Node minNode = min(node.right);</span><br><span class="line">            Node t= node;</span><br><span class="line">            node = minNode;</span><br><span class="line">            node.right = deleteMin(t.right);</span><br><span class="line">            node.left = t.left; </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        node.N = size(node.left)+size(node.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys(min(),max());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo ,Key hi)</span></span>&#123;</span><br><span class="line">        Queue&lt;Key&gt; queue = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">         keys(root,queue,lo,hi);</span><br><span class="line">         <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node node,Queue&lt;Key&gt; queue,Key lo ,Key hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> compareLo = lo.compareTo(node.key);</span><br><span class="line">        <span class="keyword">int</span> compareHi = hi.compareTo(node.key);</span><br><span class="line">        <span class="comment">//查左树</span></span><br><span class="line">        <span class="keyword">if</span>(compareLo&lt;<span class="number">0</span> )&#123;</span><br><span class="line">            keys(node.left,lo,hi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结点</span></span><br><span class="line">        <span class="keyword">if</span>(compareHi&gt;=<span class="number">0</span> || compareLo&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">             queue.enqueue(node.key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查右树</span></span><br><span class="line">        <span class="keyword">if</span>(compareHi&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            keys(node.right,lo,hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>3.性能：</p>
<blockquote>
<p>在由N个随机键构成的二叉查找树中，查找命中平均所需的比较次数为~2lnN(约1.39lgN)</p>
<p>在由N个随机键构成的二叉查找树中插入和查找命中未命中的元素平均所需的比较次数为~2lnN(约1.39lgN)</p>
</blockquote>
<h2 id="3-3-平衡查找树"><a href="#3-3-平衡查找树" class="headerlink" title="3.3 平衡查找树"></a>3.3 平衡查找树</h2><h3 id="3-3-1-2-3查找树"><a href="#3-3-1-2-3查找树" class="headerlink" title="3.3.1 2-3查找树"></a>3.3.1 2-3查找树</h3><ol>
<li>定义：一棵2-3查找树或为一棵空疏，或由以下结点组成：<ul>
<li>2-结点：含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向2-3树中的键都大于该结点。</li>
<li>3-结点：含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向2-3树中的键都位于该结点的两个键之间，右链接指向2-3树中的键都大于该结点。</li>
</ul>
</li>
<li>原理：<ul>
<li>向2-结点插入新结点:只要变成3-结点即可</li>
<li>向一棵只含有一个3-结点的树中插入新键：<ul>
<li>变成4-结点，然后中键上移变成由3个2-结点组成的2-3树</li>
</ul>
</li>
<li>向一个父节点为2-结点的3-结点中插入新键<ul>
<li>变成4-结点，然后中键上移父节点变成3-结点</li>
</ul>
</li>
<li>向一个父节点为3-结点的3-结点中插入新键<ul>
<li>变成4-结点，然后中键上移父节点变成4-结点，父节点再逐级向上分解。</li>
</ul>
</li>
</ul>
</li>
<li>性能：</li>
</ol>
<blockquote>
<p>  在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个</p>
</blockquote>
<h3 id="3-3-2-红黑树"><a href="#3-3-2-红黑树" class="headerlink" title="3.3.2 红黑树"></a>3.3.2 红黑树</h3><ol>
<li><p>定义：将树的类型分为两种：红链接将两个2-结点连接起来构成3-结点，黑链接则是2-3树种的普通链接。<br>另外一种定义：</p>
<ul>
<li>红链接都为左链接</li>
<li>没有任意一个结点与两条红链接相连</li>
<li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="keyword">boolean</span> color;</span><br><span class="line">    Key key;</span><br><span class="line">    Value value;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key,Value value,<span class="keyword">boolean</span> color,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.N = N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    Node x = h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    h.N = size(h.left)+<span class="number">1</span>+size(h.right);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    Node x = h.left;</span><br><span class="line">    x.right = h;</span><br><span class="line">    h.left = h.right;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    h.N = size(h.left)+<span class="number">1</span>+size(h.right);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//颜色转换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flipColor</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    h.left.color = BLACK;</span><br><span class="line">    h.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackBST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">   Node root;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">        root.color =BLACK;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.color;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node node,Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,RED,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跟二叉查找树一样</span></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           node.right =  put(node.right,key,value);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                node.left =  put(node.left,key,value);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  node.value = value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右子结点为红链接且左子结点是黑链接-》左旋</span></span><br><span class="line">        <span class="keyword">if</span>(isRed(node.right) &amp;&amp; !isRed(node.left))&#123;</span><br><span class="line">           <span class="keyword">return</span>  rotateLeft(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子结点为红链接且左子结点的左子结点是红链接-》右旋</span></span><br><span class="line">        <span class="keyword">if</span>(isRed(node.left) &amp;&amp; isRed(node.left.left))&#123;</span><br><span class="line">           <span class="keyword">return</span> rotateRight(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子结点为红链接且右子结点是红链接-》颜色转换</span></span><br><span class="line">        <span class="keyword">if</span>(isRed(node.left &amp;&amp; isRed(node.right)))&#123;</span><br><span class="line">            flipColor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.N = size(node.left)+<span class="number">1</span>size(node.right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.性能：</p>
<blockquote>
<p>一棵大小为N的红黑树的高度不会超过2lgN</p>
<p>一棵大小为N的红黑树中，根结点到任意结点的平均路径长度为~1.00lgN。</p>
</blockquote>
<h2 id="3-4-散列表"><a href="#3-4-散列表" class="headerlink" title="3.4 散列表"></a>3.4 散列表</h2><ol>
<li>原理：<ul>
<li>第一步用 <strong><em>散列函数</em></strong>将被查找的键转化为数组的一个索引</li>
<li>第二步处理碰撞冲突（用散列函数生成的索引冲突）<ul>
<li>解决的方法：<strong><em>拉链法</em></strong>   和  <strong><em>碰撞法</em></strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-4-1-散列函数"><a href="#3-4-1-散列函数" class="headerlink" title="3.4.1 散列函数"></a>3.4.1 散列函数</h3><ol>
<li>对于每一种类型的键都需要一个与之对应的散列函数。</li>
<li><p>方法：</p>
<ul>
<li>整型：除留余数法 选择一个素数M；然后键的索引=<code>k%M</code></li>
<li>浮点数：将键编程二进制数然后再使用除留余数法</li>
<li><p>字符串：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.length();i++)&#123;</span><br><span class="line">   hash = (R * hash + s.charAt(i)) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将hashCode()的返回值转化为一个数组索引</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x.hashCode() &amp;&amp; <span class="number">0x7fffffff</span>)%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="3-4-2-基于拉链法的散列表"><a href="#3-4-2-基于拉链法的散列表" class="headerlink" title="3.4.2 基于拉链法的散列表"></a>3.4.2 基于拉链法的散列表</h3><ol>
<li>原理：选择足够大的M，使得所有链表都尽可能短以保证高效的查找。</li>
<li>查找：先根据散列值找到链表。然后沿着链表顺序查找相应的键。</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparteChainingHashST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对的总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;<span class="comment">//散列表的大小</span></span><br><span class="line">    <span class="keyword">private</span> SquenticalSearchST&lt;Key,Value&gt;[] st;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparteChainingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">997</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparteChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        SquenticalSearchST&lt;Key,Value&gt;[] st = <span class="keyword">new</span> (SquenticalSearchST&lt;Key,Value&gt;)SquenticalSearchST[M];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;M; i++)&#123;</span><br><span class="line">            st[i] = <span class="keyword">new</span> SquenticalSearchST();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        st[hash(key)].put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Value)st[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>性质：</p>
<ul>
<li>在一张含有M条链表和N个键的散列表中，任意一条链表中的键的数量均在N/M的常数因子内的概率无限接近于1.</li>
<li>在一张含有M条链表和N个键的散列表中，未命中查找和插入操作所需的比较次数为~N/M;</li>
</ul>
</li>
</ol>
<h3 id="3-4-2-基于线性探测法的散列表"><a href="#3-4-2-基于线性探测法的散列表" class="headerlink" title="3.4.2 基于线性探测法的散列表"></a>3.4.2 基于线性探测法的散列表</h3><ol>
<li>原理：用大小为M的数组保存N个键对。M&gt;N。利用数组中的空位解决碰撞。这种方法统称为 <strong><em>开放地址散列表</em></strong>。（思想：预期将内存用作链表，不如将它们作为在散列表的空元素）</li>
<li>当碰撞发生时，我们直接检查散列表中的下一个位置。有以下三种情况<ul>
<li>命中，该位置的键与被查找的键相同</li>
<li>未命中，该位置的键为空</li>
<li>继续查找，该位置的键与被查找的键不相同</li>
</ul>
</li>
<li>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashSt</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;<span class="comment">//数组大小</span></span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] values;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashSt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        keys = <span class="keyword">new</span> (Key[]) Object[M];</span><br><span class="line">        values = <span class="keyword">new</span> (Value[]) Object[M];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode()&amp;<span class="number">0x7fffffff</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 确保有空位存放元素</span></span><br><span class="line">        <span class="keyword">if</span>(n&gt;M/<span class="number">2</span>)resize(<span class="number">2</span>*M);</span><br><span class="line">        <span class="comment">//假如key[hash] !=null 索引逐渐加1；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hash(key); keys[i]!=<span class="keyword">null</span> ; i = (i+<span class="number">1</span>)%M)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key[i].equals(key))&#123;</span><br><span class="line">                values[i] = value;<span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i] = key;</span><br><span class="line">        values[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hash(key); keys[i]!=<span class="keyword">null</span> ; i = (i+<span class="number">1</span>)%M)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key[i].equals(key))&#123;</span><br><span class="line">               <span class="keyword">return</span> values[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!contains(key))<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = keys[hash(key)];</span><br><span class="line">        <span class="comment">//找到对应的key的索引</span></span><br><span class="line">        <span class="keyword">while</span>(!key.equals(keys[i])  )&#123;</span><br><span class="line">            i = (i+<span class="number">1</span>)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除该索引的键值</span></span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        values[i] = <span class="keyword">null</span>;</span><br><span class="line">        i = (i+<span class="number">1</span>)%M;</span><br><span class="line">        <span class="comment">//先删除再插入</span></span><br><span class="line">        <span class="keyword">while</span>(keys[i]!=<span class="keyword">null</span>)&#123; </span><br><span class="line">            Key keyToRedo = keys[i];</span><br><span class="line">            Value valueToRedo = values[i];</span><br><span class="line">            keys[i] =<span class="keyword">null</span>;</span><br><span class="line">            values[i] =<span class="keyword">null</span>;</span><br><span class="line">             N--;</span><br><span class="line">             put(keyToRedo,valueToRedo);</span><br><span class="line">              i = (i+<span class="number">1</span>)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N&gt;<span class="number">0</span> &amp;&amp; N==M/<span class="number">8</span>)resize(M/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/06/algorithms-find/" itemprop="url">
                  《算法》读书笔记-查找
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-06T23:16:00+08:00" content="2016-12-06">
              2016-12-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/06/algorithms-find/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/06/algorithms-find/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;查找</p>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="3-1-符号表"><a href="#3-1-符号表" class="headerlink" title="3.1 符号表"></a>3.1 符号表</h2><p>&nbsp;&nbsp;</p>
<h3 id="3-1-1-API"><a href="#3-1-1-API" class="headerlink" title="3.1.1 API"></a>3.1.1 API</h3><h3 id="3-1-4-无序链表中的顺序查找"><a href="#3-1-4-无序链表中的顺序查找" class="headerlink" title="3.1.4 无序链表中的顺序查找"></a>3.1.4 无序链表中的顺序查找</h3><ol>
<li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearchST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node first;</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">            Key key;</span><br><span class="line">            Value value;</span><br><span class="line">            Node next;</span><br><span class="line">            Node(Key key,Value value,Node next)&#123;</span><br><span class="line">                <span class="keyword">this</span>.key = key;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">                <span class="keyword">this</span>.next = next;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">            Node node =first;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.key.equals(key))&#123;</span><br><span class="line">                    node.value = value;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            first = <span class="keyword">new</span> Node(key,value,first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">            Node node =first;</span><br><span class="line">            <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.key.equals(key))&#123;</span><br><span class="line">                    <span class="keyword">return</span> node.value;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.性能：</p>
<blockquote>
<p>在含有N对键值的基于链表的符号表中，未命中的查找和插入操作都需要N次比较。命中的查找最坏情况下需要N次比较。特别地，向一个空表中插入N个不同的键需要~N^2次比较</p>
</blockquote>
<h3 id="3-1-5-有序数组中的二分查找"><a href="#3-1-5-有序数组中的二分查找" class="headerlink" title="3.1.5 有序数组中的二分查找"></a>3.1.5 有序数组中的二分查找</h3><ol>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    Key[] keys;</span><br><span class="line">    Value[] values;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchST</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        keys = <span class="keyword">new</span> (Key[]) Comparable[capacity];</span><br><span class="line">        values = <span class="keyword">new</span> (Value[]) Comparable[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小于等于key个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi = keys.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> middle;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">            middle = lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> compare =key.compareTo(keys[middle]);</span><br><span class="line">            <span class="keyword">if</span>(compare&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                lo = middle +<span class="number">1</span>; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compare &lt;<span class="number">0</span>)&#123;</span><br><span class="line">                hi = middle -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rank = rank(key);</span><br><span class="line">        <span class="keyword">if</span>(keys[rank].key.compareTo(key) == <span class="number">0</span>)&#123;</span><br><span class="line">            keys[rank].value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N;i&gt;rank;i--)&#123;</span><br><span class="line">            keys[i] = keys[i-<span class="number">1</span>];</span><br><span class="line">            values[i] = values[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        keys[rank] = key;</span><br><span class="line">        values[rank] = value;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rank = rank(key);</span><br><span class="line">        <span class="keyword">if</span>(rank&lt; N &amp;&amp; keys[rank].compareTo(key)== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> keys[rank].value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">          <span class="keyword">return</span> ;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rank = rank(key);</span><br><span class="line">        <span class="keyword">if</span>(rank&lt; N &amp;&amp; keys[rank].compareTo(key)== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = rank;i&lt;N-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                keys[i] = keys[i+<span class="number">1</span>]; </span><br><span class="line">                values[i] = values[i+<span class="number">1</span>]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[N-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> key <span class="title">select</span><span class="params">(<span class="keyword">int</span> rank)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[rank];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//大于等于key的最大键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> key <span class="title">ceiling</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[rank(key)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小于等于key的最大键</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rank = rank(key);</span><br><span class="line">        <span class="keyword">if</span>(keys[rank].compareTo(key)== <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> keys[rank];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rank == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> keys[rank - <span class="number">1</span>];    </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>性能：</p>
</li>
</ol>
<blockquote>
<p>   在由N个键构成的有序数组中进行二分查找最多需要lgN+1次数比较（无论是否成功）</p>
<p>  在由N个键构成的有序数组中插入一个新的元素在最坏情况下需要访问~2N次数组，因此向一个空符号表中插入N个元素的最坏情况需要访问~N^2次数组</p>
</blockquote>
<h2 id="3-2-二叉查找树"><a href="#3-2-二叉查找树" class="headerlink" title="3.2 二叉查找树"></a>3.2 二叉查找树</h2><ol>
<li>定义：二叉查找树就是一个二叉树。其中每个借点都含有一个compareable的键且每个结点都含有一个左连接和右连接，且每个结点上的都大于左子树上任意结点的键，小于右子树上任意结点的键。</li>
<li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node left;</span><br><span class="line">        Node right;</span><br><span class="line">        <span class="keyword">int</span> N;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key, Value value,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.N = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span></span>&#123;</span><br><span class="line">       root =  put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Node node, Key key, Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果结点为空 新建结点</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键与结点的键比较</span></span><br><span class="line">        <span class="keyword">int</span> compareTo =key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//大于结点的键，则向右子树加入键</span></span><br><span class="line">            node.right = put(node.right,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//小于结点的键，则向左子树加入键</span></span><br><span class="line">           node.left=  put(node.left,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//相等则替换结点的值</span></span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重新计数</span></span><br><span class="line">        node.N = size(node.left)+<span class="number">1</span>+size(node.right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node== <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 结点为null返回null</span></span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键与结点的键比较</span></span><br><span class="line">        <span class="keyword">int</span> compareTo =key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo &gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> get(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span> )&#123;</span><br><span class="line">           <span class="keyword">return</span>  get(node.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">min</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> min(node.left)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小于等于key的最大key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">floor</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> floor(node,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">floor</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键与结点的键比较</span></span><br><span class="line">        <span class="keyword">int</span> compare = key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//找到右子树小于等于该键的键</span></span><br><span class="line">            Key rightMin = floor(node.right,key);</span><br><span class="line">            <span class="comment">//没有找到 自己为小于等于该键最大的键</span></span><br><span class="line">            <span class="keyword">if</span>(rightMin == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node.key;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//有则返回该键</span></span><br><span class="line">                <span class="keyword">return</span> rightMin;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//从左子树查找</span></span><br><span class="line">           <span class="keyword">return</span>  floor(node.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">select</span><span class="params">(<span class="keyword">int</span> rank)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> select(root,rank);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Key <span class="title">select</span><span class="params">(Node node,<span class="keyword">int</span> rank)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size =size(node.left);</span><br><span class="line">        <span class="keyword">if</span>(size&lt; rank)&#123;</span><br><span class="line">            <span class="keyword">return</span> select(node.right,(rank-size-<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(size&gt;rank)&#123;</span><br><span class="line">            <span class="keyword">return</span> select(node.left,rank);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">int</span> compareTo =key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo&lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rank(node.left,key));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> size(node.left)+<span class="number">1</span>+rank(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">      root =  deleteMin(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           node.left =  deleteMin(node.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        node.N = size(node.left)+size(node.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">      root =  delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node node,Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> compareTo = key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(compareTo&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.right = delete(node.right,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(compareTo &lt;<span class="number">0</span>)&#123;</span><br><span class="line">            node.left = delete(node.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 右树为空 新结点为左子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左子树为空，新节点为右子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> node.right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">             Node minNode = min(node.right);</span><br><span class="line">            Node t= node;</span><br><span class="line">            node = minNode;</span><br><span class="line">            node.right = deleteMin(t.right);</span><br><span class="line">            node.left = t.left; </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        node.N = size(node.left)+size(node.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys(min(),max());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Key&gt; <span class="title">keys</span><span class="params">(Key lo ,Key hi)</span></span>&#123;</span><br><span class="line">        Queue&lt;Key&gt; queue = <span class="keyword">new</span> Queue&lt;Key&gt;();</span><br><span class="line">         keys(root,queue,lo,hi);</span><br><span class="line">         <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">keys</span><span class="params">(Node node,Queue&lt;Key&gt; queue,Key lo ,Key hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> compareLo = lo.compareTo(node.key);</span><br><span class="line">        <span class="keyword">int</span> compareHi = hi.compareTo(node.key);</span><br><span class="line">        <span class="comment">//查左树</span></span><br><span class="line">        <span class="keyword">if</span>(compareLo&lt;<span class="number">0</span> )&#123;</span><br><span class="line">            keys(node.left,lo,hi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结点</span></span><br><span class="line">        <span class="keyword">if</span>(compareHi&gt;=<span class="number">0</span> || compareLo&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">             queue.enqueue(node.key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查右树</span></span><br><span class="line">        <span class="keyword">if</span>(compareHi&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            keys(node.right,lo,hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>3.性能：</p>
<blockquote>
<p>在由N个随机键构成的二叉查找树中，查找命中平均所需的比较次数为~2lnN(约1.39lgN)</p>
<p>在由N个随机键构成的二叉查找树中插入和查找命中未命中的元素平均所需的比较次数为~2lnN(约1.39lgN)</p>
</blockquote>
<h2 id="3-3-平衡查找树"><a href="#3-3-平衡查找树" class="headerlink" title="3.3 平衡查找树"></a>3.3 平衡查找树</h2><h3 id="3-3-1-2-3查找树"><a href="#3-3-1-2-3查找树" class="headerlink" title="3.3.1 2-3查找树"></a>3.3.1 2-3查找树</h3><ol>
<li>定义：一棵2-3查找树或为一棵空疏，或由以下结点组成：<ul>
<li>2-结点：含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向2-3树中的键都大于该结点。</li>
<li>3-结点：含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中链接指向2-3树中的键都位于该结点的两个键之间，右链接指向2-3树中的键都大于该结点。</li>
</ul>
</li>
<li>原理：<ul>
<li>向2-结点插入新结点:只要变成3-结点即可</li>
<li>向一棵只含有一个3-结点的树中插入新键：<ul>
<li>变成4-结点，然后中键上移变成由3个2-结点组成的2-3树</li>
</ul>
</li>
<li>向一个父节点为2-结点的3-结点中插入新键<ul>
<li>变成4-结点，然后中键上移父节点变成3-结点</li>
</ul>
</li>
<li>向一个父节点为3-结点的3-结点中插入新键<ul>
<li>变成4-结点，然后中键上移父节点变成4-结点，父节点再逐级向上分解。</li>
</ul>
</li>
</ul>
</li>
<li>性能：</li>
</ol>
<blockquote>
<p>  在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个</p>
</blockquote>
<h3 id="3-3-2-红黑树"><a href="#3-3-2-红黑树" class="headerlink" title="3.3.2 红黑树"></a>3.3.2 红黑树</h3><ol>
<li><p>定义：将树的类型分为两种：红链接将两个2-结点连接起来构成3-结点，黑链接则是2-3树种的普通链接。<br>另外一种定义：</p>
<ul>
<li>红链接都为左链接</li>
<li>没有任意一个结点与两条红链接相连</li>
<li>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同。</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="keyword">boolean</span> color;</span><br><span class="line">    Key key;</span><br><span class="line">    Value value;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Key key,Value value,<span class="keyword">boolean</span> color,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.N = N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">rotateLeft</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    Node x = h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    h.N = size(h.left)+<span class="number">1</span>+size(h.right);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">rotateRight</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    Node x = h.left;</span><br><span class="line">    x.right = h;</span><br><span class="line">    h.left = h.right;</span><br><span class="line">    x.color = h.color;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    x.N = h.N;</span><br><span class="line">    h.N = size(h.left)+<span class="number">1</span>+size(h.right);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//颜色转换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flipColor</span><span class="params">(Node h)</span></span>&#123;</span><br><span class="line">    h.color = RED;</span><br><span class="line">    h.left.color = BLACK;</span><br><span class="line">    h.right.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedBlackBST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">   Node root;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">        root.color =BLACK;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> node.color;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node node,Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,RED,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//跟二叉查找树一样</span></span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(node.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           node.right =  put(node.right,key,value);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                node.left =  put(node.left,key,value);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  node.value = value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右子结点为红链接且左子结点是黑链接-》左旋</span></span><br><span class="line">        <span class="keyword">if</span>(isRed(node.right) &amp;&amp; !isRed(node.left))&#123;</span><br><span class="line">           <span class="keyword">return</span>  rotateLeft(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子结点为红链接且左子结点的左子结点是红链接-》右旋</span></span><br><span class="line">        <span class="keyword">if</span>(isRed(node.left) &amp;&amp; isRed(node.left.left))&#123;</span><br><span class="line">           <span class="keyword">return</span> rotateRight(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左子结点为红链接且右子结点是红链接-》颜色转换</span></span><br><span class="line">        <span class="keyword">if</span>(isRed(node.left &amp;&amp; isRed(node.right)))&#123;</span><br><span class="line">            flipColor(node);</span><br><span class="line">        &#125;</span><br><span class="line">        node.N = size(node.left)+<span class="number">1</span>size(node.right);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.性能：</p>
<blockquote>
<p>一棵大小为N的红黑树的高度不会超过2lgN</p>
<p>一棵大小为N的红黑树中，根结点到任意结点的平均路径长度为~1.00lgN。</p>
</blockquote>
<h2 id="3-4-散列表"><a href="#3-4-散列表" class="headerlink" title="3.4 散列表"></a>3.4 散列表</h2><ol>
<li>原理：<ul>
<li>第一步用 <strong><em>散列函数</em></strong>将被查找的键转化为数组的一个索引</li>
<li>第二步处理碰撞冲突（用散列函数生成的索引冲突）<ul>
<li>解决的方法：<strong><em>拉链法</em></strong>   和  <strong><em>碰撞法</em></strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-4-1-散列函数"><a href="#3-4-1-散列函数" class="headerlink" title="3.4.1 散列函数"></a>3.4.1 散列函数</h3><ol>
<li>对于每一种类型的键都需要一个与之对应的散列函数。</li>
<li><p>方法：</p>
<ul>
<li>整型：除留余数法 选择一个素数M；然后键的索引=<code>k%M</code></li>
<li>浮点数：将键编程二进制数然后再使用除留余数法</li>
<li><p>字符串：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;s.length();i++)&#123;</span><br><span class="line">   hash = (R * hash + s.charAt(i)) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将hashCode()的返回值转化为一个数组索引</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x.hashCode() &amp;&amp; <span class="number">0x7fffffff</span>)%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="3-4-2-基于拉链法的散列表"><a href="#3-4-2-基于拉链法的散列表" class="headerlink" title="3.4.2 基于拉链法的散列表"></a>3.4.2 基于拉链法的散列表</h3><ol>
<li>原理：选择足够大的M，使得所有链表都尽可能短以保证高效的查找。</li>
<li>查找：先根据散列值找到链表。然后沿着链表顺序查找相应的键。</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparteChainingHashST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对的总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;<span class="comment">//散列表的大小</span></span><br><span class="line">    <span class="keyword">private</span> SquenticalSearchST&lt;Key,Value&gt;[] st;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparteChainingHashST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">997</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeparteChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">        SquenticalSearchST&lt;Key,Value&gt;[] st = <span class="keyword">new</span> (SquenticalSearchST&lt;Key,Value&gt;)SquenticalSearchST[M];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;M; i++)&#123;</span><br><span class="line">            st[i] = <span class="keyword">new</span> SquenticalSearchST();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        st[hash(key)].put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Value)st[hash(key)].get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>性质：</p>
<ul>
<li>在一张含有M条链表和N个键的散列表中，任意一条链表中的键的数量均在N/M的常数因子内的概率无限接近于1.</li>
<li>在一张含有M条链表和N个键的散列表中，未命中查找和插入操作所需的比较次数为~N/M;</li>
</ul>
</li>
</ol>
<h3 id="3-4-2-基于线性探测法的散列表"><a href="#3-4-2-基于线性探测法的散列表" class="headerlink" title="3.4.2 基于线性探测法的散列表"></a>3.4.2 基于线性探测法的散列表</h3><ol>
<li>原理：用大小为M的数组保存N个键对。M&gt;N。利用数组中的空位解决碰撞。这种方法统称为 <strong><em>开放地址散列表</em></strong>。（思想：预期将内存用作链表，不如将它们作为在散列表的空元素）</li>
<li>当碰撞发生时，我们直接检查散列表中的下一个位置。有以下三种情况<ul>
<li>命中，该位置的键与被查找的键相同</li>
<li>未命中，该位置的键为空</li>
<li>继续查找，该位置的键与被查找的键不相同</li>
</ul>
</li>
<li>代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashSt</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;<span class="comment">//键值对总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M;<span class="comment">//数组大小</span></span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] values;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashSt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        keys = <span class="keyword">new</span> (Key[]) Object[M];</span><br><span class="line">        values = <span class="keyword">new</span> (Value[]) Object[M];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode()&amp;<span class="number">0x7fffffff</span>)%M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 确保有空位存放元素</span></span><br><span class="line">        <span class="keyword">if</span>(n&gt;M/<span class="number">2</span>)resize(<span class="number">2</span>*M);</span><br><span class="line">        <span class="comment">//假如key[hash] !=null 索引逐渐加1；</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hash(key); keys[i]!=<span class="keyword">null</span> ; i = (i+<span class="number">1</span>)%M)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key[i].equals(key))&#123;</span><br><span class="line">                values[i] = value;<span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i] = key;</span><br><span class="line">        values[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = hash(key); keys[i]!=<span class="keyword">null</span> ; i = (i+<span class="number">1</span>)%M)&#123;</span><br><span class="line">            <span class="keyword">if</span>(key[i].equals(key))&#123;</span><br><span class="line">               <span class="keyword">return</span> values[i] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!contains(key))<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = keys[hash(key)];</span><br><span class="line">        <span class="comment">//找到对应的key的索引</span></span><br><span class="line">        <span class="keyword">while</span>(!key.equals(keys[i])  )&#123;</span><br><span class="line">            i = (i+<span class="number">1</span>)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除该索引的键值</span></span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        values[i] = <span class="keyword">null</span>;</span><br><span class="line">        i = (i+<span class="number">1</span>)%M;</span><br><span class="line">        <span class="comment">//先删除再插入</span></span><br><span class="line">        <span class="keyword">while</span>(keys[i]!=<span class="keyword">null</span>)&#123; </span><br><span class="line">            Key keyToRedo = keys[i];</span><br><span class="line">            Value valueToRedo = values[i];</span><br><span class="line">            keys[i] =<span class="keyword">null</span>;</span><br><span class="line">            values[i] =<span class="keyword">null</span>;</span><br><span class="line">             N--;</span><br><span class="line">             put(keyToRedo,valueToRedo);</span><br><span class="line">              i = (i+<span class="number">1</span>)%M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(N&gt;<span class="number">0</span> &amp;&amp; N==M/<span class="number">8</span>)resize(M/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="各个查找方法对比"><a href="#各个查找方法对比" class="headerlink" title="各个查找方法对比"></a>各个查找方法对比</h3><p><a href="http://oa5ova13h.bkt.clouddn.com/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95.PNG" target="_blank" rel="external">对比图</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/24/linux-vbird-chapter-7/" itemprop="url">
                  《鸟哥的私房菜》读书笔记-第七章、Linux 文件与目录管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-24T08:26:13+08:00" content="2016-11-24">
              2016-11-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/24/linux-vbird-chapter-7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/24/linux-vbird-chapter-7/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-目录与路径"><a href="#1-目录与路径" class="headerlink" title="1. 目录与路径"></a>1. 目录与路径</h4><h5 id="1-1-相对路径与绝对路径"><a href="#1-1-相对路径与绝对路径" class="headerlink" title="1.1 相对路径与绝对路径"></a>1.1 相对路径与绝对路径</h5><pre><code>相对路径：./
绝对路径: /xx/xx
</code></pre><h5 id="1-2-目录的相关操作：-cd-pwd-mkdir-rmdir"><a href="#1-2-目录的相关操作：-cd-pwd-mkdir-rmdir" class="headerlink" title="1.2 目录的相关操作： cd, pwd, mkdir, rmdir"></a>1.2 目录的相关操作： cd, pwd, mkdir, rmdir</h5><pre><code>cd: change directory
    cd ~ 
    cd ~[username]
    cd - 上个视图的目录
    cd .. 当前目录的父目录
pwd：print working directory
    pwd -P ：显示真正的目录，非连接文件夹的名称
mkdir: make directory
    mkdir -p test1/test2/test3 ：创建test3，当其父目录不存在的时候一并创建
rmdir: remove directory 删除空文件夹
    rmdir xxx 只能删除空文件夹
    rmdir -r xxx 递归删除文件夹里面所有的东西
</code></pre><h5 id="1-3-关於运行档路径的变量：-PATH"><a href="#1-3-关於运行档路径的变量：-PATH" class="headerlink" title="1.3 关於运行档路径的变量： $PATH"></a>1.3 关於运行档路径的变量： $PATH</h5><pre><code>echo $PATH 执行文件所在的文件路径，即环境变量
</code></pre><h4 id="2-文件与目录管理"><a href="#2-文件与目录管理" class="headerlink" title="2. 文件与目录管理"></a>2. 文件与目录管理</h4><h5 id="2-1-文件与目录的检视：-ls"><a href="#2-1-文件与目录的检视：-ls" class="headerlink" title="2.1 文件与目录的检视： ls"></a>2.1 文件与目录的检视： ls</h5><pre><code>ls -l：当前目录的属性和权限
ls -a：显示隐藏文件
ls -d：只显示目录
</code></pre><h5 id="2-2-复制、删除与移动：-cp-rm-mv"><a href="#2-2-复制、删除与移动：-cp-rm-mv" class="headerlink" title="2.2 复制、删除与移动： cp, rm, mv"></a>2.2 复制、删除与移动： cp, rm, mv</h5><pre><code>cp:
    cp -a xxx：相当於 -pdr 的意思
    cp -i xxx：询问，假如目标文件存在
    cp -p xxx:连同文件属性一并复制过去
    cp -r xxx:递归复制，如复制文件夹
rm:
    rm -r xxx：因为该目录或文件『肯定』会被 root 杀掉！
mv: 移动更名
    mv xxx xxx
</code></pre><h5 id="2-3-取得路径的文件名称与目录名称"><a href="#2-3-取得路径的文件名称与目录名称" class="headerlink" title="2.3 取得路径的文件名称与目录名称"></a>2.3 取得路径的文件名称与目录名称</h5><h4 id="3-文件内容查阅："><a href="#3-文件内容查阅：" class="headerlink" title="3. 文件内容查阅："></a>3. 文件内容查阅：</h4><h5 id="3-1-直接检视文件内容：-cat-tac-nl"><a href="#3-1-直接检视文件内容：-cat-tac-nl" class="headerlink" title="3.1 直接检视文件内容： cat, tac, nl"></a>3.1 直接检视文件内容： cat, tac, nl</h5><h5 id="3-2-可翻页检视：-more-less"><a href="#3-2-可翻页检视：-more-less" class="headerlink" title="3.2 可翻页检视： more, less"></a>3.2 可翻页检视： more, less</h5><h5 id="3-3-数据撷取：-head-tail"><a href="#3-3-数据撷取：-head-tail" class="headerlink" title="3.3 数据撷取： head, tail"></a>3.3 数据撷取： head, tail</h5><h5 id="3-4-非纯文字档：-od"><a href="#3-4-非纯文字档：-od" class="headerlink" title="3.4 非纯文字档： od"></a>3.4 非纯文字档： od</h5><h5 id="3-5-修改文件时间与建置新档：-touch"><a href="#3-5-修改文件时间与建置新档：-touch" class="headerlink" title="3.5 修改文件时间与建置新档： touch"></a>3.5 修改文件时间与建置新档： touch</h5><h4 id="4-文件与目录的默认权限与隐藏权限"><a href="#4-文件与目录的默认权限与隐藏权限" class="headerlink" title="4. 文件与目录的默认权限与隐藏权限"></a>4. 文件与目录的默认权限与隐藏权限</h4><h5 id="4-1-文件默认权限：umask"><a href="#4-1-文件默认权限：umask" class="headerlink" title="4.1 文件默认权限：umask"></a>4.1 文件默认权限：umask</h5><h5 id="4-2-文件隐藏属性：-chattr-lsattr"><a href="#4-2-文件隐藏属性：-chattr-lsattr" class="headerlink" title="4.2 文件隐藏属性： chattr, lsattr"></a>4.2 文件隐藏属性： chattr, lsattr</h5><h5 id="4-4-文件特殊权限：SUID-SGID-SBIT-权限配置"><a href="#4-4-文件特殊权限：SUID-SGID-SBIT-权限配置" class="headerlink" title="4.4 文件特殊权限：SUID, SGID, SBIT, 权限配置"></a>4.4 文件特殊权限：SUID, SGID, SBIT, 权限配置</h5><pre><code>SUID： Set UID 替代x，就是说有了s后在运行该程序的时候具有该程序拥有者的权限，就能够通过该程序修改属于改程序拥有者的文件
    SUID 权限仅对二进位程序(binary program)有效；
    运行者对於该程序需要具有 x 的可运行权限；
    本权限仅在运行该程序的过程中有效 (run-time)；
    运行者将具有该程序拥有者 (owner) 的权限。
SGID：与SUID类似只是把运行时拥有该程序所在群组的权限
    对于文件：
        SGID 对二进位程序有用还有目录！！！
        程序运行者对於该程序来说，需具备 x 的权限；
        运行者在运行的过程中将会获得该程序群组的支持
    对于目录：
        使用者若对於此目录具有 r 与 x 的权限时，该使用者能够进入此目录；
        使用者在此目录下的有效群组(effective group)将会变成该目录的群组；
        用途：若使用者在此目录下具有 w 的权限(可以新建文件)                ，则使用者所创建的新文件，该新文件的群组与此目录的群组 ***相同***。
SBIT：Sticky Bit
    当使用者对於此目录具有 w, x 权限，亦即具有写入的权限时；
    当使用者在该目录下创建文件或目录时，***仅有***自己与 root 才有权力删除该文件
权限配置
     4 为 SUID
    2 为 SGID
    1 为 SBIT
</code></pre><h5 id="4-3-观察文件类型：file"><a href="#4-3-观察文件类型：file" class="headerlink" title="4.3 观察文件类型：file"></a>4.3 观察文件类型：file</h5><pre><code>file xxx
</code></pre><h4 id="5-命令与文件的搜寻："><a href="#5-命令与文件的搜寻：" class="headerlink" title="5. 命令与文件的搜寻："></a>5. 命令与文件的搜寻：</h4><h5 id="5-1-命令档名的搜寻：which"><a href="#5-1-命令档名的搜寻：which" class="headerlink" title="5.1 命令档名的搜寻：which"></a>5.1 命令档名的搜寻：which</h5><pre><code>which xxx
</code></pre><h5 id="5-2-文件档名的搜寻：whereis-locate-find"><a href="#5-2-文件档名的搜寻：whereis-locate-find" class="headerlink" title="5.2 文件档名的搜寻：whereis, locate, find"></a>5.2 文件档名的搜寻：whereis, locate, find</h5><pre><code>1. whereis
2. locate
3. find
    find path -user name
    find path -group name
    find path -perm mode 权限刚好
    find path -perm -mode 必须要全部囊括 mode 的权限的文件
    find path -perm +mode 
        搜寻文件权限『包含任一 mode 的权限』的文件，举例来说，我们搜寻
         -rwxr-xr-x ，亦即 -perm +755 时，但一个文件属性为 -rw-------也会被列出来，因为他有 -rw.... 的属性存在！
    find / -perm +7000 -exec ls -l {} \;
        {} 代表的是『由 find 找到的内容』，如上图所示，find 的结果会被放置到 {} 位置中；-exec 一直到 \; 是关键字，代表 find 额外动作的开始 (-exec) 到结束 (\;) ，在这中间的就是 find 命令内的额外动作。 在本例中就是『 ls -l {} 』罗！因为『 ; 』在 bash 环境下是有特殊意义的，因此利用反斜线来跳脱。
</code></pre><h4 id="6-极重要！权限与命令间的关系："><a href="#6-极重要！权限与命令间的关系：" class="headerlink" title="6. 极重要！权限与命令间的关系："></a>6. 极重要！权限与命令间的关系：</h4><pre><code>一、让使用者能进入某目录成为『可工作目录』的基本权限为何：
    可使用的命令：例如 cd 等变换工作目录的命令；
    目录所需权限：使用者对这个目录至少需要具有 x 的权限
    额外需求：如果使用者想要在这个目录内利用 ls 查阅档名，则使用者对此目录还需要 r 的权限。
二、使用者在某个目录内读取一个文件的基本权限为何？
    可使用的命令：例如本章谈到的 cat, more, less等等
    目录所需权限：使用者对这个目录至少需要具有 x 权限；
    文件所需权限：使用者对文件至少需要具有 r 的权限才行！
三、让使用者可以修改一个文件的基本权限为何？
    可使用的命令：例如 nano 或未来要介绍的 vi 编辑器等；
    目录所需权限：使用者在该文件所在的目录至少要有 x 权限；
    文件所需权限：使用者对该文件至少要有 r, w 权限
四、让一个使用者可以创建一个文件的基本权限为何？
    目录所需权限：使用者在该目录要具有 w,x 的权限，重点在 w 啦！
五、让使用者进入某目录并运行该目录下的某个命令之基本权限为何？
    目录所需权限：使用者在该目录至少要有 x 的权限；
    文件所需权限：使用者在该文件至少需要有 x 的权限
</code></pre><p>-a 是and 的意思<br>-o 是or的意思<br>! 条件  是非的意思<br>find / ! -user root 查找非root的文件</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/24/linux-vbird-chapter-10/" itemprop="url">
                  《鸟哥的私房菜》读书笔记-第十章、vim 程序编辑器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-24T08:26:13+08:00" content="2016-11-24">
              2016-11-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/24/linux-vbird-chapter-10/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/24/linux-vbird-chapter-10/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-vi-与-vim"><a href="#1-vi-与-vim" class="headerlink" title="1. vi 与 vim"></a>1. vi 与 vim</h4><h5 id="1-1-为何要学-vim"><a href="#1-1-为何要学-vim" class="headerlink" title="1.1 为何要学 vim"></a>1.1 为何要学 vim</h5><pre><code>*  所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在；
* 很多个别软件的编辑接口都会 ***主动呼叫 vi*** (例如未来会谈到的 crontab, visudo, edquota 等指令)；
* vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计；
</code></pre><p>因为程序简单，编辑速度相当快速。</p>
<h4 id="2-vi-的使用"><a href="#2-vi-的使用" class="headerlink" title="2. vi 的使用"></a>2. vi 的使用</h4><h5 id="2-1-简易执行范例"><a href="#2-1-简易执行范例" class="headerlink" title="2.1 简易执行范例"></a>2.1 简易执行范例</h5><pre><code>2.2.1 vi [filename]
2.2.2 模式：编辑模式和命令模式之间不能切换
    一般模式：按[i,o,a]切换到编辑模式，按Esc退出
    编辑模式：
    命令模式：
</code></pre><h5 id="2-2-按键说明"><a href="#2-2-按键说明" class="headerlink" title="2.2 按键说明"></a>2.2 按键说明</h5><h6 id="2-2-1-一般模式可用的按钮说明，光标移动、复制贴上、搜寻取代等"><a href="#2-2-1-一般模式可用的按钮说明，光标移动、复制贴上、搜寻取代等" class="headerlink" title="2.2.1 一般模式可用的按钮说明，光标移动、复制贴上、搜寻取代等"></a>2.2.1 一般模式可用的按钮说明，光标移动、复制贴上、搜寻取代等</h6><pre><code>2.2.1.1 移动光标的方法：
    `crtl+f`:下一页[Page Down]
    `crtl+b`：上一页[Page Up]
    `0`：移动到这一行的最前面字符处 [Home]
    `$`：移动到这一行的最后面字符处 [End]
    `gg`：第一行
    `G`：最后一行
    `n&lt;space&gt;`:那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20space 则光标会向后面移动 20 个字符距离。
    `n&lt;Enter&gt;`:n 为数字。光标向下移动 n 行(
    `nG`：到第几行
2.2.1.2 寻找替换：
    `/word`：向下查找word
    `:n1,$n2s/word1/word2/g`： 从n1行到n2行把word1替换成word2
    `:n1,$s/word1/word2/g`： 从第n2行开始到最后一行把word1替换成word2
    `:n1,$s/word1/word2/gc`：    从第n2行开始到最后一行把word1替换成word2,需要confirm确定
2.2.1.3 删除、复制与贴上：
    `x`和`X`：`x`为删除光标后的一个字符，即向后删[delete],`X` 为删除光标前的一个字符,即向前删[backspace]
    `xn`：连续删除n个字符
    `dd`：删除该行
    `ndd`:n 为数字。删除光标所在的向下 n 列（包括该行），例如 20dd     则是删除 20 列 
    `yy`：复制该行
    `nyy`：n为数字，复制光标所在的向下 n 列（包括该行），例如 20yy  则是复制 20 列
    `p`和`P`：p 为将已复制的数据在光标下一行贴上，P    则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了    10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20  行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20    行会被推到变成 30 行。
    `crtl +r`:重做上一个动作
    `u`：撤销
    `.`：重做上一个动作
</code></pre><h6 id="2-2-2-一般模式切换到编辑模式的可用的按钮说明"><a href="#2-2-2-一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="2.2.2 一般模式切换到编辑模式的可用的按钮说明"></a>2.2.2 一般模式切换到编辑模式的可用的按钮说明</h6><pre><code>2.2.2.1 进入插入或取代的编辑模式：
`i, I`：进入插入模式(Insert mode)：
</code></pre><p>i 为『从目前光标所在处插入』， I 为『在目前所在行的第一个非空格符处开始插入』<br>            <code>a, A</code>：进入插入模式(Insert mode)：<br>a 为『从目前光标所在的下一个字符处开始插入』， A 为『从光标所在行的最后一个字符处开始插入』<br>            <code>o, O</code>：进入插入模式(Insert mode)：<br>这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处插入新的一行』； O 为在目前光标所在处的上一行插入新的一行！<br>            <code>r, R</code>：进入取代模式(Replace mode)：<br>r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；</p>
<h6 id="2-2-3-一般模式切换到指令列模式的可用的按钮说明"><a href="#2-2-3-一般模式切换到指令列模式的可用的按钮说明" class="headerlink" title="2.2.3 一般模式切换到指令列模式的可用的按钮说明"></a>2.2.3 一般模式切换到指令列模式的可用的按钮说明</h6><pre><code>2.2.3.1 指令列的储存、离开等指令
    `:w`：将编辑的数据写入硬盘档案中
    `:q`：离开
    `:wq`：储存后离开，若为 :wq! 则为强制储存后离开
2.2.3.2 vim 环境的变更
    `:set nu` ：显示行号
    `:set nonu`:不显示行号
</code></pre><h5 id="2-3-一个案例的练习"><a href="#2-3-一个案例的练习" class="headerlink" title="2.3 一个案例的练习"></a>2.3 一个案例的练习</h5><h5 id="2-4-vim-的暂存档、救援回复与开启时的警告讯息"><a href="#2-4-vim-的暂存档、救援回复与开启时的警告讯息" class="headerlink" title="2.4 vim 的暂存档、救援回复与开启时的警告讯息"></a>2.4 vim 的暂存档、救援回复与开启时的警告讯息</h5><h4 id="3-vim-的额外功能"><a href="#3-vim-的额外功能" class="headerlink" title="3. vim 的额外功能"></a>3. vim 的额外功能</h4><h5 id="3-1-区块选择-Visual-Block"><a href="#3-1-区块选择-Visual-Block" class="headerlink" title="3.1 区块选择(Visual Block)"></a>3.1 区块选择(Visual Block)</h5><pre><code>    `v`：字符选择，会将光标经过的地方反白选择！
    `V`：行选择，会将光标经过的行反白选择！
`[Ctrl]+v`：区块选择，可以用长方形的方式选择资料
    `y`：将反白的地方复制起来
</code></pre><p>d   将反白的地方删除掉</p>
<h5 id="3-2-多档案编辑"><a href="#3-2-多档案编辑" class="headerlink" title="3.2 多档案编辑"></a>3.2 多档案编辑</h5><pre><code>`vim filename1 filename2`
:n  编辑下一个档案
:N  编辑上一个档案
:files  列出目前这个 vim 的开启的所有档案
</code></pre><h5 id="3-3-多窗口功能"><a href="#3-3-多窗口功能" class="headerlink" title="3.3 多窗口功能"></a>3.3 多窗口功能</h5><pre><code>`:sp [filename]`  开启一个新窗口，如果有加 filename， 表示在新窗口开启一个新档案，否则表示两个窗口为同一个档案内容(同步显示)。
`[ctrl]+w+ j`和`[ctrl]+w+↓`  按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j (或向下箭头键)，则光标可移动到下方的窗口。
`[ctrl]+w+ k` 和`[ctrl]+w+↑`同上，不过光标移动到上面的窗口。
`[ctrl]+w+ q` 其实就是 :q 结束离开啦！ 举例来说，如果我想要结束下方的窗口，那么利用 [ctrl]+w+↓ 移动到下方窗口后，按下 :q 即可离开， 也可以按下 [ctrl]+w+q 啊！
</code></pre><h5 id="3-4-vim-环境设定与记录：-vimrc-viminfo"><a href="#3-4-vim-环境设定与记录：-vimrc-viminfo" class="headerlink" title="3.4 vim 环境设定与记录： ~/.vimrc, ~/.viminfo"></a>3.4 vim 环境设定与记录： ~/.vimrc, ~/.viminfo</h5><h5 id="3-5-vim-常用指令示意图"><a href="#3-5-vim-常用指令示意图" class="headerlink" title="3.5 vim 常用指令示意图"></a>3.5 vim 常用指令示意图</h5><h4 id="4-其他-vim-使用注意事项"><a href="#4-其他-vim-使用注意事项" class="headerlink" title="4. 其他 vim 使用注意事项"></a>4. 其他 vim 使用注意事项</h4><h5 id="4-1-中文编码的问题"><a href="#4-1-中文编码的问题" class="headerlink" title="4.1 中文编码的问题"></a>4.1 中文编码的问题</h5><pre><code>LANG= xxx
</code></pre><h5 id="4-2-DOS-与-Linux-的断行字符：-dos2unix-unix2dos"><a href="#4-2-DOS-与-Linux-的断行字符：-dos2unix-unix2dos" class="headerlink" title="4.2 DOS 与 Linux 的断行字符： dos2unix, unix2dos"></a>4.2 DOS 与 Linux 的断行字符： dos2unix, unix2dos</h5><pre><code>而 Linux 的 Enter 为 LF 符号， 不过，由于 DOS 的断行符号是 CRLF ，也就是多了一个 ^M 的符号出来
</code></pre><h5 id="4-3-语系编码转换：-iconv"><a href="#4-3-语系编码转换：-iconv" class="headerlink" title="4.3 语系编码转换： iconv"></a>4.3 语系编码转换： iconv</h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/24/linux-vbird-chapter-6/" itemprop="url">
                  《鸟哥的私房菜》读书笔记-第六章、Linux 的文件权限与目录配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-24T00:17:13+08:00" content="2016-11-24">
              2016-11-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/24/linux-vbird-chapter-6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/24/linux-vbird-chapter-6/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-使用者与群组"><a href="#1-使用者与群组" class="headerlink" title="1. 使用者与群组"></a>1. 使用者与群组</h4><pre><code>1. user，group 和others
</code></pre><h4 id="2-Linux文件权限概念"><a href="#2-Linux文件权限概念" class="headerlink" title="2. Linux文件权限概念"></a>2. Linux文件权限概念</h4><h5 id="2-1-Linux文件属性"><a href="#2-1-Linux文件属性" class="headerlink" title="2.1 Linux文件属性"></a>2.1 Linux文件属性</h5><pre><code>-rwrwx---
d 为目录
- 为文件
l 连结档(link file
b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；
c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。
三个rwx，分别为文件拥有者的权限，同群组的权限，其他非本群组的权限
</code></pre><p>第二组为『同群组的权限』；<br>第三组为『其他非本群组的权限』。</p>
<h5 id="2-2-如何改变文件属性与权限：-chgrp-chown-chmod"><a href="#2-2-如何改变文件属性与权限：-chgrp-chown-chmod" class="headerlink" title="2.2 如何改变文件属性与权限： chgrp, chown, chmod"></a>2.2 如何改变文件属性与权限： chgrp, chown, chmod</h5><pre><code>chgrp: `chgrp 群组 文件` 
chown：`chown 用户 文件`
chmod：`chmod 文件权限 文件名` `chmod 644 test.txt`
chmod   u g o       a +(加入)  -(除去)      =(设定)
        r
        w
        x   文件或目录
        如`chmod  u=rwx,go=rx  .bashrc`、`chmod  a+w  .bashrc`、`chmod  a-x  .bashrc`
</code></pre><h5 id="2-3-目录与文件之权限意义"><a href="#2-3-目录与文件之权限意义" class="headerlink" title="2.3 目录与文件之权限意义"></a>2.3 目录与文件之权限意义</h5><pre><code>对文件：
    r:读取文件内容
    w:修改，编辑，新增但***不包含删除该文件***
    x：跟window根据扩展名判断文件是否执行不同,Linux系统是根据x这个权限来决定文件是否可以被执行
对目录：
    r:具有读取目录结构列表的权限。即可以使用`ls`,但是只看到文件名，要看到文件详细需要`x`,不然只会有问号
    w:建立新文件和新文件夹，删除已存在的文件和文件夹（*无论其权限如何*）,修改文件夹和文件名，移动目录内文件和文件夹的位置。
    要判断用户是否有权限删除一个文件，就 *判断用户对该文件所处的父目录是否有w权限*
    x:用户能否进入该目录成为工作目录
    假如要开放目录给其他人：应该至少也要给予r及x的权限，但w权限不可随便给.
</code></pre><h5 id="2-4-Linux文件种类与扩展名"><a href="#2-4-Linux文件种类与扩展名" class="headerlink" title="2.4 Linux文件种类与扩展名"></a>2.4 Linux文件种类与扩展名</h5><h4 id="3-Linux目录配置"><a href="#3-Linux目录配置" class="headerlink" title="3. Linux目录配置"></a>3. Linux目录配置</h4><h5 id="3-1-Linux目录配置的依据–FHS：-usr-var"><a href="#3-1-Linux目录配置的依据–FHS：-usr-var" class="headerlink" title="3.1 Linux目录配置的依据–FHS：/, /usr, /var"></a>3.1 Linux目录配置的依据–FHS：/, /usr, /var</h5><h5 id="3-2-目录树-directory-tree"><a href="#3-2-目录树-directory-tree" class="headerlink" title="3.2 目录树(directory tree)"></a>3.2 目录树(directory tree)</h5><h5 id="3-3-绝对路径与相对路径"><a href="#3-3-绝对路径与相对路径" class="headerlink" title="3.3 绝对路径与相对路径"></a>3.3 绝对路径与相对路径</h5><h5 id="3-4-CentOS-的观察：-lsb-release"><a href="#3-4-CentOS-的观察：-lsb-release" class="headerlink" title="3.4 CentOS 的观察： lsb_release"></a>3.4 CentOS 的观察： lsb_release</h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/24/linux-vbird-chapter-5/" itemprop="url">
                  《鸟哥的私房菜》读书笔记-第五章、首次登陆与在线求助 man page
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-24T00:16:13+08:00" content="2016-11-24">
              2016-11-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/24/linux-vbird-chapter-5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/24/linux-vbird-chapter-5/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-首次登陆系统"><a href="#1-首次登陆系统" class="headerlink" title="1. 首次登陆系统"></a>1. 首次登陆系统</h4><h5 id="1-1-首次登陆CentOS-5-x图形接口"><a href="#1-1-首次登陆CentOS-5-x图形接口" class="headerlink" title="1.1 首次登陆CentOS 5.x图形接口"></a>1.1 首次登陆CentOS 5.x图形接口</h5><h5 id="1-2-GNOME的操作与注销"><a href="#1-2-GNOME的操作与注销" class="headerlink" title="1.2 GNOME的操作与注销"></a>1.2 GNOME的操作与注销</h5><h5 id="1-3-KDE的操作与注销"><a href="#1-3-KDE的操作与注销" class="headerlink" title="1.3 KDE的操作与注销"></a>1.3 KDE的操作与注销</h5><h5 id="1-4-X-Window与文本模式的切换"><a href="#1-4-X-Window与文本模式的切换" class="headerlink" title="1.4 X Window与文本模式的切换"></a>1.4 X Window与文本模式的切换</h5><h5 id="1-5-在终端界面登陆linux"><a href="#1-5-在终端界面登陆linux" class="headerlink" title="1.5 在终端界面登陆linux"></a>1.5 在终端界面登陆linux</h5><pre><code>至于提示字符方面，在Linux当中，默认root的提示字符为 # ，而一般身份用户的提示字符为 $ 。
</code></pre><h4 id="2-文本模式下命令的下达"><a href="#2-文本模式下命令的下达" class="headerlink" title="2. 文本模式下命令的下达"></a>2. 文本模式下命令的下达</h4><h5 id="2-1-开始下达命令-语系的支持"><a href="#2-1-开始下达命令-语系的支持" class="headerlink" title="2.1 开始下达命令, 语系的支持"></a>2.1 开始下达命令, 语系的支持</h5><pre><code>命令格式：`command [-options] parameter1 parameter2`
大小写区分
使用反斜杠 `(\)` 来替代[Enter]符号达到换行的作用
命令, 选项, 参数等这几个咚咚中间以空格来区分，不论空几格 shell 都视为一格；
</code></pre><h5 id="2-2-基础命令的操作-date-cal-bc"><a href="#2-2-基础命令的操作-date-cal-bc" class="headerlink" title="2.2 基础命令的操作, date, cal, bc"></a>2.2 基础命令的操作, date, cal, bc</h5><h5 id="2-3-重要的几个热键-Tab-ctrl-c-ctrl-d"><a href="#2-3-重要的几个热键-Tab-ctrl-c-ctrl-d" class="headerlink" title="2.3 重要的几个热键[Tab], [ctrl]-c, [ctrl]-d"></a>2.3 重要的几个热键[Tab], [ctrl]-c, [ctrl]-d</h5><pre><code>1. TAB 
    [Tab] 接在一串命令的第一个字的后面，则为命令补全；
    [Tab] 接在一串命令的第二个字以后时，则为『文件补齐』(因为参数有可能是文件)！
2. [Ctrl]-c 按键：停止
3. [Ctrl]-d 按键：相当于输入exit啊
</code></pre><h5 id="2-4-错误信息的查看"><a href="#2-4-错误信息的查看" class="headerlink" title="2.4 错误信息的查看"></a>2.4 错误信息的查看</h5><h4 id="3-Linux系统的在线求助man-page与info-page"><a href="#3-Linux系统的在线求助man-page与info-page" class="headerlink" title="3. Linux系统的在线求助man page与info page"></a>3. Linux系统的在线求助man page与info page</h4><h5 id="3-1-man-page"><a href="#3-1-man-page" class="headerlink" title="3.1 man page"></a>3.1 man page</h5><pre><code>1. man xxx :manual(操作说明)的简写 xxx为命令
2. 『DATE(1)』 ***1，3和8***
        |代号  代表内容|
        |1|           使用者在shell环境中可以操作的命令或可运行文件|
        |2|           系统核心可呼叫的函数与工具等|
        |3|           一些常用的函数(function)与函式库(library)，大部分为C的函式库(libc)|
        |4|           装置文件的说明，通常在/dev下的文件|
        |5|           配置文件或者是某些文件的格式|
        |6|           游戏(games)|
        |7|           惯例与协议等，例如Linux文件系统、网络协议、ASCII code等等的说明|
        |8|           系统管理员可用的管理命令|
        |9|           跟kernel有关的文件|
3. `man -f [命令或者是数据]`  `man -f man`-&gt;`man 1 man`
    左边为该命令的名字和数字
    右边为简易说明
    等于 `whatis [命令或者是数据]`
4. `man -k 命令或者文件关键词` 通过关键词搜索
    等于`apropos [命令或者是数据]`
5. ***记住常见命令，通过man去查找相关说明 再通过`tab`补全去查找相关的命名，再通过man去查看细节。***
</code></pre><h5 id="3-2-info-page"><a href="#3-2-info-page" class="headerlink" title="3.2 info page"></a>3.2 info page</h5><pre><code>File：代表这个info page的数据是来自info.info文件所提供的；
Node：代表目前的这个页面是属于Top节点。意思是info.info内含有很多信息，而Top仅是info.info文件内的一个节点内容而已；
Next：下一个节点的名称为Getting Started，你也可以按『N』到下个节点去；
Up：回到上一层的节点总揽画面，你也可以按下『U』回到上一层；
Prev：前一个节点。但由于Top是info.info的第一个节点，所以上面没有前一个节点的信息。
</code></pre><h5 id="3-3-其他有用的文件-documents"><a href="#3-3-其他有用的文件-documents" class="headerlink" title="3.3 其他有用的文件(documents)"></a>3.3 其他有用的文件(documents)</h5><pre><code>在文字接口下，有任何你不知道的命令或文件格式这种玩意儿，但是你想要了解他，请赶快使用man或者是info来查询！
而如果你想要架设一些其他的服务，或想要利用一整组软件来达成某项功能时，请赶快到/usr/share/doc 底下查一查有没有该服务的说明档喔！
</code></pre><h4 id="4-超简单文书编辑器：-nano"><a href="#4-超简单文书编辑器：-nano" class="headerlink" title="4. 超简单文书编辑器： nano"></a>4. 超简单文书编辑器： nano</h4><pre><code>[ctrl]-G：取得联机帮助(help)，很有用的！
[ctrl]-X：离开naon软件，若有修改过文件会提示是否需要储存喔！
[ctrl]-O：储存文件，若你有权限的话就能够储存文件了；
[ctrl]-R：从其他文件读入数据，可以将某个文件的内容贴在本文件中；
[ctrl]-W：搜寻字符串，这个也是很有帮助的命令喔！
[ctrl]-C：说明目前光标所在处的行数与列数等信息；
[ctrl]-_：可以直接输入行号，让光标快速移动到该行；
[alt]-Y：校正语法功能开启或关闭(单击开、再单击关)
[alt]-M：可以支持鼠标来移动光标的功能
</code></pre><h4 id="5-正确的关机方法-sync-shutdown-reboot-halt-poweroff-init"><a href="#5-正确的关机方法-sync-shutdown-reboot-halt-poweroff-init" class="headerlink" title="5. 正确的关机方法: sync, shutdown, reboot, halt, poweroff, init"></a>5. 正确的关机方法: sync, shutdown, reboot, halt, poweroff, init</h4><pre><code>将数据同步写入硬盘中的命令： sync
惯用的关机命令： shutdown
重新启动，关机： reboot, halt, poweroff
    可以自由选择关机模式：是要关机、重新启动或进入单人操作模式均可；
    可以配置关机时间: 可以配置成现在立刻关机,      也可以配置某一个特定的时间才关机。
    可以自定义关机信息：在关机之前，可以将自己配置的信息传送给在线 user 。
    可以仅发出警告信息：有时有可能你要进行一些测试，而不想让其他的使用者干扰，         或者是明白的告诉使用者某段时间要注意一下！这个时候可以使用 shutdown        来吓一吓使用者，但却不是真的要关机啦！
    可以选择是否要 fsck 检查文件系统 。
    [root@www ~]# /sbin/shutdown [-t 秒] [-arkhncfF] 时间 [警告信息] 
    选项与参数： 
    -t sec ： -t 后面加秒数，亦即『过几秒后关机』的意思 
    -k     ： 不要真的关机，只是发送警告信息出去！ 
    -r     ： 在将系统的服务停掉之后就重新启动(常用) 
    -h     ： 将系统的服务停掉后，立即关机。 (常用) 
    -n     ： 不经过 init 程序，直接以 shutdown 的功能来关机 
    -f     ： 关机并启动之后，强制略过 fsck 的磁盘检查 
    -F     ： 系统重新启动之后，强制进行 fsck 的磁盘检查 
    -c     ： 取消已经在进行的 shutdown 命令内容。 
</code></pre><h4 id="6-启动过程的问题排解"><a href="#6-启动过程的问题排解" class="headerlink" title="6. 启动过程的问题排解"></a>6. 启动过程的问题排解</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/22/linux-vbird-chapter-0/" itemprop="url">
                  《鸟哥的私房菜》读书笔记-第零章：计算机概论
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-11-22T22:16:13+08:00" content="2016-11-22">
              2016-11-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/11/22/linux-vbird-chapter-0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/22/linux-vbird-chapter-0/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第零章-计算机概论"><a href="#第零章-计算机概论" class="headerlink" title="第零章 计算机概论"></a>第零章 计算机概论</h3><h4 id="1-計算机：辅助人脑的好工具"><a href="#1-計算机：辅助人脑的好工具" class="headerlink" title="1. 計算机：辅助人脑的好工具"></a>1. 計算机：辅助人脑的好工具</h4><h5 id="1-1-計算机硬件的五大单元"><a href="#1-1-計算机硬件的五大单元" class="headerlink" title="1.1 計算机硬件的五大单元"></a>1.1 計算机硬件的五大单元</h5><pre><code>1. 输入单元：鼠标、触摸板、键盘等
2. 输出单元：显示器、打印机等
3. cpu中的控制单元
4. cpu中的算数逻辑单元
5. 主内存
</code></pre><h5 id="1-2-CPU的种类"><a href="#1-2-CPU的种类" class="headerlink" title="1.2 CPU的种类"></a>1.2 CPU的种类</h5><pre><code>1. 精简指令集（RISC）reduced instruction set computer
    特点：指令简单，运行快，执行效果好。但是复杂需要多个指令完成
    应用：绝大部分手机
2. 复杂指令集（CISC） complex instruction set computer
    特点：每个小指令可以执行一些低阶的硬件操作，指令多且复杂，长度不一
    应用：PC
</code></pre><h5 id="1-3-周边设备"><a href="#1-3-周边设备" class="headerlink" title="1.3 周边设备"></a>1.3 周边设备</h5><h5 id="1-4-运作流程"><a href="#1-4-运作流程" class="headerlink" title="1.4 运作流程"></a>1.4 运作流程</h5><pre><code>1. cpu-大脑
2. 主板-神经网络
3. 各项周边设备-手脚皮肤
4. 显卡：脑袋中的影像
5. 硬盘：大脑的记忆区块。
6. 主内存：与外界交互短暂保存的影像，***硬盘的数据需要转换到主内存中才能被CPU使用***
</code></pre><h5 id="1-5-計算机分类"><a href="#1-5-計算机分类" class="headerlink" title="1.5 計算机分类"></a>1.5 計算机分类</h5><pre><code>* 超级计算机(Supercomputer)
* 大型计算机(Mainframe Computer)
* 迷你计算机(Minicomputer)
* 工作站(Workstation)
* 微计算机(Microcomputer) 又可以称为个人计算机
</code></pre><h5 id="1-6-計算机上面常用的计算单位-容量、速度等"><a href="#1-6-計算机上面常用的计算单位-容量、速度等" class="headerlink" title="1.6 計算机上面常用的计算单位 (容量、速度等)"></a>1.6 計算机上面常用的计算单位 (容量、速度等)</h5><pre><code>1. bit:0/1 的单位我们称为bit
2. byte: 1byte = 8bits
3. 容量单位用二进制
4. 速度单位用十进制：1GHz = 1000 * 1000 * 1000 Hz
5. 带宽：Mbps Mbit per second 每秒多少Mbit。8M带宽=8Mbits/s = 1Mbytes/s上行和下行速度
6. 硬盘用十进位的单位，所以500GByte代表为500*1000*1000*1000Byte之意。 转成档案的容量单位时使用二进位(1024为底)，所以就成为466GB左右的容量了
7. 硬盘的最小物理量为512Bytes，最小的组成单位为磁区(sector)， 通常硬盘容量的计算采用『多少个sector』
</code></pre><h4 id="2-个人计算机架构与周边设备"><a href="#2-个人计算机架构与周边设备" class="headerlink" title="2. 个人计算机架构与周边设备"></a>2. 个人计算机架构与周边设备</h4><h5 id="2-1-CPU：-CPU的外频与倍频-32位与64位-CPU等级"><a href="#2-1-CPU：-CPU的外频与倍频-32位与64位-CPU等级" class="headerlink" title="2.1 CPU： CPU的外频与倍频, 32位与64位, CPU等级"></a>2.1 CPU： CPU的外频与倍频, 32位与64位, CPU等级</h5><pre><code>0. PC的CPU架构：
    * 北桥：负责连结速度较快的CPU、主内存与显示卡等组件；
    * 南桥：负责连接速度较慢的周边介面， 包括硬盘、USB、网络卡等等。
1. 多核是指一颗cpu封装多个运算核心
2. 不同cpu的脚位不同，需要配套相应主板才能使用
3. cpu的性能影响因素：*微指令集* 和 *频率*
CPU频率为3.0GHz， 表示这颗CPU在一秒内可以进行3.0x109次工作
4. 不同的CPU之间不能单纯的以频率来判断运算效能喔！这是因为每颗CPU的微指令集不相同，架构也不见得一样， 每次频率能够进行的工作指令数也不同之故！所以，频率目前仅能用来比较同款CPU的速度！
5. 外频和倍频：外频指的是CPU与外部组件进行数据传输时的速度，倍频则是 CPU 内部用来加速工作效能的一个倍数， 两者相乘才是CPU的频率速度。我们以刚刚Intel Core 2 Duo E8400 CPU来说，他的频率是3.0GHz， 而外频是333MHz，因此倍频就是9倍罗！(3.0G=333Mx9, 其中1G=1000M)
6. 32位和64位：指北桥的系统总线（前端系统总线）的频宽。
7. 我们看到内存与北桥的频宽为12.8GBytes/s，亦即是1600MHz*64bits = 1600MHz*8Bytes = 12800MByes/s = 12.8GBytes/s
8. CPU每次能够处理的数据量称为字长大小(word size)， 字长大小依据CPU的设计而有32位与64位。我们现在所称的计算机是32或64位主要是依据这个 CPU解析的字长大小而来的！
9. 这也导致32位的CPU最多只能支持最大到4GBytes的内存。
</code></pre><h5 id="2-2-內存"><a href="#2-2-內存" class="headerlink" title="2.2 內存"></a>2.2 內存</h5><pre><code>1. 所以，通常越大的内存代表越快速的系统，这是因为系统不用常常释放一些内存内部的数据。 以服务器来说，主内存的容量有时比CPU的速度还要来的重要的！
2. 双通道：由於所有的数据都必须要存放在主内存，所以主内存的***数据宽度***当然是越大越好。 但传统的系统总线宽度一般大约仅达64位，为了要加大这个宽度，因此芯片组厂商就将两个主内存汇整在一起， 如果一支内存可达64位，两支内存就可以达到128位了，这就是双通道的设计理念。
3. CPU频率与主内存的关系：理论上两者的外频应该 ***一致***
4. CPU内部有第二层缓存(L2 cache)：就不需要北桥传输数据了。DRAM不能满足要求，此时就需要静态随机访问内存(Static Random Access Memory, SRAM)。但是其工艺成本高，不易做成大容量。
5. ROM（只读内存）：BIOS(Basic Input Output System)是一套程序，这套程序是写死到主机板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就是只读内存(Read Only Memory, ROM)。
6. 
</code></pre><h5 id="2-3-显卡（VGA-Video-Graphics-Array-）："><a href="#2-3-显卡（VGA-Video-Graphics-Array-）：" class="headerlink" title="2.3 显卡（VGA(Video Graphics Array)）："></a>2.3 显卡（VGA(Video Graphics Array)）：</h5><pre><code>一般对於图形影像的显示重点在於***解析度与色彩深度***，因为每个图像显示的颜色会占用掉内存， 因此显示卡上面会有一个内存的容量，这个显示卡内存容量将会影响到最终你的萤幕解析度与色彩深度的喔！
</code></pre><h5 id="2-4-硬盘与储存设备"><a href="#2-4-硬盘与储存设备" class="headerlink" title="2.4 硬盘与储存设备"></a>2.4 硬盘与储存设备</h5><pre><code>1. 简介：硬盘、软盘、MO、CD、DVD、磁带机、随身碟(快闪内存)、还有新一代的蓝光光驱等， 乃至於大型机器的区域网络储存设备(SAN, NAS)等等，都是可以用来储存数据的。而其中最常见的应该就是硬盘了吧！ 
2. 在硬盘盒里面其实是由许许多多的圆形磁碟盘、机械手臂、 磁碟读取头与主轴马达所组成的
3. 实际运作时， 主轴马达让磁碟盘转动，然后机械手臂可伸展让读取头在磁碟盘上头进行读写的动作。 
4. 整个磁碟盘上头好像有多个同心圆绘制出的圆形图，而由圆心以放射状的方式分割出磁碟的最小储存单位，那就是磁区(Sector)， 在物理组成分面，每个磁区大小为512Bytes，这个值是不会改变的。而磁区组成一个圆就成为磁轨(track)， 如果是在多碟的硬盘上面，在所有磁碟盘上面的同一个磁轨可以组成一个磁柱(Cylinder)， 磁柱也是一般我们分割硬盘时的最小单位了！
</code></pre><h5 id="2-5-PCI介面卡"><a href="#2-5-PCI介面卡" class="headerlink" title="2.5 PCI介面卡"></a>2.5 PCI介面卡</h5><h5 id="2-6-主机板"><a href="#2-6-主机板" class="headerlink" title="2.6 主机板"></a>2.6 主机板</h5><pre><code>CMOS与BIOS： CMOS主要的功能为记录主机板上面的重要参数， 包括系统时间、CPU电压与频率、各项设备的I/O位址与IRQ等，由於这些数据的记录要花费电力，因此主机板上面才有电池。 BIOS为写入到主机板上某一块 flash 或 EEPROM 的程序，他可以在开机的时候执行，以载入CMOS当中的参数， 并尝试呼叫储存装置中的开机程序，进一步进入操作系统当中。BIOS程序也可以修改CMOS中的数据， 每种主机板呼叫BIOS设定程序的按键都不同，一般桌上型计算机常见的是使用[del]按键进入BIOS设定画面。
</code></pre><h5 id="2-7-电源供应器"><a href="#2-7-电源供应器" class="headerlink" title="2.7 电源供应器"></a>2.7 电源供应器</h5><h5 id="2-8-选购须知"><a href="#2-8-选购须知" class="headerlink" title="2.8 选购须知"></a>2.8 选购须知</h5><h4 id="3-数据表示方式"><a href="#3-数据表示方式" class="headerlink" title="3. 数据表示方式"></a>3. 数据表示方式</h4><h5 id="3-1-数字系统"><a href="#3-1-数字系统" class="headerlink" title="3.1 数字系统"></a>3.1 数字系统</h5><pre><code>1. 使用二进制。
</code></pre><h5 id="3-2-文字编码系统"><a href="#3-2-文字编码系统" class="headerlink" title="3.2 文字编码系统"></a>3.2 文字编码系统</h5><pre><code>1. 既然计算机都只有记录0/1而已，甚至记录的数据都是使用byte/bit等单位来记录的，那么文字该如何记录啊？ 事实上文字档案也是被记录为0与1而已，而这个档案的内容要被取出来查阅时，必须要经过一个编码系统的处理才行。 所谓的『编码系统』可以想成是一个『字码对照表』
2. 常用的英文编码表为***ASCII系统*** ，这个编码系统中， 每个符号(英文、数字或符号等)都会占用***1bytes***的记录， 因此总共会有28=256种变化。至於中文字当中的编码系统目前最常用的就是big5这个编码表了。 每个中文字会占用2bytes，理论上最多可以有216=65536
3. 由国际组织ISO/IEC跳出来制订了所谓的Unicode编码系统， 我们常常称呼的UTF8或万国码的编码就是这个咚咚。
</code></pre><h4 id="4-软件程序运作"><a href="#4-软件程序运作" class="headerlink" title="4. 软件程序运作"></a>4. 软件程序运作</h4><h5 id="4-1-机器程序与编译程序"><a href="#4-1-机器程序与编译程序" class="headerlink" title="4.1 机器程序与编译程序"></a>4.1 机器程序与编译程序</h5><pre><code>1. 机器码运行的缺点
    需要了解机器语言：机器只认识0与1，因此你必须要学习直接写给机器看的语言！
    需要了解所有硬件的相关功能函数
    程序不具有可携性：每个CPU都有独特的微指令集，同样的，***每个硬件都有其功能函数***。 因此，你为A计算机写的程序，理论上是没有办法在B计算机上面运作的！而且程序码的修改非常困难！ 
    程序具有专一性：因为这样的程序必须要针对硬件功能函数来撰写
2. 高级程序语言编写完成通过编译器编译成机器码，解决了在不同计算机上运行的问题
3. 但是读取数据写入内存，需要分配内存区间并定位，需要重复撰写控制码问题。这就有了操作系统（System Operation）的诞生。
</code></pre><h5 id="4-2-操作系统"><a href="#4-2-操作系统" class="headerlink" title="4.2 操作系统"></a>4.2 操作系统</h5><pre><code>1. 操作系统核心(Kernel)
    1. 定义：操作系统(Operating System, OS)其实也是一组程序， 这组程序的重点在於管理计算机的所有活动以及驱动系统中的所有硬件。
    2. 那么操作系统的功能就是让CPU可以开始判断逻辑与运算数值、 让主内存可以开始载入/读出数据与程序码、让硬盘可以开始被存取、让网络卡可以开始传输数据、 让所有周边可以开始运转等等。总之，硬件的所有动作都必须要透过这个操作系统来达成就是了
    3. 核心程序所放置到内存当中的区块是受保护的！ 并且开机后就一直常驻在内存当中。
2. 系统呼叫(System Call)
    计算机系统主要由硬件构成，然后核心程序主要在管理硬件，提供合理的计算机系统资源分配(包括CPU资源、内存使用资源等等)， 因此只要硬件不同(如x86架构与RISC架构的CPU)，核心就得要进行修改才行。 
3. 在定义上，只要能够让计算机硬件正确无误的运作，那就算是操作系统了。所以说， 操作系统其实就是核心与其提供的介面工具，不过就如同上面讲的，因为最简单的核心缺乏了与使用者沟通的亲和介面， 所以在目前，一般我们提到的『操作系统』都会包含核心与相关的使用者应用软件呢！
4. 基本概念：
    操作系统是参照硬件的规格写成的
    操作系统只是在管理整个硬件资源，包括CPU，内存，输入输出设备
    应用程序都是参考OS提供的开发介面（接口）interface写成的。
5. 核心功能：
    1. 系统呼叫接口 system call interface
    2. 程序管理 process control
    3. 内存管理 memory management
    4. 文件系统管理 filesystem management
    5. 硬件驱动 device driver
6. 驱动程序
    1. 操作系统需要能驱动一个硬件，才能使用它
    2. 一般来说，硬件厂商根据操作系统提供的接口和规范开发驱动程序并提供给消费者。
</code></pre><h5 id="4-3-应用程序"><a href="#4-3-应用程序" class="headerlink" title="4.3 应用程序"></a>4.3 应用程序</h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/07/algorithms-sort/" itemprop="url">
                  《算法》读书笔记-排序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-07T19:00:00+08:00" content="2016-10-07">
              2016-10-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/10/07/algorithms-sort/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/07/algorithms-sort/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;最近在重新学习算法，以加深对算法及数据结构的理解，从而在工作中能够根据需求和场景选择合适的算法和数据结构，提升代码的质量和水平。</p>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="2-1-初级排序"><a href="#2-1-初级排序" class="headerlink" title="2.1 初级排序"></a>2.1 初级排序</h2><p>&nbsp;&nbsp;</p>
<h3 id="2-1-1-2-运行时间"><a href="#2-1-1-2-运行时间" class="headerlink" title="2.1.1.2 运行时间"></a>2.1.1.2 运行时间</h3><p>排序成本的模型：主要是 <strong><em>比较</em></strong> 和 <strong><em>交换</em></strong>。对于不需要比较的算法，计算其 <strong>访问数组的次数</strong>。</p>
<h3 id="2-1-2-选择排序"><a href="#2-1-2-选择排序" class="headerlink" title="2.1.2 选择排序"></a>2.1.2 选择排序</h3><ol>
<li>思路：在数组中找到 <strong><em>最小的元素</em></strong> 然后与数组第一个元素交换，再次找到 <em>剩下元素中最小的元素</em>，如此往复，直到将整个数组排序。</li>
<li><p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j&lt; N; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(less(a[j], a[min] ))min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        exch(a, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于长度为N的数组，选择排序需要 <strong><em>N2/2次比较</em></strong>和 <strong><em>N次交换</em></strong></p>
</li>
</ol>
<h3 id="2-1-3-插入排序"><a href="#2-1-3-插入排序" class="headerlink" title="2.1.3 插入排序"></a>2.1.3 插入排序</h3><ol>
<li>思路：将元素插入已经排序的部分有序数组中，在插入位置之后的数组元素向后移动。其需要时间取决于数组的元素的初始排序。</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &gt;  <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less(a[j], a[j-<span class="number">1</span>])) &#123;</span><br><span class="line">                exch(a[j], a[j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成本：平均需要~N2/4比较和~N2/4排序。最坏是~N2/2比较和~N2/2交换。最好情况需要N-1比较和0次交换</p>
</li>
<li>规律： 插入排序需要的 <strong><em>交换操作</em></strong> 和数组中 <strong><em>倒置</em></strong>的数量 <strong><em>相同</em></strong>，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。</li>
<li>选择排序和插入排序的时间都是 <strong><em>平方级别</em></strong>的。</li>
</ol>
<h3 id="2-1-6希尔排序"><a href="#2-1-6希尔排序" class="headerlink" title="2.1.6希尔排序"></a>2.1.6希尔排序</h3><ol>
<li>思路：希尔排序是基于插入排序做改进。<br>使数组中任意相隔为h的元素都是有序的，一个 <em>h有序</em>的数组就是 <em>h个相互独立的有序数组</em> 编织在一起组成的一个数组。</li>
<li><p>代码:此为升序排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">int</span> h =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+h; j&gt;= h &amp;&amp; less(a[j], a[j-h]);j- = h) &#123;</span><br><span class="line">                exch(a, j, j-h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h/<span class="number">3</span>;</span><br><span class="line">    &#125;                                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>成本：此算法在最坏情况下的比较次数和 <strong><em>N3/2</em></strong>成正比。希尔排序的运行时间突破了 <strong><em>平方级别</em></strong>。因为接下来的算法虽然比希尔排序高效，但是更复杂，所以<strong><em>先用希尔排序</em></strong>，再根据实际情况进行优化或者替代。</p>
</li>
</ol>
<h2 id="2-2-归并排序"><a href="#2-2-归并排序" class="headerlink" title="2.2 归并排序"></a>2.2 归并排序</h2><ol>
<li>思路：将数组分成两半进行排序，然后再归并到一起。如此递归，最终将数组排序。这种分治的思想有 <strong><em>自顶向下</em></strong>和 <strong><em>自底向上</em></strong>两种解决的方法。</li>
<li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个只有在lo hi相差1的时候才能保证merge的结果是有序的，所以到采用分治的思想</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo;k &lt;= hi;k++) &#123;</span><br><span class="line">        aux[k] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) a[k] = aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; h ) a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(a[i], a[j])) a[k] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> a[k] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>自顶向下的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span> <span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi -lo)/<span class="number">2</span>;</span><br><span class="line">    sort(a, lo, mid);</span><br><span class="line">    sort(a, mid+<span class="number">1</span>, hi);</span><br><span class="line">    merge(a, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自底向上的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz+=sz)&#123;<span class="comment">//子数组的大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N-sz; lo+=sz+sz)&#123;</span><br><span class="line">            merge (lo, lo+sz-<span class="number">1</span>, Math.min( (lo + sz + sz-<span class="number">1</span>) , (N-<span class="number">1</span>)) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>成本：时间与NlogN成正比；所需的额外空间和N成正比。需要 <strong><em>1/2NlgN至NlgN次比较</em></strong>，最多 <strong><em>6NlgN次访问</em></strong>。</li>
</ol>
<h2 id="2-3-快速排序"><a href="#2-3-快速排序" class="headerlink" title="2.3 快速排序"></a>2.3 快速排序</h2><ol>
<li>思路：快速排序也是采用分治思想。其与归并排序是互补的。归并排序递归调用发生在处理整个数组 <em>之前</em>，快速排序发生在处理整个数组 <em>之后</em>。归并排序数组被分成两半，快速排序数组被 <em>切分</em>取决于数组的内容。</li>
<li>代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi&lt;=lo)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> j = partition(a, lo, hi);<span class="comment">//找出切分的元素</span></span><br><span class="line">    sort(a, lo, j-<span class="number">1</span>);<span class="comment">//左边排序</span></span><br><span class="line">    sort(a, j+<span class="number">1</span>, hi);<span class="comment">//右边排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = a[lo];</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j =hi+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(less(a[++i],v))&#123;<span class="keyword">if</span>(i==hi)<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">while</span>(less(v,a[--j]))&#123;<span class="keyword">if</span>(j==lo)<span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j)<span class="keyword">break</span>;</span><br><span class="line">        exah(a,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    exah(a,lo,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三向切分的快速排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(lo &gt;= hi)<span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">int</span> lt =lo;</span><br><span class="line">   <span class="keyword">int</span> i =lo+<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> gt= hi;</span><br><span class="line">   <span class="keyword">int</span> v = a[lo];</span><br><span class="line">   <span class="keyword">while</span>(i &lt;= gt)&#123;</span><br><span class="line">       <span class="keyword">int</span> cmp = a.compare(v);</span><br><span class="line">       <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           exch(lt++,i++);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           exch(gt--,i++);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   sort(a,lo,lt-<span class="number">1</span>);</span><br><span class="line">   sort(a,gt+<span class="number">1</span>,hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-4-优先队列"><a href="#2-4-优先队列" class="headerlink" title="2.4 优先队列"></a>2.4 优先队列</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><ol>
<li>思路：<blockquote>
<p>当一棵二叉树的每个结点都大于等于它的两个子结点。这就是 <strong><em>堆有序</em></strong>。<br>二叉堆就是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存。<br>用N+1的数组来表示大小为N的堆</p>
</blockquote>
</li>
<li>代码：<br>由下至上的堆有序化（上浮）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swin</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>, k))&#123;</span><br><span class="line">        exch(a,k/<span class="number">2</span>,k);</span><br><span class="line">        k=k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由上至下的堆有序化（下浮）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">2</span>*k&lt;=N)&#123;</span><br><span class="line">        <span class="keyword">int</span> j =k*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (j&lt;N &amp;&amp; less(j, j+<span class="number">1</span>))&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!less(k, j))<span class="keyword">break</span>;</span><br><span class="line">        exch(k,j);</span><br><span class="line">        k = j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">队列重要方法的实现</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;<span class="comment">//索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Key v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//pq是一个数据</span></span><br><span class="line">        pq[++N] = v;</span><br><span class="line">        swin(N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">delMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Key max = pq[<span class="number">0</span>];</span><br><span class="line">        exch(<span class="number">1</span>,N--);</span><br><span class="line">        pq[N+<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-5另一种排序"><a href="#2-4-5另一种排序" class="headerlink" title="2.4.5另一种排序"></a>2.4.5另一种排序</h3><ol>
<li>思路：分为堆的构造和下沉排序。</li>
</ol>
<ul>
<li>堆的构造：扫描数组一半的数据，通过下沉操作构造出堆<blockquote>
<p>用下沉操作由N个元素组成的堆只需少于2N次比较以及少于N次交换</p>
</blockquote>
</li>
<li>从右到左将最后的堆元素与堆最大的元素（位置1的元素）交换，然后将最大的元素移除堆，即缩小堆的范围。而交换后的元素通过下沉操作到达合适的位置。有点类似 <strong><em>选择排序</em></strong>的思想。但是比较的次数少很多，因为堆能很快在未排序的部分找到最大的元素。</li>
</ul>
<h2 id="2-5-应用"><a href="#2-5-应用" class="headerlink" title="2.5 应用"></a>2.5 应用</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/headicon.jpg"
               alt="AaronChan" />
          <p class="site-author-name" itemprop="name">AaronChan</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">38</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Aaron-Chan" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AaronChan</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"aaronchan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  

</body>
</html>
